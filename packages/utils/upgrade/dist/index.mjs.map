{"version":3,"file":"index.mjs","sources":["../src/modules/timer/timer.ts","../src/modules/timer/constants.ts","../src/modules/format/formats.ts","../src/modules/npm/constants.ts","../src/modules/version/types.ts","../src/modules/version/semver.ts","../src/modules/version/range.ts","../src/modules/npm/package.ts","../src/modules/file-scanner/scanner.ts","../src/modules/runner/runner.ts","../src/modules/runner/code/code.ts","../src/modules/json/transform-api.ts","../src/modules/json/file.ts","../src/modules/runner/json/transform.ts","../src/modules/runner/json/json.ts","../src/modules/project/constants.ts","../src/modules/project/project.ts","../src/modules/project/utils.ts","../src/modules/error/utils.ts","../src/modules/codemod/constants.ts","../src/modules/codemod/codemod.ts","../src/modules/codemod-repository/constants.ts","../src/modules/codemod-repository/repository.ts","../src/modules/codemod-runner/codemod-runner.ts","../src/modules/upgrader/upgrader.ts","../src/modules/upgrader/constants.ts","../src/modules/requirement/requirement.ts","../src/tasks/upgrade/requirements/major.ts","../src/tasks/upgrade/requirements/common.ts","../src/tasks/upgrade/prompts/latest.ts","../src/tasks/upgrade/upgrade.ts","../src/tasks/codemods/utils.ts","../src/tasks/codemods/run-codemods.ts","../src/tasks/codemods/list-codemods.ts","../src/modules/logger/logger.ts","../src/modules/report/report.ts"],"sourcesContent":["import type { Timer as TimerInterface, TimeInterval } from './types';\r\n\r\nexport class Timer implements TimerInterface {\r\n  private interval!: TimeInterval;\r\n\r\n  constructor() {\r\n    this.reset();\r\n  }\r\n\r\n  get elapsedMs() {\r\n    const { start, end } = this.interval;\r\n\r\n    return end ? end - start : Date.now() - start;\r\n  }\r\n\r\n  get end() {\r\n    return this.interval.end;\r\n  }\r\n\r\n  get start() {\r\n    return this.interval.start;\r\n  }\r\n\r\n  stop() {\r\n    this.interval.end = Date.now();\r\n\r\n    return this.elapsedMs;\r\n  }\r\n\r\n  reset() {\r\n    this.interval = { start: Date.now(), end: null };\r\n\r\n    return this;\r\n  }\r\n}\r\n\r\nexport const timerFactory = () => new Timer();\r\n","export const ONE_SECOND_MS = 1000;\r\n","import CliTable3 from 'cli-table3';\r\nimport chalk from 'chalk';\r\n\r\nimport { constants as timerConstants } from '../timer';\r\n\r\nimport type { AppProject, PluginProject, ProjectType } from '../project';\r\nimport type { Codemod } from '../codemod';\r\nimport type { Version } from '../version';\r\nimport type { Report } from '../report';\r\n\r\nexport const path = (path: string) => chalk.blue(path);\r\n\r\nexport const version = (version: Version.LiteralVersion | Version.SemVer) => {\r\n  return chalk.italic.yellow(`v${version}`);\r\n};\r\n\r\nexport const codemodUID = (uid: string) => {\r\n  return chalk.bold.cyan(uid);\r\n};\r\n\r\nexport const projectDetails = (project: AppProject | PluginProject) => {\r\n  return `Project: TYPE=${projectType(project.type)}; CWD=${path(project.cwd)}; PATHS=${project.paths.map(path)}`;\r\n};\r\n\r\nexport const projectType = (type: ProjectType) => chalk.cyan(type);\r\n\r\nexport const versionRange = (range: Version.Range) => chalk.italic.yellow(range.raw);\r\n\r\nexport const transform = (transformFilePath: string) => chalk.cyan(transformFilePath);\r\n\r\nexport const highlight = (arg: unknown) => chalk.bold.underline(arg);\r\n\r\nexport const upgradeStep = (text: string, step: [current: number, total: number]) => {\r\n  return chalk.bold(`(${step[0]}/${step[1]}) ${text}...`);\r\n};\r\n\r\nexport const reports = (reports: Report.CodemodReport[]) => {\r\n  const rows = reports.map(({ codemod, report }, i) => {\r\n    const fIndex = chalk.grey(i);\r\n    const fVersion = chalk.magenta(codemod.version);\r\n    const fKind = chalk.yellow(codemod.kind);\r\n    const fFormattedTransformPath = chalk.cyan(codemod.format());\r\n    const fTimeElapsed =\r\n      i === 0\r\n        ? `${report.timeElapsed}s ${chalk.dim.italic('(cold start)')}`\r\n        : `${report.timeElapsed}s`;\r\n    const fAffected = report.ok > 0 ? chalk.green(report.ok) : chalk.grey(0);\r\n    const fUnchanged = report.ok === 0 ? chalk.red(report.nochange) : chalk.grey(report.nochange);\r\n\r\n    return [fIndex, fVersion, fKind, fFormattedTransformPath, fAffected, fUnchanged, fTimeElapsed];\r\n  });\r\n\r\n  const table = new CliTable3({\r\n    style: { compact: true },\r\n    head: [\r\n      chalk.bold.grey('N°'),\r\n      chalk.bold.magenta('Version'),\r\n      chalk.bold.yellow('Kind'),\r\n      chalk.bold.cyan('Name'),\r\n      chalk.bold.green('Affected'),\r\n      chalk.bold.red('Unchanged'),\r\n      chalk.bold.blue('Duration'),\r\n    ],\r\n  });\r\n\r\n  table.push(...rows);\r\n\r\n  return table.toString();\r\n};\r\n\r\nexport const codemodList = (codemods: Codemod.List) => {\r\n  type Row = [index: string, version: string, kind: string, name: string, uid: string];\r\n\r\n  const rows = codemods.map<Row>((codemod, index) => {\r\n    const fIndex = chalk.grey(index);\r\n    const fVersion = chalk.magenta(codemod.version);\r\n    const fKind = chalk.yellow(codemod.kind);\r\n    const fName = chalk.blue(codemod.format());\r\n    const fUID = codemodUID(codemod.uid);\r\n\r\n    return [fIndex, fVersion, fKind, fName, fUID] satisfies Row;\r\n  });\r\n\r\n  const table = new CliTable3({\r\n    style: { compact: true },\r\n    head: [\r\n      chalk.bold.grey('N°'),\r\n      chalk.bold.magenta('Version'),\r\n      chalk.bold.yellow('Kind'),\r\n      chalk.bold.blue('Name'),\r\n      chalk.bold.cyan('UID'),\r\n    ],\r\n  });\r\n\r\n  table.push(...rows);\r\n\r\n  return table.toString();\r\n};\r\n\r\nexport const durationMs = (elapsedMs: number) => {\r\n  const elapsedSeconds = (elapsedMs / timerConstants.ONE_SECOND_MS).toFixed(3);\r\n\r\n  return `${elapsedSeconds}s`;\r\n};\r\n","export const NPM_REGISTRY_URL = 'https://registry.npmjs.org';\r\n","export type Version = number;\r\n\r\nexport type LiteralVersion =\r\n  | `${Version}`\r\n  | `${Version}.${Version}`\r\n  | `${Version}.${Version}.${Version}`;\r\n\r\nexport type LiteralSemVer = `${Version}.${Version}.${Version}`;\r\n\r\nexport type { SemVer, Range } from 'semver';\r\n\r\nexport enum ReleaseType {\r\n  // Classic\r\n  Major = 'major',\r\n  Minor = 'minor',\r\n  Patch = 'patch',\r\n  // Other\r\n  Latest = 'latest',\r\n}\r\n","import semver from 'semver';\r\n\r\nimport * as Version from './types';\r\n\r\nexport const semVerFactory = (version: string): Version.SemVer => {\r\n  return new semver.SemVer(version);\r\n};\r\n\r\nexport const isLiteralSemVer = (str: string): str is Version.LiteralSemVer => {\r\n  const tokens = str.split('.');\r\n\r\n  return (\r\n    tokens.length === 3 &&\r\n    tokens.every((token) => !Number.isNaN(+token) && Number.isInteger(+token))\r\n  );\r\n};\r\n\r\nexport const isValidSemVer = (str: string) => semver.valid(str) !== null;\r\n\r\nexport const isSemverInstance = (value: unknown): value is semver.SemVer => {\r\n  return value instanceof semver.SemVer;\r\n};\r\n\r\nexport const isSemVerReleaseType = (str: string): str is Version.ReleaseType => {\r\n  return Object.values(Version.ReleaseType).includes(str as Version.ReleaseType);\r\n};\r\n","import semver from 'semver';\r\n\r\nimport * as Version from './types';\r\nimport { isSemverInstance, isSemVerReleaseType, semVerFactory } from './semver';\r\n\r\nexport const rangeFactory = (range: string): Version.Range => {\r\n  return new semver.Range(range);\r\n};\r\n\r\nexport const rangeFromReleaseType = (current: Version.SemVer, identifier: Version.ReleaseType) => {\r\n  switch (identifier) {\r\n    case Version.ReleaseType.Latest: {\r\n      // Match anything greater than the current version\r\n      return rangeFactory(`>${current.raw}`);\r\n    }\r\n    case Version.ReleaseType.Major: {\r\n      // For example, 4.15.4 returns 5.0.0\r\n      const nextMajor = semVerFactory(current.raw).inc('major');\r\n\r\n      // Using only the major version as the upper limit allows any minor,\r\n      // patch, or build version to be taken in the range.\r\n      //\r\n      // For example, if the current version is \"4.15.4\", incrementing the\r\n      // major version would result in \"5.0.0\".\r\n      // The generated rule is \">4.15.4 <=5\", allowing any version\r\n      // greater than \"4.15.4\" but less than \"6.0.0-0\".\r\n      return rangeFactory(`>${current.raw} <=${nextMajor.major}`);\r\n    }\r\n    case Version.ReleaseType.Minor: {\r\n      // For example, 4.15.4 returns 5.0.0\r\n      const nextMajor = semVerFactory(current.raw).inc('major');\r\n\r\n      // Using the <major>.<minor>.<patch> version as the upper limit allows any minor,\r\n      // patch, or build versions to be taken in the range.\r\n      //\r\n      // For example, if the current version is \"4.15.4\", incrementing the\r\n      // major version would result in \"5.0.0\".\r\n      // The generated rule is \">4.15.4 <5.0.0\", allowing any version\r\n      // greater than \"4.15.4\" but less than \"5.0.0\".\r\n      return rangeFactory(`>${current.raw} <${nextMajor.raw}`);\r\n    }\r\n    case Version.ReleaseType.Patch: {\r\n      // For example, 4.15.4 returns 4.16.0\r\n      const nextMinor = semVerFactory(current.raw).inc('minor');\r\n\r\n      // Using only the minor version as the upper limit allows any patch\r\n      // or build versions to be taken in the range.\r\n      //\r\n      // For example, if the current version is \"4.15.4\", incrementing the\r\n      // minor version would result in \"4.16.0\".\r\n      // The generated rule is \">4.15.4 <4.16.0\", allowing any version\r\n      // greater than \"4.15.4\" but less than \"4.16.0\".\r\n      return rangeFactory(`>${current.raw} <${nextMinor.raw}`);\r\n    }\r\n    default: {\r\n      throw new Error('Not implemented');\r\n    }\r\n  }\r\n};\r\n\r\nexport const rangeFromVersions = (\r\n  currentVersion: Version.SemVer,\r\n  target: Version.ReleaseType | Version.SemVer\r\n) => {\r\n  if (isSemverInstance(target)) {\r\n    return rangeFactory(`>${currentVersion.raw} <=${target.raw}`);\r\n  }\r\n\r\n  if (isSemVerReleaseType(target)) {\r\n    return rangeFromReleaseType(currentVersion, target);\r\n  }\r\n\r\n  throw new Error(`Invalid target set: ${target}`); // TODO: better errors\r\n};\r\n\r\nexport const isValidStringifiedRange = (str: string) => semver.validRange(str) !== null;\r\n\r\nexport const isRangeInstance = (range: unknown): range is semver.Range => {\r\n  return range instanceof semver.Range;\r\n};\r\n","import assert from 'node:assert';\r\nimport semver from 'semver';\r\n\r\nimport * as constants from './constants';\r\nimport { isLiteralSemVer } from '../version';\r\n\r\nimport type { Package as PackageInterface, NPMPackage, NPMPackageVersion } from './types';\r\nimport type { Version } from '../version';\r\n\r\nexport class Package implements PackageInterface {\r\n  name: string;\r\n\r\n  packageURL: string;\r\n\r\n  private npmPackage: NPMPackage | null;\r\n\r\n  constructor(name: string) {\r\n    this.name = name;\r\n    this.packageURL = `${constants.NPM_REGISTRY_URL}/${name}`;\r\n    this.npmPackage = null;\r\n  }\r\n\r\n  get isLoaded() {\r\n    return this.npmPackage !== null;\r\n  }\r\n\r\n  private assertPackageIsLoaded(npmPackage: NPMPackage | null): asserts npmPackage is NPMPackage {\r\n    assert(this.isLoaded, 'The package is not loaded yet');\r\n  }\r\n\r\n  getVersionsDict() {\r\n    this.assertPackageIsLoaded(this.npmPackage);\r\n\r\n    return this.npmPackage.versions;\r\n  }\r\n\r\n  getVersionsAsList() {\r\n    this.assertPackageIsLoaded(this.npmPackage);\r\n\r\n    return Object.values(this.npmPackage.versions);\r\n  }\r\n\r\n  findVersionsInRange(range: Version.Range) {\r\n    const versions = this.getVersionsAsList();\r\n\r\n    return (\r\n      versions\r\n        // Only select versions matching the upgrade range\r\n        .filter((v) => range.test(v.version))\r\n        // Only select supported version format (x.x.x)\r\n        .filter((v) => isLiteralSemVer(v.version))\r\n        // Sort in ascending order\r\n        .sort((v1, v2) => semver.compare(v1.version, v2.version))\r\n    );\r\n  }\r\n\r\n  findVersion(version: Version.SemVer): NPMPackageVersion | undefined {\r\n    const versions = this.getVersionsAsList();\r\n\r\n    return versions.find((npmVersion) => semver.eq(npmVersion.version, version));\r\n  }\r\n\r\n  async refresh() {\r\n    const response = await fetch(this.packageURL);\r\n\r\n    // TODO: Use a validation library to make sure the response structure is correct\r\n    assert(response.ok, `Request failed for ${this.packageURL}`);\r\n\r\n    this.npmPackage = await response.json();\r\n\r\n    return this;\r\n  }\r\n\r\n  versionExists(version: Version.SemVer) {\r\n    return this.findVersion(version) !== undefined;\r\n  }\r\n}\r\n\r\nexport const npmPackageFactory = (name: string) => new Package(name);\r\n","import path from 'node:path';\r\nimport fastglob from 'fast-glob';\r\n\r\nimport type { FileScanner as FileScannerInterface } from './types';\r\n\r\nexport class FileScanner implements FileScannerInterface {\r\n  public cwd: string;\r\n\r\n  constructor(cwd: string) {\r\n    this.cwd = cwd;\r\n  }\r\n\r\n  scan(patterns: string[]) {\r\n    // we use fastglob instead of glob because it supports negation patterns\r\n    const filenames = fastglob.sync(patterns, {\r\n      cwd: this.cwd,\r\n    });\r\n\r\n    // Resolve the full paths for every filename\r\n    return filenames.map((filename) => path.join(this.cwd, filename));\r\n  }\r\n}\r\n\r\nexport const fileScannerFactory = (cwd: string) => new FileScanner(cwd);\r\n","import type { Codemod } from '../codemod';\r\n\r\nimport type { Runner as RunnerInterface, RunnerConfiguration, RunnerFunction } from './types';\r\n\r\nexport abstract class AbstractRunner<TConfig extends RunnerConfiguration>\r\n  implements RunnerInterface<TConfig>\r\n{\r\n  abstract runner: RunnerFunction<TConfig>;\r\n\r\n  paths: string[];\r\n\r\n  configuration: TConfig;\r\n\r\n  constructor(paths: string[], configuration: TConfig) {\r\n    this.paths = paths;\r\n    this.configuration = configuration;\r\n  }\r\n\r\n  async run(codemod: Codemod.Codemod, configuration?: TConfig) {\r\n    const isValidCodemod = this.valid(codemod);\r\n\r\n    if (!isValidCodemod) {\r\n      throw new Error(`Invalid codemod provided to the runner: ${codemod.filename}`);\r\n    }\r\n\r\n    const runConfiguration: TConfig = { ...this.configuration, ...configuration };\r\n\r\n    return this.runner(codemod.path, this.paths, runConfiguration);\r\n  }\r\n\r\n  abstract valid(codemod: Codemod.Codemod): boolean;\r\n}\r\n","import { run as jscodeshift } from 'jscodeshift/src/Runner';\r\n\r\nimport { AbstractRunner } from '../runner';\r\n\r\nimport type { Codemod } from '../../codemod';\r\nimport type { CodeRunnerConfiguration } from './types';\r\n\r\nexport class CodeRunner extends AbstractRunner<CodeRunnerConfiguration> {\r\n  runner = jscodeshift;\r\n\r\n  valid(codemod: Codemod.Codemod): boolean {\r\n    return codemod.kind === 'code';\r\n  }\r\n}\r\n\r\nexport const codeRunnerFactory = (paths: string[], configuration: CodeRunnerConfiguration) => {\r\n  return new CodeRunner(paths, configuration);\r\n};\r\n","import { cloneDeep, get, has, set, merge, omit } from 'lodash/fp';\r\n\r\nimport type { Utils } from '@strapi/types';\r\n\r\nimport type { JSONTransformAPI as JSONTransformAPIInterface } from './types';\r\n\r\nexport class JSONTransformAPI implements JSONTransformAPIInterface {\r\n  private json: Utils.JSONObject;\r\n\r\n  constructor(json: Utils.JSONObject) {\r\n    this.json = cloneDeep(json);\r\n  }\r\n\r\n  get<T extends Utils.JSONValue>(path: string): T | undefined;\r\n  get<T extends Utils.JSONValue>(path: string, defaultValue: T): T;\r\n  get<T extends Utils.JSONValue>(path?: string, defaultValue?: T) {\r\n    if (!path) {\r\n      return this.root() as T;\r\n    }\r\n\r\n    return cloneDeep(get(path, this.json) ?? defaultValue) as T;\r\n  }\r\n\r\n  has(path: string) {\r\n    return has(path, this.json);\r\n  }\r\n\r\n  merge(other: Utils.JSONObject) {\r\n    this.json = merge(other, this.json);\r\n\r\n    return this;\r\n  }\r\n\r\n  root(): Utils.JSONObject {\r\n    return cloneDeep(this.json);\r\n  }\r\n\r\n  set(path: string, value: Utils.JSONValue) {\r\n    this.json = set(path, value, this.json);\r\n\r\n    return this;\r\n  }\r\n\r\n  remove(path: string) {\r\n    this.json = omit(path, this.json);\r\n    return this;\r\n  }\r\n}\r\n\r\nexport const createJSONTransformAPI = (object: Utils.JSONObject) => new JSONTransformAPI(object);\r\n","import fse from 'fs-extra';\r\n\r\nimport type { Utils } from '@strapi/types';\r\n\r\nexport const readJSON = async (path: string): Promise<Utils.JSONValue> => {\r\n  const buffer = await fse.readFile(path);\r\n\r\n  return JSON.parse(buffer.toString());\r\n};\r\n\r\nexport const saveJSON = async (path: string, json: Utils.JSONValue): Promise<void> => {\r\n  const jsonAsString = `${JSON.stringify(json, null, 2)}\\n`;\r\n\r\n  await fse.writeFile(path, jsonAsString);\r\n};\r\n","/* eslint-disable @typescript-eslint/no-var-requires */\r\n\r\nimport assert from 'node:assert';\r\nimport { isEqual } from 'lodash/fp';\r\nimport { register } from 'esbuild-register/dist/node';\r\n\r\nimport { createJSONTransformAPI, readJSON, saveJSON } from '../../json';\r\n\r\nimport type { Report } from '../../report';\r\n\r\nimport type { JSONRunnerConfiguration, JSONSourceFile, JSONTransformParams } from './types';\r\n\r\nexport const transformJSON = async (\r\n  codemodPath: string,\r\n  paths: string[],\r\n  config: JSONRunnerConfiguration\r\n): Promise<Report.Report> => {\r\n  const { dry } = config;\r\n  const startTime = process.hrtime();\r\n\r\n  const report: Report.Report = {\r\n    ok: 0,\r\n    nochange: 0,\r\n    skip: 0,\r\n    error: 0,\r\n    timeElapsed: '',\r\n    stats: {},\r\n  };\r\n\r\n  /**\r\n   * Why do we need to include node_modules (hookIgnoreNodeModules) and specify a matcher (hookMatcher) to esbuild?\r\n   *\r\n   * When using tools like npx or dlx, the execution context is different from when running the program in a local\r\n   * project. npx and dlx run the commands in a temporary installation, which is isolated from local project files.\r\n   *\r\n   * When hookIgnoreNodeModules is not specified (or set to true), esbuild-register instructs\r\n   * Pirates (https://github.com/danez/pirates) to not transpile any files that come from node_modules.\r\n   *\r\n   * Now, when using npx or dlx to run a script, its location can be seen as \"external\" because it's not part of\r\n   * the temporary environment where npx or dlx execute. Therefore, it's considered to be part of node_modules.\r\n   *\r\n   * Due to this, if hookIgnoreNodeModules is set to true or left unspecified,\r\n   * esbuild-register won't try to compile them upon require.\r\n   *\r\n   * hookMatcher is added to make sure we're not matching anything else than our codemod in external directories.\r\n   */\r\n  const esbuildOptions = {\r\n    extensions: ['.js', '.mjs', '.ts'],\r\n    hookIgnoreNodeModules: false,\r\n    hookMatcher: isEqual(codemodPath),\r\n  };\r\n  const { unregister } = register(esbuildOptions);\r\n\r\n  const module = require(codemodPath);\r\n\r\n  unregister();\r\n\r\n  const codemod = typeof module.default === 'function' ? module.default : module;\r\n\r\n  assert(typeof codemod === 'function', `Codemod must be a function. Found ${typeof codemod}`);\r\n\r\n  for (const path of paths) {\r\n    try {\r\n      const json = await readJSON(path);\r\n\r\n      // Make sure the JSON value is a JSON object\r\n      assert(typeof json === 'object' && !Array.isArray(json) && json !== null);\r\n\r\n      // TODO: Optimize the API to limit parse/stringify operations\r\n      const file: JSONSourceFile = { path, json };\r\n      const params: JSONTransformParams = { cwd: config.cwd, json: createJSONTransformAPI };\r\n\r\n      const out = await codemod(file, params);\r\n\r\n      if (out === undefined) {\r\n        report.error += 1;\r\n      }\r\n      // If the json object has modifications\r\n      else if (!isEqual(json, out)) {\r\n        if (!dry) {\r\n          await saveJSON(path, out);\r\n        }\r\n        report.ok += 1;\r\n      }\r\n      // No changes\r\n      else {\r\n        report.nochange += 1;\r\n      }\r\n    } catch {\r\n      report.error += 1;\r\n    }\r\n  }\r\n\r\n  const endTime = process.hrtime(startTime);\r\n  report.timeElapsed = (endTime[0] + endTime[1] / 1e9).toFixed(3);\r\n\r\n  return report;\r\n};\r\n","import { AbstractRunner } from '../runner';\r\n\r\nimport { transformJSON } from './transform';\r\n\r\nimport type { Codemod } from '../../codemod';\r\nimport type { JSONRunnerConfiguration } from './types';\r\n\r\nexport class JSONRunner extends AbstractRunner<JSONRunnerConfiguration> {\r\n  runner = transformJSON;\r\n\r\n  valid(codemod: Codemod.Codemod): boolean {\r\n    return codemod.kind === 'json';\r\n  }\r\n}\r\n\r\nexport const jsonRunnerFactory = (paths: string[], configuration: JSONRunnerConfiguration) => {\r\n  return new JSONRunner(paths, configuration);\r\n};\r\n","export const PROJECT_PACKAGE_JSON = 'package.json';\r\n\r\nexport const PROJECT_APP_ALLOWED_ROOT_PATHS = ['src', 'config', 'public'];\r\n\r\nexport const PROJECT_PLUGIN_ALLOWED_ROOT_PATHS = ['admin', 'server'];\r\n\r\nexport const PROJECT_PLUGIN_ROOT_FILES = ['strapi-admin.js', 'strapi-server.js'];\r\n\r\nexport const PROJECT_CODE_EXTENSIONS = [\r\n  // Source files\r\n  'js',\r\n  'mjs',\r\n  'ts',\r\n  // React files\r\n  'jsx',\r\n  'tsx',\r\n];\r\n\r\nexport const PROJECT_JSON_EXTENSIONS = ['json'];\r\n\r\nexport const PROJECT_ALLOWED_EXTENSIONS = [...PROJECT_CODE_EXTENSIONS, ...PROJECT_JSON_EXTENSIONS];\r\n\r\nexport const SCOPED_STRAPI_PACKAGE_PREFIX = '@strapi/';\r\n\r\nexport const STRAPI_DEPENDENCY_NAME = `${SCOPED_STRAPI_PACKAGE_PREFIX}strapi`;\r\n","import path from 'node:path';\r\nimport assert from 'node:assert';\r\nimport fse from 'fs-extra';\r\nimport semver from 'semver';\r\n\r\nimport { semVerFactory, isLiteralSemVer, isValidSemVer } from '../version';\r\nimport { fileScannerFactory } from '../file-scanner';\r\nimport { codeRunnerFactory } from '../runner/code';\r\nimport { jsonRunnerFactory } from '../runner/json';\r\nimport * as constants from './constants';\r\n\r\nimport type { Version } from '../version';\r\nimport type { Codemod } from '../codemod';\r\nimport type { Report } from '../report';\r\nimport type {\r\n  FileExtension,\r\n  MinimalPackageJSON,\r\n  ProjectConfig,\r\n  ProjectType,\r\n  RunCodemodsOptions,\r\n} from './types';\r\n\r\nexport class Project {\r\n  public cwd: string;\r\n\r\n  // The following properties are assigned during the .refresh() call in the constructor.\r\n\r\n  public files!: string[];\r\n\r\n  public packageJSONPath!: string;\r\n\r\n  public packageJSON!: MinimalPackageJSON;\r\n\r\n  public readonly paths: string[];\r\n\r\n  constructor(cwd: string, config: ProjectConfig) {\r\n    if (!fse.pathExistsSync(cwd)) {\r\n      throw new Error(`ENOENT: no such file or directory, access '${cwd}'`);\r\n    }\r\n\r\n    this.cwd = cwd;\r\n    this.paths = config.paths;\r\n\r\n    this.refresh();\r\n  }\r\n\r\n  getFilesByExtensions(extensions: FileExtension[]) {\r\n    return this.files.filter((filePath) => {\r\n      const fileExtension = path.extname(filePath) as FileExtension;\r\n\r\n      return extensions.includes(fileExtension);\r\n    });\r\n  }\r\n\r\n  refresh() {\r\n    this.refreshPackageJSON();\r\n    this.refreshProjectFiles();\r\n\r\n    return this;\r\n  }\r\n\r\n  async runCodemods(codemods: Codemod.List, options: RunCodemodsOptions) {\r\n    const runners = this.createProjectCodemodsRunners(options.dry);\r\n    const reports: Report.CodemodReport[] = [];\r\n\r\n    for (const codemod of codemods) {\r\n      for (const runner of runners) {\r\n        if (runner.valid(codemod)) {\r\n          const report = await runner.run(codemod);\r\n          reports.push({ codemod, report });\r\n        }\r\n      }\r\n    }\r\n\r\n    return reports;\r\n  }\r\n\r\n  private createProjectCodemodsRunners(dry: boolean = false) {\r\n    const jsonExtensions = constants.PROJECT_JSON_EXTENSIONS.map<FileExtension>((ext) => `.${ext}`);\r\n    const codeExtensions = constants.PROJECT_CODE_EXTENSIONS.map<FileExtension>((ext) => `.${ext}`);\r\n\r\n    const jsonFiles = this.getFilesByExtensions(jsonExtensions);\r\n    const codeFiles = this.getFilesByExtensions(codeExtensions);\r\n\r\n    const codeRunner = codeRunnerFactory(codeFiles, {\r\n      dry,\r\n      parser: 'ts',\r\n      runInBand: true,\r\n      babel: true,\r\n      extensions: constants.PROJECT_CODE_EXTENSIONS.join(','),\r\n      // Don't output any log coming from the runner\r\n      print: false,\r\n      silent: true,\r\n      verbose: 0,\r\n    });\r\n\r\n    const jsonRunner = jsonRunnerFactory(jsonFiles, { dry, cwd: this.cwd });\r\n\r\n    return [codeRunner, jsonRunner] as const;\r\n  }\r\n\r\n  private refreshPackageJSON(): void {\r\n    const packageJSONPath = path.join(this.cwd, constants.PROJECT_PACKAGE_JSON);\r\n\r\n    try {\r\n      fse.accessSync(packageJSONPath);\r\n    } catch {\r\n      throw new Error(`Could not find a ${constants.PROJECT_PACKAGE_JSON} file in ${this.cwd}`);\r\n    }\r\n\r\n    const packageJSONBuffer = fse.readFileSync(packageJSONPath);\r\n\r\n    this.packageJSONPath = packageJSONPath;\r\n    this.packageJSON = JSON.parse(packageJSONBuffer.toString());\r\n  }\r\n\r\n  private refreshProjectFiles(): void {\r\n    const scanner = fileScannerFactory(this.cwd);\r\n\r\n    this.files = scanner.scan(this.paths);\r\n  }\r\n}\r\n\r\nexport class AppProject extends Project {\r\n  public strapiVersion!: Version.SemVer;\r\n\r\n  readonly type = 'application' as const satisfies ProjectType;\r\n\r\n  /**\r\n   * Returns an array of allowed file paths for a Strapi application\r\n   *\r\n   * The resulting paths include app default files and the root package.json file.\r\n   */\r\n  private static get paths() {\r\n    const allowedRootPaths = formatGlobCollectionPattern(constants.PROJECT_APP_ALLOWED_ROOT_PATHS);\r\n    const allowedExtensions = formatGlobCollectionPattern(constants.PROJECT_ALLOWED_EXTENSIONS);\r\n\r\n    return [\r\n      // App default files\r\n      `./${allowedRootPaths}/**/*.${allowedExtensions}`,\r\n      `!./**/node_modules/**/*`,\r\n      `!./**/dist/**/*`,\r\n      // Root package.json file\r\n      constants.PROJECT_PACKAGE_JSON,\r\n    ];\r\n  }\r\n\r\n  constructor(cwd: string) {\r\n    super(cwd, { paths: AppProject.paths });\r\n    this.refreshStrapiVersion();\r\n  }\r\n\r\n  refresh() {\r\n    super.refresh();\r\n    this.refreshStrapiVersion();\r\n    return this;\r\n  }\r\n\r\n  private refreshStrapiVersion(): void {\r\n    this.strapiVersion =\r\n      // First try to get the strapi version from the package.json dependencies\r\n      this.findStrapiVersionFromProjectPackageJSON() ??\r\n      // If the version found is not a valid SemVer, get the Strapi version from the installed package\r\n      this.findLocallyInstalledStrapiVersion();\r\n  }\r\n\r\n  private findStrapiVersionFromProjectPackageJSON(): Version.SemVer | undefined {\r\n    const projectName = this.packageJSON.name;\r\n    const version = this.packageJSON.dependencies?.[constants.STRAPI_DEPENDENCY_NAME];\r\n\r\n    if (version === undefined) {\r\n      throw new Error(\r\n        `No version of ${constants.STRAPI_DEPENDENCY_NAME} was found in ${projectName}. Are you in a valid Strapi project?`\r\n      );\r\n    }\r\n\r\n    const isValidSemVer = isLiteralSemVer(version) && semver.valid(version) === version;\r\n\r\n    // We return undefined only if a strapi/strapi version is found, but it's not semver compliant\r\n    return isValidSemVer ? semVerFactory(version) : undefined;\r\n  }\r\n\r\n  private findLocallyInstalledStrapiVersion(): Version.SemVer {\r\n    const packageSearchText = `${constants.STRAPI_DEPENDENCY_NAME}/package.json`;\r\n\r\n    let strapiPackageJSONPath: string;\r\n    let strapiPackageJSON: MinimalPackageJSON;\r\n\r\n    try {\r\n      strapiPackageJSONPath = require.resolve(packageSearchText, { paths: [this.cwd] });\r\n      strapiPackageJSON = require(strapiPackageJSONPath);\r\n\r\n      assert(typeof strapiPackageJSON === 'object');\r\n    } catch {\r\n      throw new Error(\r\n        `Cannot resolve module \"${constants.STRAPI_DEPENDENCY_NAME}\" from paths [${this.cwd}]`\r\n      );\r\n    }\r\n\r\n    const strapiVersion = strapiPackageJSON.version;\r\n\r\n    if (!isValidSemVer(strapiVersion)) {\r\n      throw new Error(\r\n        `Invalid ${constants.STRAPI_DEPENDENCY_NAME} version found in ${strapiPackageJSONPath} (${strapiVersion})`\r\n      );\r\n    }\r\n\r\n    return semVerFactory(strapiVersion);\r\n  }\r\n}\r\n\r\nconst formatGlobCollectionPattern = (collection: string[]): string => {\r\n  assert(\r\n    collection.length > 0,\r\n    'Invalid pattern provided, the given collection needs at least 1 element'\r\n  );\r\n\r\n  return collection.length === 1 ? collection[0] : `{${collection}}`;\r\n};\r\n\r\nexport class PluginProject extends Project {\r\n  readonly type = 'plugin' as const satisfies ProjectType;\r\n\r\n  /**\r\n   * Returns an array of allowed file paths for a Strapi plugin\r\n   *\r\n   * The resulting paths include plugin default files, the root package.json file, and plugin-specific files.\r\n   */\r\n  private static get paths() {\r\n    const allowedRootPaths = formatGlobCollectionPattern(\r\n      constants.PROJECT_PLUGIN_ALLOWED_ROOT_PATHS\r\n    );\r\n    const allowedExtensions = formatGlobCollectionPattern(constants.PROJECT_ALLOWED_EXTENSIONS);\r\n\r\n    return [\r\n      // Plugin default files\r\n      `./${allowedRootPaths}/**/*.${allowedExtensions}`,\r\n      `!./**/node_modules/**/*`,\r\n      `!./**/dist/**/*`,\r\n      // Root package.json file\r\n      constants.PROJECT_PACKAGE_JSON,\r\n      // Plugin root files\r\n      ...constants.PROJECT_PLUGIN_ROOT_FILES,\r\n    ];\r\n  }\r\n\r\n  constructor(cwd: string) {\r\n    super(cwd, { paths: PluginProject.paths });\r\n  }\r\n}\r\n\r\nconst isPlugin = (cwd: string) => {\r\n  const packageJSONPath = path.join(cwd, constants.PROJECT_PACKAGE_JSON);\r\n\r\n  try {\r\n    fse.accessSync(packageJSONPath);\r\n  } catch {\r\n    throw new Error(`Could not find a ${constants.PROJECT_PACKAGE_JSON} file in ${cwd}`);\r\n  }\r\n\r\n  const packageJSONBuffer = fse.readFileSync(packageJSONPath);\r\n\r\n  const packageJSON = JSON.parse(packageJSONBuffer.toString());\r\n\r\n  return packageJSON?.strapi?.kind === 'plugin';\r\n};\r\n\r\n// TODO: make this async so we can use async file methods\r\nexport const projectFactory = (cwd: string) => {\r\n  fse.accessSync(cwd);\r\n\r\n  return isPlugin(cwd) ? new PluginProject(cwd) : new AppProject(cwd);\r\n};\r\n","import { AppProject, PluginProject } from './project';\r\n\r\nexport const isPluginProject = (project: unknown): project is PluginProject => {\r\n  return project instanceof PluginProject;\r\n};\r\n\r\nexport function assertPluginProject(project: unknown): asserts project is PluginProject {\r\n  if (!isPluginProject(project)) {\r\n    throw new Error('Project is not a plugin');\r\n  }\r\n}\r\n\r\nexport const isApplicationProject = (project: unknown): project is AppProject => {\r\n  return project instanceof AppProject;\r\n};\r\n\r\nexport function assertAppProject(project: unknown): asserts project is AppProject {\r\n  if (!isApplicationProject(project)) {\r\n    throw new Error('Project is not an application');\r\n  }\r\n}\r\n","import type { Version } from '../version';\r\n\r\nexport class UnexpectedError extends Error {\r\n  constructor() {\r\n    super('Unexpected Error');\r\n  }\r\n}\r\n\r\nexport class NPMCandidateNotFoundError extends Error {\r\n  target: Version.SemVer | Version.Range | Version.ReleaseType;\r\n\r\n  constructor(\r\n    target: Version.SemVer | Version.Range | Version.ReleaseType,\r\n    message: string = `Couldn't find a valid NPM candidate for \"${target}\"`\r\n  ) {\r\n    super(message);\r\n\r\n    this.target = target;\r\n  }\r\n}\r\n\r\nexport class AbortedError extends Error {\r\n  constructor(message: string = 'Upgrade aborted') {\r\n    super(message);\r\n  }\r\n}\r\n\r\nexport const unknownToError = (e: unknown): Error => {\r\n  if (e instanceof Error) {\r\n    return e;\r\n  }\r\n\r\n  if (typeof e === 'string') {\r\n    return new Error(e);\r\n  }\r\n\r\n  return new UnexpectedError();\r\n};\r\n","export const CODEMOD_CODE_SUFFIX = 'code';\r\n\r\nexport const CODEMOD_JSON_SUFFIX = 'json';\r\n\r\nexport const CODEMOD_ALLOWED_SUFFIXES = [CODEMOD_CODE_SUFFIX, CODEMOD_JSON_SUFFIX];\r\n\r\nexport const CODEMOD_EXTENSION = 'ts';\r\n\r\nexport const CODEMOD_FILE_REGEXP = new RegExp(\r\n  `^.+[.](${CODEMOD_ALLOWED_SUFFIXES.join('|')})[.]${CODEMOD_EXTENSION}$`\r\n);\r\n","import path from 'node:path';\r\n\r\nimport * as constants from './constants';\r\n\r\nimport type { Codemod as CodemodInterface, FormatOptions, Kind, UID } from './types';\r\nimport type { Version } from '../version';\r\n\r\ntype CreateCodemodPayload = Pick<\r\n  CodemodInterface,\r\n  'kind' | 'version' | 'baseDirectory' | 'filename'\r\n>;\r\n\r\nexport class Codemod implements CodemodInterface {\r\n  uid: UID;\r\n\r\n  kind: Kind;\r\n\r\n  version: Version.SemVer;\r\n\r\n  baseDirectory: string;\r\n\r\n  filename: string;\r\n\r\n  path: string;\r\n\r\n  constructor(options: CreateCodemodPayload) {\r\n    this.kind = options.kind;\r\n    this.version = options.version;\r\n    this.baseDirectory = options.baseDirectory;\r\n    this.filename = options.filename;\r\n\r\n    this.path = path.join(this.baseDirectory, this.version.raw, this.filename);\r\n    this.uid = this.createUID();\r\n  }\r\n\r\n  private createUID(): UID {\r\n    const name = this.format({ stripExtension: true, stripKind: true, stripHyphens: false });\r\n    const kind = this.kind;\r\n    const version = this.version.raw as Version.LiteralSemVer;\r\n\r\n    return `${version}-${name}-${kind}`;\r\n  }\r\n\r\n  format(options?: FormatOptions) {\r\n    const { stripExtension = true, stripKind = true, stripHyphens = true } = options ?? {};\r\n\r\n    let formatted = this.filename;\r\n\r\n    if (stripExtension) {\r\n      formatted = formatted.replace(new RegExp(`\\\\.${constants.CODEMOD_EXTENSION}$`, 'i'), '');\r\n    }\r\n\r\n    if (stripKind) {\r\n      formatted = formatted\r\n        .replace(`.${constants.CODEMOD_CODE_SUFFIX}`, '')\r\n        .replace(`.${constants.CODEMOD_JSON_SUFFIX}`, '');\r\n    }\r\n\r\n    if (stripHyphens) {\r\n      formatted = formatted.replaceAll('-', ' ');\r\n    }\r\n\r\n    return formatted;\r\n  }\r\n}\r\n\r\nexport const codemodFactory = (options: CreateCodemodPayload) => new Codemod(options);\r\n","import path from 'node:path';\r\n\r\nexport const INTERNAL_CODEMODS_DIRECTORY = path.join(\r\n  __dirname, // upgrade/dist\r\n  '..', // upgrade\r\n  'resources', // upgrade/resources\r\n  'codemods' // upgrade/resources/codemods\r\n);\r\n","import assert from 'node:assert';\r\nimport fse from 'fs-extra';\r\nimport semver from 'semver';\r\nimport path from 'node:path';\r\n\r\nimport { codemodFactory, constants } from '../codemod';\r\nimport { isRangeInstance, semVerFactory } from '../version';\r\n\r\nimport { INTERNAL_CODEMODS_DIRECTORY } from './constants';\r\n\r\nimport type { Codemod } from '../codemod';\r\nimport type { Version } from '../version';\r\n\r\nimport type { CodemodRepository as CodemodRepositoryInterface, FindQuery } from './types';\r\n\r\nexport class CodemodRepository implements CodemodRepositoryInterface {\r\n  private groups: Record<Version.LiteralSemVer, Codemod.Codemod[]>;\r\n\r\n  private versions: Version.SemVer[];\r\n\r\n  public cwd: string;\r\n\r\n  constructor(cwd: string) {\r\n    assert(fse.existsSync(cwd), `Invalid codemods directory provided \"${cwd}\"`);\r\n\r\n    this.cwd = cwd;\r\n\r\n    this.groups = {};\r\n    this.versions = [];\r\n  }\r\n\r\n  refresh() {\r\n    this.refreshAvailableVersions();\r\n    this.refreshAvailableFiles();\r\n\r\n    return this;\r\n  }\r\n\r\n  count(version: Version.SemVer) {\r\n    return this.findByVersion(version).length;\r\n  }\r\n\r\n  versionExists(version: Version.SemVer) {\r\n    return version.raw in this.groups;\r\n  }\r\n\r\n  has(uid: string) {\r\n    const result = this.find({ uids: [uid] });\r\n\r\n    if (result.length !== 1) {\r\n      return false;\r\n    }\r\n\r\n    const { codemods } = result[0];\r\n\r\n    return codemods.length === 1 && codemods[0].uid === uid;\r\n  }\r\n\r\n  find(q: FindQuery) {\r\n    const entries = Object.entries(this.groups) as Array<[Version.LiteralSemVer, Codemod.List]>;\r\n\r\n    return (\r\n      entries\r\n        // Filter by range if provided in the query\r\n        .filter(maybeFilterByRange)\r\n        // Transform version/codemods tuples into regular objects\r\n        .map<Codemod.VersionedCollection>(([version, codemods]) => ({\r\n          version: semVerFactory(version),\r\n          // Filter by UID if provided in the query\r\n          codemods: codemods.filter(maybeFilterByUIDs),\r\n        }))\r\n        // Only return groups with at least 1 codemod\r\n        .filter(({ codemods }) => codemods.length > 0)\r\n    );\r\n\r\n    function maybeFilterByRange([version]: [Version.LiteralSemVer, Codemod.List]) {\r\n      if (!isRangeInstance(q.range)) {\r\n        return true;\r\n      }\r\n\r\n      return q.range.test(version);\r\n    }\r\n\r\n    function maybeFilterByUIDs(codemod: Codemod.Codemod) {\r\n      if (q.uids === undefined) {\r\n        return true;\r\n      }\r\n\r\n      return q.uids.includes(codemod.uid);\r\n    }\r\n  }\r\n\r\n  findByVersion(version: Version.SemVer) {\r\n    const literalVersion = version.raw as Version.LiteralSemVer;\r\n    const codemods = this.groups[literalVersion];\r\n\r\n    return codemods ?? [];\r\n  }\r\n\r\n  findAll() {\r\n    const entries = Object.entries(this.groups);\r\n\r\n    return entries.map<Codemod.VersionedCollection>(([version, codemods]) => ({\r\n      version: semVerFactory(version),\r\n      codemods,\r\n    }));\r\n  }\r\n\r\n  private refreshAvailableVersions() {\r\n    this.versions = fse\r\n      .readdirSync(this.cwd) // Only keep root directories\r\n      .filter((filename) => fse.statSync(path.join(this.cwd, filename)).isDirectory())\r\n      // Paths should be valid semver\r\n      .filter((filename): filename is Version.LiteralSemVer => semver.valid(filename) !== null)\r\n      // Transform files names to SemVer instances\r\n      .map<Version.SemVer>((version) => semVerFactory(version))\r\n      // Sort versions in ascending order\r\n      .sort(semver.compare);\r\n\r\n    return this;\r\n  }\r\n\r\n  private refreshAvailableFiles() {\r\n    this.groups = {};\r\n\r\n    for (const version of this.versions) {\r\n      this.refreshAvailableFilesForVersion(version);\r\n    }\r\n  }\r\n\r\n  private refreshAvailableFilesForVersion(version: Version.SemVer) {\r\n    const literalVersion = version.raw as Version.LiteralSemVer;\r\n    const versionDirectory = path.join(this.cwd, literalVersion);\r\n\r\n    // Ignore obsolete versions\r\n    if (!fse.existsSync(versionDirectory)) {\r\n      return;\r\n    }\r\n\r\n    this.groups[literalVersion] = fse\r\n      .readdirSync(versionDirectory)\r\n      // Make sure the filenames are valid codemod files\r\n      .filter((filename) => fse.statSync(path.join(versionDirectory, filename)).isFile())\r\n      .filter((filename) => constants.CODEMOD_FILE_REGEXP.test(filename))\r\n      // Transform the filenames into Codemod instances\r\n      .map((filename) => {\r\n        const kind = parseCodemodKindFromFilename(filename);\r\n        const baseDirectory = this.cwd;\r\n\r\n        return codemodFactory({ kind, baseDirectory, version, filename });\r\n      });\r\n  }\r\n}\r\n\r\nexport const parseCodemodKindFromFilename = (filename: string): Codemod.Kind => {\r\n  const kind = filename.split('.').at(-2) as Codemod.Kind | undefined;\r\n\r\n  assert(kind !== undefined);\r\n  assert(constants.CODEMOD_ALLOWED_SUFFIXES.includes(kind));\r\n\r\n  return kind;\r\n};\r\n\r\nexport const codemodRepositoryFactory = (cwd: string = INTERNAL_CODEMODS_DIRECTORY) => {\r\n  return new CodemodRepository(cwd);\r\n};\r\n","import { groupBy, size } from 'lodash/fp';\r\n\r\nimport {\r\n  codemodRepositoryFactory,\r\n  constants as codemodRepositoryConstants,\r\n} from '../codemod-repository';\r\nimport { unknownToError } from '../error';\r\nimport { semVerFactory } from '../version';\r\nimport * as f from '../format';\r\n\r\nimport type { Codemod } from '../codemod';\r\nimport type { Logger } from '../logger';\r\nimport type { Project } from '../project';\r\nimport type { UpgradeReport } from '../upgrader';\r\nimport type { CodemodRunnerInterface, CodemodRunnerReport, SelectCodemodsCallback } from './types';\r\nimport type { Version } from '../version';\r\n\r\nexport class CodemodRunner implements CodemodRunnerInterface {\r\n  private readonly project: Project;\r\n\r\n  private range: Version.Range;\r\n\r\n  private isDry: boolean;\r\n\r\n  private logger: Logger | null;\r\n\r\n  private selectCodemodsCallback: SelectCodemodsCallback | null;\r\n\r\n  constructor(project: Project, range: Version.Range) {\r\n    this.project = project;\r\n    this.range = range;\r\n\r\n    this.isDry = false;\r\n\r\n    this.logger = null;\r\n    this.selectCodemodsCallback = null;\r\n  }\r\n\r\n  setRange(range: Version.Range) {\r\n    this.range = range;\r\n    return this;\r\n  }\r\n\r\n  setLogger(logger: Logger) {\r\n    this.logger = logger;\r\n    return this;\r\n  }\r\n\r\n  onSelectCodemods(callback: SelectCodemodsCallback | null) {\r\n    this.selectCodemodsCallback = callback;\r\n    return this;\r\n  }\r\n\r\n  dry(enabled: boolean = true) {\r\n    this.isDry = enabled;\r\n    return this;\r\n  }\r\n\r\n  private createRepository(codemodsDirectory?: string) {\r\n    const repository = codemodRepositoryFactory(\r\n      codemodsDirectory ?? codemodRepositoryConstants.INTERNAL_CODEMODS_DIRECTORY\r\n    );\r\n\r\n    // Make sure we have access to the latest snapshots of codemods on the system\r\n    repository.refresh();\r\n\r\n    return repository;\r\n  }\r\n\r\n  private async safeRunAndReport(codemods: Codemod.List) {\r\n    if (this.isDry) {\r\n      this.logger?.warn?.(\r\n        'Running the codemods in dry mode. No files will be modified during the process.'\r\n      );\r\n    }\r\n\r\n    try {\r\n      const reports = await this.project.runCodemods(codemods, { dry: this.isDry });\r\n\r\n      this.logger?.raw?.(f.reports(reports));\r\n\r\n      if (!this.isDry) {\r\n        const nbAffectedTotal = reports\r\n          .flatMap((report) => report.report.ok)\r\n          .reduce((acc, nb) => acc + nb, 0);\r\n\r\n        this.logger?.debug?.(\r\n          `Successfully ran ${f.highlight(codemods.length)} codemod(s), ${f.highlight(nbAffectedTotal)} change(s) have been detected`\r\n        );\r\n      }\r\n\r\n      return successReport();\r\n    } catch (e: unknown) {\r\n      return erroredReport(unknownToError(e));\r\n    }\r\n  }\r\n\r\n  async runByUID(uid: string, codemodsDirectory?: string): Promise<CodemodRunnerReport> {\r\n    const repository = this.createRepository(codemodsDirectory);\r\n\r\n    if (!repository.has(uid)) {\r\n      throw new Error(`Unknown codemod UID provided: ${uid}`);\r\n    }\r\n\r\n    // Note: Ignore the range when running with a UID\r\n    const codemods = repository.find({ uids: [uid] }).flatMap(({ codemods }) => codemods);\r\n\r\n    return this.safeRunAndReport(codemods);\r\n  }\r\n\r\n  async run(codemodsDirectory?: string): Promise<CodemodRunnerReport> {\r\n    const repository = this.createRepository(codemodsDirectory);\r\n\r\n    // Find codemods matching the given range\r\n    const codemodsInRange = repository.find({ range: this.range });\r\n\r\n    // If a selection callback is set, use it, else keep every codemods found\r\n    const selectedCodemods = this.selectCodemodsCallback\r\n      ? await this.selectCodemodsCallback(codemodsInRange)\r\n      : codemodsInRange;\r\n\r\n    // If no codemods have been selected (either manually or automatically)\r\n    // Then ignore and return a successful report\r\n    if (selectedCodemods.length === 0) {\r\n      this.logger?.debug?.(`Found no codemods to run for ${f.versionRange(this.range)}`);\r\n      return successReport();\r\n    }\r\n\r\n    // Flatten the collection to a single list of codemods, the original list should already be sorted by version\r\n    const codemods = selectedCodemods.flatMap(({ codemods }) => codemods);\r\n\r\n    // Log (debug) the codemods by version\r\n    const codemodsByVersion = groupBy('version', codemods);\r\n    const fRange = f.versionRange(this.range);\r\n\r\n    this.logger?.debug?.(\r\n      `Found ${f.highlight(codemods.length)} codemods for ${f.highlight(size(codemodsByVersion))} version(s) using ${fRange}`\r\n    );\r\n\r\n    for (const [version, codemods] of Object.entries(codemodsByVersion)) {\r\n      this.logger?.debug?.(`- ${f.version(semVerFactory(version))} (${codemods.length})`);\r\n    }\r\n\r\n    return this.safeRunAndReport(codemods);\r\n  }\r\n}\r\n\r\nexport const codemodRunnerFactory = (project: Project, range: Version.Range) => {\r\n  return new CodemodRunner(project, range);\r\n};\r\n\r\nconst successReport = (): UpgradeReport => ({ success: true, error: null });\r\nconst erroredReport = (error: Error): UpgradeReport => ({ success: false, error });\r\n","import chalk from 'chalk';\r\nimport semver from 'semver';\r\nimport { packageManager } from '@strapi/utils';\r\n\r\nimport { createJSONTransformAPI, saveJSON } from '../json';\r\nimport { constants as projectConstants } from '../project';\r\nimport {\r\n  isSemverInstance,\r\n  isSemVerReleaseType,\r\n  isValidSemVer,\r\n  rangeFromVersions,\r\n  semVerFactory,\r\n} from '../version';\r\nimport { NPMCandidateNotFoundError, unknownToError } from '../error';\r\nimport * as f from '../format';\r\nimport { codemodRunnerFactory } from '../codemod-runner';\r\n\r\nimport type { Upgrader as UpgraderInterface, UpgradeReport } from './types';\r\nimport type { Version } from '../version';\r\nimport type { Logger } from '../logger';\r\nimport type { Requirement } from '../requirement';\r\nimport type { NPM } from '../npm';\r\nimport type { AppProject } from '../project';\r\nimport type { ConfirmationCallback } from '../common/types';\r\n\r\ntype DependenciesEntries = Array<[name: string, version: Version.SemVer]>;\r\n\r\nexport class Upgrader implements UpgraderInterface {\r\n  private readonly project: AppProject;\r\n\r\n  private readonly npmPackage: NPM.Package;\r\n\r\n  private target: Version.SemVer;\r\n\r\n  private codemodsTarget!: Version.SemVer;\r\n\r\n  private isDry: boolean;\r\n\r\n  private logger: Logger | null;\r\n\r\n  private requirements: Requirement.Requirement[];\r\n\r\n  private confirmationCallback: ConfirmationCallback | null;\r\n\r\n  constructor(project: AppProject, target: Version.SemVer, npmPackage: NPM.Package) {\r\n    this.project = project;\r\n    this.npmPackage = npmPackage;\r\n\r\n    this.target = target;\r\n    this.syncCodemodsTarget();\r\n\r\n    this.isDry = false;\r\n\r\n    this.requirements = [];\r\n\r\n    this.logger = null;\r\n    this.confirmationCallback = null;\r\n  }\r\n\r\n  getNPMPackage(): NPM.Package {\r\n    return this.npmPackage;\r\n  }\r\n\r\n  getProject(): AppProject {\r\n    return this.project;\r\n  }\r\n\r\n  getTarget(): Version.SemVer {\r\n    return semVerFactory(this.target.raw);\r\n  }\r\n\r\n  setRequirements(requirements: Requirement.Requirement[]) {\r\n    this.requirements = requirements;\r\n    return this;\r\n  }\r\n\r\n  setTarget(target: Version.SemVer) {\r\n    this.target = target;\r\n    return this;\r\n  }\r\n\r\n  syncCodemodsTarget() {\r\n    // Extract the <major>.<minor>.<patch> version from the target and assign it to the codemods target\r\n    //\r\n    // This is useful when dealing with alphas, betas or release candidates:\r\n    // e.g. \"5.0.0-beta.951\" becomes \"5.0.0\"\r\n    //\r\n    // For experimental versions (e.g. \"0.0.0-experimental.hex\"), it is necessary to\r\n    // override the codemods target manually in order to run the appropriate ones.\r\n    this.codemodsTarget = semVerFactory(\r\n      `${this.target.major}.${this.target.minor}.${this.target.patch}`\r\n    );\r\n\r\n    this.logger?.debug?.(\r\n      `The codemods target has been synced with the upgrade target. The codemod runner will now look for ${f.version(\r\n        this.codemodsTarget\r\n      )}`\r\n    );\r\n\r\n    return this;\r\n  }\r\n\r\n  overrideCodemodsTarget(target: Version.SemVer) {\r\n    this.codemodsTarget = target;\r\n\r\n    this.logger?.debug?.(\r\n      `Overriding the codemods target. The codemod runner will now look for ${f.version(target)}`\r\n    );\r\n\r\n    return this;\r\n  }\r\n\r\n  setLogger(logger: Logger) {\r\n    this.logger = logger;\r\n    return this;\r\n  }\r\n\r\n  onConfirm(callback: ConfirmationCallback | null) {\r\n    this.confirmationCallback = callback;\r\n    return this;\r\n  }\r\n\r\n  dry(enabled: boolean = true) {\r\n    this.isDry = enabled;\r\n    return this;\r\n  }\r\n\r\n  addRequirement(requirement: Requirement.Requirement) {\r\n    this.requirements.push(requirement);\r\n\r\n    const fRequired = requirement.isRequired ? '(required)' : '(optional)';\r\n    this.logger?.debug?.(\r\n      `Added a new requirement to the upgrade: ${f.highlight(requirement.name)} ${fRequired}`\r\n    );\r\n\r\n    return this;\r\n  }\r\n\r\n  async upgrade(): Promise<UpgradeReport> {\r\n    this.logger?.info?.(\r\n      `Upgrading from ${f.version(this.project.strapiVersion)} to ${f.version(this.target)}`\r\n    );\r\n\r\n    if (this.isDry) {\r\n      this.logger?.warn?.(\r\n        'Running the upgrade in dry mode. No files will be modified during the process.'\r\n      );\r\n    }\r\n\r\n    const range = rangeFromVersions(this.project.strapiVersion, this.target);\r\n    const codemodsRange = rangeFromVersions(this.project.strapiVersion, this.codemodsTarget);\r\n\r\n    const npmVersionsMatches = this.npmPackage?.findVersionsInRange(range) ?? [];\r\n\r\n    this.logger?.debug?.(\r\n      `Found ${f.highlight(npmVersionsMatches.length)} versions satisfying ${f.versionRange(range)}`\r\n    );\r\n\r\n    try {\r\n      this.logger?.info?.(f.upgradeStep('Checking requirement', [1, 4]));\r\n      await this.checkRequirements(this.requirements, {\r\n        npmVersionsMatches,\r\n        project: this.project,\r\n        target: this.target,\r\n      });\r\n\r\n      this.logger?.info?.(f.upgradeStep('Applying the latest code modifications', [2, 4]));\r\n      await this.runCodemods(codemodsRange);\r\n\r\n      // We need to refresh the project files to make sure we have\r\n      // the latest version of each file (including package.json) for the next steps\r\n      this.logger?.debug?.('Refreshing project information...');\r\n      this.project.refresh();\r\n\r\n      this.logger?.info?.(f.upgradeStep('Upgrading Strapi dependencies', [3, 4]));\r\n      await this.updateDependencies();\r\n\r\n      this.logger?.info?.(f.upgradeStep('Installing dependencies', [4, 4]));\r\n      await this.installDependencies();\r\n    } catch (e) {\r\n      return erroredReport(unknownToError(e));\r\n    }\r\n\r\n    return successReport();\r\n  }\r\n\r\n  async confirm(message: string): Promise<boolean> {\r\n    if (typeof this.confirmationCallback !== 'function') {\r\n      return true;\r\n    }\r\n\r\n    return this.confirmationCallback(message);\r\n  }\r\n\r\n  private async checkRequirements(\r\n    requirements: Requirement.Requirement[],\r\n    context: Requirement.TestContext\r\n  ) {\r\n    for (const requirement of requirements) {\r\n      const { pass, error } = await requirement.test(context);\r\n\r\n      if (pass) {\r\n        await this.onSuccessfulRequirement(requirement, context);\r\n      } else {\r\n        await this.onFailedRequirement(requirement, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  private async onSuccessfulRequirement(\r\n    requirement: Requirement.Requirement,\r\n    context: Requirement.TestContext\r\n  ): Promise<void> {\r\n    const hasChildren = requirement.children.length > 0;\r\n\r\n    if (hasChildren) {\r\n      await this.checkRequirements(requirement.children, context);\r\n    }\r\n  }\r\n\r\n  private async onFailedRequirement(\r\n    requirement: Requirement.Requirement,\r\n    originalError: Error\r\n  ): Promise<void> {\r\n    const errorMessage = `Requirement failed: ${originalError.message} (${f.highlight(\r\n      requirement.name\r\n    )})`;\r\n    const warningMessage = originalError.message;\r\n    const confirmationMessage = `Ignore optional requirement \"${f.highlight(requirement.name)}\" ?`;\r\n\r\n    const error = new Error(errorMessage);\r\n\r\n    if (requirement.isRequired) {\r\n      throw error;\r\n    }\r\n\r\n    this.logger?.warn?.(warningMessage);\r\n\r\n    const response = await this.confirmationCallback?.(confirmationMessage);\r\n\r\n    if (!response) {\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private async updateDependencies(): Promise<void> {\r\n    const { packageJSON, packageJSONPath } = this.project;\r\n\r\n    const json = createJSONTransformAPI(packageJSON);\r\n\r\n    const dependencies = json.get<Record<string, string>>('dependencies', {});\r\n    const strapiDependencies = this.getScopedStrapiDependencies(dependencies);\r\n\r\n    this.logger?.debug?.(\r\n      `Found ${f.highlight(strapiDependencies.length)} dependency(ies) to update`\r\n    );\r\n    strapiDependencies.forEach((dependency) =>\r\n      this.logger?.debug?.(`- ${dependency[0]} (${dependency[1]} -> ${this.target})`)\r\n    );\r\n\r\n    if (strapiDependencies.length === 0) {\r\n      return;\r\n    }\r\n\r\n    strapiDependencies.forEach(([name]) => json.set(`dependencies.${name}`, this.target.raw));\r\n\r\n    const updatedPackageJSON = json.root();\r\n\r\n    if (this.isDry) {\r\n      this.logger?.debug?.(`Skipping dependencies update (${chalk.italic('dry mode')})`);\r\n      return;\r\n    }\r\n\r\n    await saveJSON(packageJSONPath, updatedPackageJSON);\r\n  }\r\n\r\n  private getScopedStrapiDependencies(dependencies: Record<string, string>): DependenciesEntries {\r\n    const { strapiVersion } = this.project;\r\n\r\n    const strapiDependencies: DependenciesEntries = [];\r\n\r\n    // Find all @strapi/* packages matching the current Strapi version\r\n    for (const [name, version] of Object.entries(dependencies)) {\r\n      const isScopedStrapiPackage = name.startsWith(projectConstants.SCOPED_STRAPI_PACKAGE_PREFIX);\r\n      const isOnCurrentStrapiVersion = isValidSemVer(version) && version === strapiVersion.raw;\r\n\r\n      if (isScopedStrapiPackage && isOnCurrentStrapiVersion) {\r\n        strapiDependencies.push([name, semVerFactory(version)]);\r\n      }\r\n    }\r\n\r\n    return strapiDependencies;\r\n  }\r\n\r\n  private async installDependencies(): Promise<void> {\r\n    const projectPath = this.project.cwd;\r\n\r\n    const packageManagerName = await packageManager.getPreferred(projectPath);\r\n\r\n    this.logger?.debug?.(`Using ${f.highlight(packageManagerName)} as package manager`);\r\n\r\n    if (this.isDry) {\r\n      this.logger?.debug?.(`Skipping dependencies installation (${chalk.italic('dry mode')})`);\r\n      return;\r\n    }\r\n\r\n    await packageManager.installDependencies(projectPath, packageManagerName, {\r\n      stdout: this.logger?.stdout,\r\n      stderr: this.logger?.stderr,\r\n    });\r\n  }\r\n\r\n  private async runCodemods(range: Version.Range): Promise<void> {\r\n    const codemodRunner = codemodRunnerFactory(this.project, range);\r\n\r\n    codemodRunner.dry(this.isDry);\r\n\r\n    if (this.logger) {\r\n      codemodRunner.setLogger(this.logger);\r\n    }\r\n\r\n    await codemodRunner.run();\r\n  }\r\n}\r\n\r\n/**\r\n * Resolves the NPM target version based on the given project, target, and NPM package.\r\n * If target is a SemVer, it directly finds it. If it's a release type (major, minor, patch),\r\n * it calculates the range of versions for this release type and returns the latest version within this range.\r\n */\r\nconst resolveNPMTarget = (\r\n  project: AppProject,\r\n  target: Version.ReleaseType | Version.SemVer,\r\n  npmPackage: NPM.Package\r\n): NPM.NPMPackageVersion => {\r\n  // Semver\r\n  if (isSemverInstance(target)) {\r\n    const version = npmPackage.findVersion(target);\r\n\r\n    if (!version) {\r\n      throw new NPMCandidateNotFoundError(target);\r\n    }\r\n\r\n    return version;\r\n  }\r\n\r\n  // Release Types\r\n  if (isSemVerReleaseType(target)) {\r\n    const range = rangeFromVersions(project.strapiVersion, target);\r\n    const npmVersionsMatches = npmPackage.findVersionsInRange(range);\r\n\r\n    // The targeted version is the latest one that matches the given range\r\n    const version = npmVersionsMatches.at(-1);\r\n\r\n    if (!version) {\r\n      throw new NPMCandidateNotFoundError(range, `The project is already up-to-date (${target})`);\r\n    }\r\n\r\n    return version;\r\n  }\r\n\r\n  throw new NPMCandidateNotFoundError(target);\r\n};\r\n\r\nexport const upgraderFactory = (\r\n  project: AppProject,\r\n  target: Version.ReleaseType | Version.SemVer,\r\n  npmPackage: NPM.Package\r\n) => {\r\n  const npmTarget = resolveNPMTarget(project, target, npmPackage);\r\n  const semverTarget = semVerFactory(npmTarget.version);\r\n\r\n  if (semver.eq(semverTarget, project.strapiVersion)) {\r\n    throw new Error(`The project is already using v${semverTarget}`);\r\n  }\r\n\r\n  return new Upgrader(project, semverTarget, npmPackage);\r\n};\r\n\r\nconst successReport = (): UpgradeReport => ({ success: true, error: null });\r\nconst erroredReport = (error: Error): UpgradeReport => ({ success: false, error });\r\n","export const STRAPI_PACKAGE_NAME = '@strapi/strapi';\r\n","import type {\r\n  Requirement as RequirementInterface,\r\n  RequirementTestCallback,\r\n  TestContext,\r\n  TestResult,\r\n} from './types';\r\n\r\nexport class Requirement implements RequirementInterface {\r\n  readonly isRequired: boolean;\r\n\r\n  readonly name: string;\r\n\r\n  readonly testCallback: RequirementTestCallback | null;\r\n\r\n  children: RequirementInterface[];\r\n\r\n  constructor(name: string, testCallback: RequirementTestCallback | null, isRequired?: boolean) {\r\n    this.name = name;\r\n    this.testCallback = testCallback;\r\n    this.isRequired = isRequired ?? true;\r\n    this.children = [];\r\n  }\r\n\r\n  setChildren(children: RequirementInterface[]) {\r\n    this.children = children;\r\n    return this;\r\n  }\r\n\r\n  addChild(child: RequirementInterface) {\r\n    this.children.push(child);\r\n    return this;\r\n  }\r\n\r\n  asOptional() {\r\n    const newInstance = requirementFactory(this.name, this.testCallback, false);\r\n\r\n    newInstance.setChildren(this.children);\r\n\r\n    return newInstance;\r\n  }\r\n\r\n  asRequired() {\r\n    const newInstance = requirementFactory(this.name, this.testCallback, true);\r\n\r\n    newInstance.setChildren(this.children);\r\n\r\n    return newInstance;\r\n  }\r\n\r\n  async test(context: TestContext) {\r\n    try {\r\n      await this.testCallback?.(context);\r\n      return ok();\r\n    } catch (e) {\r\n      if (e instanceof Error) {\r\n        return errored(e);\r\n      }\r\n\r\n      if (typeof e === 'string') {\r\n        return errored(new Error(e));\r\n      }\r\n\r\n      return errored(new Error('Unknown error'));\r\n    }\r\n  }\r\n}\r\n\r\nconst ok = (): TestResult => ({ pass: true, error: null });\r\n\r\nconst errored = (error: Error): TestResult => ({ pass: false, error });\r\n\r\nexport const requirementFactory = (\r\n  name: string,\r\n  testCallback: RequirementTestCallback | null,\r\n  isRequired?: boolean\r\n) => new Requirement(name, testCallback, isRequired);\r\n","import { requirementFactory } from '../../../modules/requirement';\r\nimport { semVerFactory } from '../../../modules/version';\r\n\r\nexport const REQUIRE_AVAILABLE_NEXT_MAJOR = requirementFactory(\r\n  'REQUIRE_AVAILABLE_NEXT_MAJOR',\r\n  (context) => {\r\n    const { project, target } = context;\r\n\r\n    const currentMajor = project.strapiVersion.major;\r\n    const targetedMajor = target.major;\r\n\r\n    if (targetedMajor === currentMajor) {\r\n      throw new Error(`You're already on the latest major version (v${currentMajor})`);\r\n    }\r\n  }\r\n);\r\n\r\nexport const REQUIRE_LATEST_FOR_CURRENT_MAJOR = requirementFactory(\r\n  'REQUIRE_LATEST_FOR_CURRENT_MAJOR',\r\n  (context) => {\r\n    const { project, target, npmVersionsMatches } = context;\r\n    const { major: currentMajor } = project.strapiVersion;\r\n\r\n    const invalidMatches = npmVersionsMatches.filter(\r\n      (match) => semVerFactory(match.version).major === currentMajor\r\n    );\r\n\r\n    if (invalidMatches.length > 0) {\r\n      const invalidVersions = invalidMatches.map((match) => match.version);\r\n      const invalidVersionsCount = invalidVersions.length;\r\n\r\n      throw new Error(\r\n        `Doing a major upgrade requires to be on the latest v${currentMajor} version, but found ${invalidVersionsCount} versions between the current one and ${target}. Please upgrade to ${invalidVersions.at(-1)} and try again.`\r\n      );\r\n    }\r\n  }\r\n);\r\n","import simpleGit from 'simple-git';\r\n\r\nimport { requirementFactory } from '../../../modules/requirement';\r\n\r\nexport const REQUIRE_GIT_CLEAN_REPOSITORY = requirementFactory(\r\n  'REQUIRE_GIT_CLEAN_REPOSITORY',\r\n  async (context) => {\r\n    const git = simpleGit({ baseDir: context.project.cwd });\r\n\r\n    const status = await git.status();\r\n\r\n    if (!status.isClean()) {\r\n      throw new Error(\r\n        'Repository is not clean. Please commit or stash any changes before upgrading'\r\n      );\r\n    }\r\n  }\r\n);\r\n\r\nexport const REQUIRE_GIT_REPOSITORY = requirementFactory(\r\n  'REQUIRE_GIT_REPOSITORY',\r\n  async (context) => {\r\n    const git = simpleGit({ baseDir: context.project.cwd });\r\n\r\n    const isRepo = await git.checkIsRepo();\r\n\r\n    if (!isRepo) {\r\n      throw new Error('Not a git repository (or any of the parent directories)');\r\n    }\r\n  }\r\n).addChild(REQUIRE_GIT_CLEAN_REPOSITORY.asOptional());\r\n\r\nexport const REQUIRE_GIT_INSTALLED = requirementFactory(\r\n  'REQUIRE_GIT_INSTALLED',\r\n  async (context) => {\r\n    const git = simpleGit({ baseDir: context.project.cwd });\r\n\r\n    try {\r\n      await git.version();\r\n    } catch {\r\n      throw new Error('Git is not installed');\r\n    }\r\n  }\r\n).addChild(REQUIRE_GIT_REPOSITORY.asOptional());\r\n\r\nexport const REQUIRE_GIT = requirementFactory('REQUIRE_GIT', null).addChild(\r\n  REQUIRE_GIT_INSTALLED.asOptional()\r\n);\r\n","import { AbortedError } from '../../../modules/error';\r\nimport * as f from '../../../modules/format';\r\n\r\nimport { rangeFactory, semVerFactory, Version } from '../../../modules/version';\r\n\r\nimport type { Upgrader } from '../../../modules/upgrader';\r\nimport type { UpgradeOptions } from '../types';\r\n\r\n/**\r\n * Handles the upgrade prompts when using the latest tag.\r\n *\r\n * - checks if an upgrade involves a major bump, warning and asking for user confirmation before proceeding\r\n */\r\nexport const latest = async (upgrader: Upgrader, options: UpgradeOptions) => {\r\n  // Exit if the upgrade target isn't the latest tag\r\n  if (options.target !== Version.ReleaseType.Latest) {\r\n    return;\r\n  }\r\n\r\n  // Retrieve utilities from the upgrader instance\r\n  const npmPackage = upgrader.getNPMPackage();\r\n  const target = upgrader.getTarget();\r\n  const project = upgrader.getProject();\r\n\r\n  const { strapiVersion: current } = project;\r\n\r\n  // Pre-formatted strings used in logs\r\n  const fTargetMajor = f.highlight(`v${target.major}`);\r\n  const fCurrentMajor = f.highlight(`v${current.major}`);\r\n\r\n  const fTarget = f.version(target);\r\n  const fCurrent = f.version(current);\r\n\r\n  // Flags\r\n  const isMajorUpgrade = target.major > current.major;\r\n\r\n  // Handle potential major upgrade, warns, and asks for confirmation to proceed\r\n  if (isMajorUpgrade) {\r\n    options.logger.warn(\r\n      `Detected a major upgrade for the \"${f.highlight(Version.ReleaseType.Latest)}\" tag: ${fCurrent} > ${fTarget}`\r\n    );\r\n\r\n    // Find the latest release in between the current one and the next major\r\n    const newerPackageRelease = npmPackage\r\n      .findVersionsInRange(rangeFactory(`>${current.raw} <${target.major}`))\r\n      .at(-1);\r\n\r\n    // If the project isn't on the latest version for the current major, emit a warning\r\n    if (newerPackageRelease) {\r\n      const fLatest = f.version(semVerFactory(newerPackageRelease.version));\r\n      options.logger.warn(\r\n        `It's recommended to first upgrade to the latest version of ${fCurrentMajor} (${fLatest}) before upgrading to ${fTargetMajor}.`\r\n      );\r\n    }\r\n\r\n    const proceedAnyway = await upgrader.confirm(`I know what I'm doing. Proceed anyway!`);\r\n\r\n    if (!proceedAnyway) {\r\n      throw new AbortedError();\r\n    }\r\n  }\r\n};\r\n","import path from 'node:path';\r\n\r\nimport * as f from '../../modules/format';\r\nimport { npmPackageFactory } from '../../modules/npm';\r\nimport { isApplicationProject, projectFactory } from '../../modules/project';\r\nimport { timerFactory } from '../../modules/timer';\r\nimport { constants as upgraderConstants, upgraderFactory } from '../../modules/upgrader';\r\nimport { Version } from '../../modules/version';\r\n\r\nimport * as requirements from './requirements';\r\nimport * as prompts from './prompts';\r\n\r\nimport type { UpgradeOptions } from './types';\r\nimport type { Upgrader } from '../../modules/upgrader';\r\n\r\nexport const upgrade = async (options: UpgradeOptions) => {\r\n  const timer = timerFactory();\r\n  const { logger, codemodsTarget } = options;\r\n\r\n  // Resolves the correct working directory based on the given input\r\n  const cwd = path.resolve(options.cwd ?? process.cwd());\r\n\r\n  const project = projectFactory(cwd);\r\n\r\n  logger.debug(f.projectDetails(project));\r\n\r\n  if (!isApplicationProject(project)) {\r\n    throw new Error(\r\n      `The \"${options.target}\" upgrade can only be run on a Strapi project; for plugins, please use \"codemods\".`\r\n    );\r\n  }\r\n\r\n  logger.debug(\r\n    `Application: VERSION=${f.version(project.packageJSON.version as Version.LiteralVersion)}; STRAPI_VERSION=${f.version(project.strapiVersion)}`\r\n  );\r\n\r\n  const npmPackage = npmPackageFactory(upgraderConstants.STRAPI_PACKAGE_NAME);\r\n\r\n  // Load all available versions from the NPM registry\r\n  await npmPackage.refresh();\r\n\r\n  // Initialize the upgrade instance\r\n  // Throws during initialization if the provided target is incompatible with the current version\r\n  const upgrader = upgraderFactory(project, options.target, npmPackage)\r\n    .dry(options.dry ?? false)\r\n    .onConfirm(options.confirm ?? null)\r\n    .setLogger(logger);\r\n\r\n  // Manually override the target version for codemods if it's explicitly provided\r\n  if (codemodsTarget !== undefined) {\r\n    upgrader.overrideCodemodsTarget(codemodsTarget);\r\n  }\r\n\r\n  // Prompt user for confirmation details before upgrading\r\n  await runUpgradePrompts(upgrader, options);\r\n\r\n  // Add specific requirements before upgrading\r\n  addUpgradeRequirements(upgrader, options);\r\n\r\n  // Actually run the upgrade process once configured,\r\n  // The response contains information about the final status: success/error\r\n  const upgradeReport = await upgrader.upgrade();\r\n\r\n  if (!upgradeReport.success) {\r\n    throw upgradeReport.error;\r\n  }\r\n\r\n  timer.stop();\r\n\r\n  logger.info(`Completed in ${f.durationMs(timer.elapsedMs)}ms`);\r\n};\r\n\r\nconst runUpgradePrompts = async (upgrader: Upgrader, options: UpgradeOptions) => {\r\n  if (options.target === Version.ReleaseType.Latest) {\r\n    await prompts.latest(upgrader, options);\r\n  }\r\n};\r\n\r\nconst addUpgradeRequirements = (upgrader: Upgrader, options: UpgradeOptions): void => {\r\n  // Don't add the same requirements when manually targeting a major upgrade\r\n  // using a semver as it's implied that the users know what they're doing\r\n  if (options.target === Version.ReleaseType.Major) {\r\n    upgrader\r\n      .addRequirement(requirements.major.REQUIRE_AVAILABLE_NEXT_MAJOR)\r\n      .addRequirement(requirements.major.REQUIRE_LATEST_FOR_CURRENT_MAJOR);\r\n  }\r\n\r\n  // Make sure the git repository is in an optimal state before running the upgrade\r\n  // Mainly used to ease rollbacks in case the upgrade is corrupted\r\n  upgrader.addRequirement(requirements.common.REQUIRE_GIT.asOptional());\r\n};\r\n","import path from 'node:path';\r\n\r\nimport { isApplicationProject } from '../../modules/project';\r\nimport { Version, isSemverInstance, rangeFactory, isRangeInstance } from '../../modules/version';\r\n\r\nimport type { Project } from '../../modules/project';\r\n\r\nexport const resolvePath = (cwd?: string) => path.resolve(cwd ?? process.cwd());\r\n\r\nexport const getRangeFromTarget = (\r\n  currentVersion: Version.SemVer,\r\n  target: Version.ReleaseType | Version.LiteralSemVer\r\n) => {\r\n  if (isSemverInstance(target)) {\r\n    return rangeFactory(target);\r\n  }\r\n\r\n  const { major, minor, patch } = currentVersion;\r\n\r\n  switch (target) {\r\n    case Version.ReleaseType.Latest:\r\n      throw new Error(\"Can't use <latest> to create a codemods range: not implemented\");\r\n    case Version.ReleaseType.Major:\r\n      return rangeFactory(`${major}`);\r\n    case Version.ReleaseType.Minor:\r\n      return rangeFactory(`${major}.${minor}`);\r\n    case Version.ReleaseType.Patch:\r\n      return rangeFactory(`${major}.${minor}.${patch}`);\r\n    default:\r\n      throw new Error(`Invalid target set: ${target}`);\r\n  }\r\n};\r\n\r\nexport const findRangeFromTarget = (\r\n  project: Project,\r\n  target: Version.ReleaseType | Version.LiteralSemVer | Version.Range\r\n): Version.Range => {\r\n  // If a range is manually defined, use it\r\n  if (isRangeInstance(target)) {\r\n    return target;\r\n  }\r\n\r\n  // If the current project is a Strapi application\r\n  // Get the range from the given target\r\n  if (isApplicationProject(project)) {\r\n    return getRangeFromTarget(project.strapiVersion, target);\r\n  }\r\n\r\n  // Else, if the project is a Strapi plugin or anything else\r\n  // Set the range to match any version\r\n  return rangeFactory('*');\r\n};\r\n","import * as f from '../../modules/format';\r\nimport { timerFactory } from '../../modules/timer';\r\nimport { projectFactory } from '../../modules/project';\r\nimport { codemodRunnerFactory } from '../../modules/codemod-runner';\r\nimport { findRangeFromTarget, resolvePath } from './utils';\r\n\r\nimport type { RunCodemodsOptions } from './types';\r\nimport type { CodemodRunnerReport } from '../../modules/codemod-runner';\r\n\r\nexport const runCodemods = async (options: RunCodemodsOptions) => {\r\n  const timer = timerFactory();\r\n  const { logger, uid } = options;\r\n\r\n  // Make sure we're resolving the correct working directory based on the given input\r\n  const cwd = resolvePath(options.cwd);\r\n\r\n  const project = projectFactory(cwd);\r\n  const range = findRangeFromTarget(project, options.target);\r\n\r\n  logger.debug(f.projectDetails(project));\r\n  logger.debug(`Range: set to ${f.versionRange(range)}`);\r\n\r\n  const codemodRunner = codemodRunnerFactory(project, range)\r\n    .dry(options.dry ?? false)\r\n    .onSelectCodemods(options.selectCodemods ?? null)\r\n    .setLogger(logger);\r\n\r\n  let report: CodemodRunnerReport;\r\n\r\n  // If uid is defined, only run the selected codemod\r\n  if (uid !== undefined) {\r\n    logger.debug(`Running a single codemod: ${f.codemodUID(uid)}`);\r\n    report = await codemodRunner.runByUID(uid);\r\n  }\r\n\r\n  // By default, only filter using the specified range\r\n  else {\r\n    report = await codemodRunner.run();\r\n  }\r\n\r\n  if (!report.success) {\r\n    throw report.error;\r\n  }\r\n\r\n  timer.stop();\r\n\r\n  logger.info(`Completed in ${timer.elapsedMs}`);\r\n};\r\n","import { codemodRepositoryFactory } from '../../modules/codemod-repository';\r\nimport { projectFactory } from '../../modules/project';\r\nimport { findRangeFromTarget, resolvePath } from './utils';\r\n\r\nimport * as f from '../../modules/format';\r\n\r\nimport type { ListCodemodsOptions } from './types';\r\n\r\nexport const listCodemods = async (options: ListCodemodsOptions) => {\r\n  const { logger, target } = options;\r\n\r\n  const cwd = resolvePath(options.cwd);\r\n  const project = projectFactory(cwd);\r\n  const range = findRangeFromTarget(project, target);\r\n\r\n  logger.debug(f.projectDetails(project));\r\n  logger.debug(`Range: set to ${f.versionRange(range)}`);\r\n\r\n  // Create a codemod repository targeting the default location of the codemods\r\n  const repo = codemodRepositoryFactory();\r\n\r\n  // Make sure all the codemods are loaded\r\n  repo.refresh();\r\n\r\n  // Find groups of codemods matching the given range\r\n  const groups = repo.find({ range });\r\n\r\n  // Flatten the groups into a simple codemod array\r\n  const codemods = groups.flatMap((collection) => collection.codemods);\r\n\r\n  // Debug\r\n  logger.debug(`Found ${f.highlight(codemods.length)} codemods`);\r\n\r\n  // Don't log an empty table\r\n  if (codemods.length === 0) {\r\n    logger.info(`Found no codemods matching ${f.versionRange(range)}`);\r\n    return;\r\n  }\r\n\r\n  // Format the list to a pretty table\r\n  const fCodemods = f.codemodList(codemods);\r\n\r\n  logger.raw(fCodemods);\r\n};\r\n","import chalk from 'chalk';\r\n\r\nimport type { Logger as LoggerInterface, LoggerOptions } from './types';\r\n\r\nexport class Logger implements LoggerInterface {\r\n  isDebug: boolean;\r\n\r\n  isSilent: boolean;\r\n\r\n  private nbErrorsCalls: number;\r\n\r\n  private nbWarningsCalls: number;\r\n\r\n  constructor(options: LoggerOptions = {}) {\r\n    // Set verbosity options\r\n    this.isDebug = options.debug ?? false;\r\n    this.isSilent = options.silent ?? false;\r\n\r\n    // Initialize counters\r\n    this.nbErrorsCalls = 0;\r\n    this.nbWarningsCalls = 0;\r\n  }\r\n\r\n  private get isNotSilent(): boolean {\r\n    return !this.isSilent;\r\n  }\r\n\r\n  get errors(): number {\r\n    return this.nbErrorsCalls;\r\n  }\r\n\r\n  get warnings(): number {\r\n    return this.nbWarningsCalls;\r\n  }\r\n\r\n  get stdout(): (NodeJS.WriteStream & { fd: 1 }) | undefined {\r\n    return this.isSilent ? undefined : process.stdout;\r\n  }\r\n\r\n  get stderr(): (NodeJS.WriteStream & { fd: 2 }) | undefined {\r\n    return this.isSilent ? undefined : process.stderr;\r\n  }\r\n\r\n  setDebug(debug: boolean): this {\r\n    this.isDebug = debug;\r\n    return this;\r\n  }\r\n\r\n  setSilent(silent: boolean): this {\r\n    this.isSilent = silent;\r\n    return this;\r\n  }\r\n\r\n  debug(...args: unknown[]): this {\r\n    const isDebugEnabled = this.isNotSilent && this.isDebug;\r\n\r\n    if (isDebugEnabled) {\r\n      console.log(chalk.cyan(`[DEBUG]\\t[${nowAsISO()}]`), ...args);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  error(...args: unknown[]): this {\r\n    this.nbErrorsCalls += 1;\r\n\r\n    if (this.isNotSilent) {\r\n      console.error(chalk.red(`[ERROR]\\t[${nowAsISO()}]`), ...args);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  info(...args: unknown[]): this {\r\n    if (this.isNotSilent) {\r\n      console.info(chalk.blue(`[INFO]\\t[${new Date().toISOString()}]`), ...args);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  raw(...args: unknown[]): this {\r\n    if (this.isNotSilent) {\r\n      console.log(...args);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  warn(...args: unknown[]): this {\r\n    this.nbWarningsCalls += 1;\r\n\r\n    if (this.isNotSilent) {\r\n      console.warn(chalk.yellow(`[WARN]\\t[${new Date().toISOString()}]`), ...args);\r\n    }\r\n\r\n    return this;\r\n  }\r\n}\r\n\r\nconst nowAsISO = () => new Date().toISOString();\r\n\r\nexport const loggerFactory = (options: LoggerOptions = {}) => new Logger(options);\r\n","import type { Codemod } from '../codemod';\r\n\r\nimport type { CodemodReport, Report } from './types';\r\n\r\nexport const codemodReportFactory = (codemod: Codemod.Codemod, report: Report): CodemodReport => ({\r\n  codemod,\r\n  report,\r\n});\r\n\r\nexport const reportFactory = (report: Report): Report => ({ ...report });\r\n"],"names":["path","version","reports","index","timerConstants.ONE_SECOND_MS","ReleaseType","Version.ReleaseType","constants.NPM_REGISTRY_URL","jscodeshift","constants.PROJECT_JSON_EXTENSIONS","constants.PROJECT_CODE_EXTENSIONS","constants.PROJECT_PACKAGE_JSON","constants.PROJECT_APP_ALLOWED_ROOT_PATHS","constants.PROJECT_ALLOWED_EXTENSIONS","constants.STRAPI_DEPENDENCY_NAME","isValidSemVer","constants.PROJECT_PLUGIN_ALLOWED_ROOT_PATHS","constants.PROJECT_PLUGIN_ROOT_FILES","constants.CODEMOD_EXTENSION","constants.CODEMOD_CODE_SUFFIX","constants.CODEMOD_JSON_SUFFIX","constants.CODEMOD_FILE_REGEXP","constants.CODEMOD_ALLOWED_SUFFIXES","codemodRepositoryConstants.INTERNAL_CODEMODS_DIRECTORY","f.reports","f.highlight","successReport","erroredReport","codemods","f.versionRange","f.version","f.upgradeStep","projectConstants.SCOPED_STRAPI_PACKAGE_PREFIX","f.projectDetails","upgraderConstants.STRAPI_PACKAGE_NAME","f.durationMs","prompts.latest","requirements.major.REQUIRE_AVAILABLE_NEXT_MAJOR","requirements.major.REQUIRE_LATEST_FOR_CURRENT_MAJOR","requirements.common.REQUIRE_GIT","f.codemodUID","f.codemodList"],"mappings":"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"}