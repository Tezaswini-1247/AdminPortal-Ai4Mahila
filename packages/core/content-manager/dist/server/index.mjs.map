{"version":3,"file":"index.mjs","sources":["../../server/src/utils/index.ts","../../server/src/history/utils.ts","../../server/src/history/controllers/validation/history-version.ts","../../server/src/history/controllers/history-version.ts","../../server/src/history/controllers/index.ts","../../server/src/history/constants.ts","../../server/src/history/services/utils.ts","../../server/src/history/services/history.ts","../../server/src/history/services/lifecycles.ts","../../server/src/history/services/index.ts","../../server/src/history/routes/history-version.ts","../../server/src/history/routes/index.ts","../../server/src/history/models/history-version.ts","../../server/src/history/index.ts","../../server/src/preview/constants.ts","../../server/src/preview/routes/preview.ts","../../server/src/preview/routes/index.ts","../../server/src/preview/utils.ts","../../server/src/preview/controllers/validation/preview.ts","../../server/src/preview/controllers/preview.ts","../../server/src/preview/controllers/index.ts","../../server/src/preview/services/preview.ts","../../server/src/preview/services/preview-config.ts","../../server/src/preview/services/index.ts","../../server/src/preview/index.ts","../../server/src/register.ts","../../server/src/constants/index.ts","../../server/src/bootstrap.ts","../../server/src/destroy.ts","../../server/src/middlewares/routing.ts","../../server/src/routes/admin.ts","../../server/src/routes/index.ts","../../server/src/validation/policies/hasPermissions.ts","../../server/src/policies/hasPermissions.ts","../../server/src/policies/index.ts","../../server/src/services/utils/configuration/attributes.ts","../../server/src/services/utils/configuration/settings.ts","../../server/src/controllers/validation/model-configuration.ts","../../server/src/controllers/validation/index.ts","../../server/src/controllers/utils/clone.ts","../../server/src/controllers/validation/dimensions.ts","../../server/src/controllers/utils/metadata.ts","../../server/src/controllers/collection-types.ts","../../server/src/controllers/components.ts","../../server/src/controllers/content-types.ts","../../server/src/controllers/init.ts","../../server/src/controllers/validation/relations.ts","../../server/src/controllers/relations.ts","../../server/src/controllers/single-types.ts","../../server/src/controllers/uid.ts","../../server/src/controllers/index.ts","../../server/src/services/utils/store.ts","../../server/src/services/utils/configuration/metadatas.ts","../../server/src/services/utils/configuration/layouts.ts","../../server/src/services/utils/configuration/index.ts","../../server/src/services/configuration.ts","../../server/src/services/components.ts","../../server/src/services/content-types.ts","../../server/src/services/data-mapper.ts","../../server/src/services/field-sizes.ts","../../server/src/services/metrics.ts","../../server/src/services/permission-checker.ts","../../server/src/services/permission.ts","../../server/src/services/utils/populate.ts","../../server/src/services/populate-builder.ts","../../server/src/services/uid.ts","../../server/src/services/document-metadata.ts","../../server/src/services/utils/draft.ts","../../server/src/services/document-manager.ts","../../server/src/services/index.ts","../../server/src/index.ts"],"sourcesContent":["import '@strapi/types';\r\n\r\nimport { DocumentManagerService } from 'src/services/document-manager';\r\nimport DocumentMetadata from 'src/services/document-metadata';\r\n\r\ntype Services = {\r\n  'document-manager': DocumentManagerService;\r\n  'document-metadata': typeof DocumentMetadata;\r\n  [key: string]: any;\r\n};\r\n\r\nconst getService = <TName extends keyof Services>(name: TName): ReturnType<Services[TName]> => {\r\n  return strapi.plugin('content-manager').service(name as string);\r\n};\r\n\r\nexport { getService };\r\n","import type { Core } from '@strapi/types';\r\n\r\ntype HistoryServices = typeof import('./services').services;\r\n\r\nfunction getService<T extends keyof HistoryServices>(strapi: Core.Strapi, name: T) {\r\n  // Cast is needed because the return type of strapi.service is too vague\r\n  return strapi.service(`plugin::content-manager.${name}`) as ReturnType<HistoryServices[T]>;\r\n}\r\n\r\nexport { getService };\r\n","import * as yup from 'yup';\r\nimport { validateYupSchema } from '@strapi/utils';\r\n\r\nconst historyRestoreVersionSchema = yup\r\n  .object()\r\n  .shape({\r\n    contentType: yup.string().trim().required(),\r\n  })\r\n  .required();\r\n\r\nexport const validateRestoreVersion = validateYupSchema(historyRestoreVersionSchema);\r\n","import { async, errors } from '@strapi/utils';\r\nimport type { Core, UID } from '@strapi/types';\r\nimport { pick } from 'lodash/fp';\r\nimport { getService as getContentManagerService } from '../../utils';\r\nimport { getService } from '../utils';\r\nimport { HistoryVersions } from '../../../../shared/contracts';\r\nimport { RestoreHistoryVersion } from '../../../../shared/contracts/history-versions';\r\nimport { validateRestoreVersion } from './validation/history-version';\r\n\r\n/**\r\n * Parses pagination params and makes sure they're within valid ranges\r\n */\r\nconst getValidPagination = ({ page, pageSize }: { page: any; pageSize: any }) => {\r\n  let pageNumber = 1;\r\n  let pageSizeNumber = 20;\r\n\r\n  if (page) {\r\n    const parsedPage = parseInt(page, 10);\r\n    pageNumber = parseInt(page, 10);\r\n\r\n    if (!Number.isNaN(parsedPage) && parsedPage >= 1) {\r\n      pageNumber = parsedPage;\r\n    }\r\n  }\r\n\r\n  if (pageSize) {\r\n    const parsedPageSize = parseInt(pageSize, 10);\r\n\r\n    if (!Number.isNaN(parsedPageSize) && parsedPageSize >= 1 && parsedPageSize <= 100) {\r\n      pageSizeNumber = parsedPageSize;\r\n    }\r\n  }\r\n\r\n  return { page: pageNumber, pageSize: pageSizeNumber };\r\n};\r\n\r\nconst createHistoryVersionController = ({ strapi }: { strapi: Core.Strapi }) => {\r\n  return {\r\n    async findMany(ctx) {\r\n      const contentTypeUid = ctx.query.contentType as UID.ContentType;\r\n      const isSingleType = strapi.getModel(contentTypeUid)?.kind === 'singleType';\r\n\r\n      if (isSingleType && !contentTypeUid) {\r\n        throw new errors.ForbiddenError('contentType is required');\r\n      }\r\n\r\n      if (!isSingleType && (!contentTypeUid || !ctx.query.documentId)) {\r\n        throw new errors.ForbiddenError('contentType and documentId are required');\r\n      }\r\n\r\n      /**\r\n       * There are no permissions specifically for history versions,\r\n       * but we need to check that the user can read the content type\r\n       */\r\n      const permissionChecker = getContentManagerService('permission-checker').create({\r\n        userAbility: ctx.state.userAbility,\r\n        model: ctx.query.contentType,\r\n      });\r\n\r\n      if (permissionChecker.cannot.read()) {\r\n        return ctx.forbidden();\r\n      }\r\n\r\n      const query: HistoryVersions.GetHistoryVersions.Request['query'] =\r\n        await permissionChecker.sanitizeQuery(ctx.query);\r\n\r\n      const { results, pagination } = await getService(strapi, 'history').findVersionsPage({\r\n        query: {\r\n          ...query,\r\n          ...getValidPagination({ page: query.page, pageSize: query.pageSize }),\r\n        },\r\n        state: { userAbility: ctx.state.userAbility },\r\n      });\r\n\r\n      const sanitizedResults = await async.map(\r\n        results,\r\n        async (version: HistoryVersions.HistoryVersionDataResponse & { locale: string }) => {\r\n          return {\r\n            ...version,\r\n            data: await permissionChecker.sanitizeOutput(version.data),\r\n            createdBy: version.createdBy\r\n              ? pick(['id', 'firstname', 'lastname', 'username', 'email'], version.createdBy)\r\n              : undefined,\r\n          };\r\n        }\r\n      );\r\n\r\n      return {\r\n        data: sanitizedResults,\r\n        meta: { pagination },\r\n      };\r\n    },\r\n\r\n    async restoreVersion(ctx) {\r\n      const request = ctx.request as unknown as RestoreHistoryVersion.Request;\r\n\r\n      await validateRestoreVersion(request.body, 'contentType is required');\r\n\r\n      const permissionChecker = getContentManagerService('permission-checker').create({\r\n        userAbility: ctx.state.userAbility,\r\n        model: request.body.contentType,\r\n      });\r\n\r\n      if (permissionChecker.cannot.update()) {\r\n        throw new errors.ForbiddenError();\r\n      }\r\n\r\n      const restoredDocument = await getService(strapi, 'history').restoreVersion(\r\n        request.params.versionId\r\n      );\r\n\r\n      return {\r\n        data: { documentId: restoredDocument.documentId },\r\n      } satisfies RestoreHistoryVersion.Response;\r\n    },\r\n  } satisfies Core.Controller;\r\n};\r\n\r\nexport { createHistoryVersionController };\r\n","import type { Plugin } from '@strapi/types';\r\nimport { createHistoryVersionController } from './history-version';\r\n\r\nexport const controllers = {\r\n  'history-version': createHistoryVersionController,\r\n  /**\r\n   * Casting is needed because the types aren't aware that Strapi supports\r\n   * passing a controller factory as the value, instead of a controller object directly\r\n   */\r\n} as unknown as Plugin.LoadedPlugin['controllers'];\r\n","export const HISTORY_VERSION_UID = 'plugin::content-manager.history-version';\r\nexport const FIELDS_TO_IGNORE = [\r\n  'createdAt',\r\n  'updatedAt',\r\n  'publishedAt',\r\n  'createdBy',\r\n  'updatedBy',\r\n  'strapi_stage',\r\n  'strapi_assignee',\r\n];\r\n","import { difference, omit } from 'lodash/fp';\r\nimport type { Struct, UID } from '@strapi/types';\r\nimport { Core, Data, Modules, Schema } from '@strapi/types';\r\nimport { contentTypes } from '@strapi/utils';\r\nimport { CreateHistoryVersion } from '../../../../shared/contracts/history-versions';\r\nimport { FIELDS_TO_IGNORE } from '../constants';\r\nimport { HistoryVersions } from '../../../../shared/contracts';\r\nimport { RelationResult } from '../../../../shared/contracts/relations';\r\n\r\nconst DEFAULT_RETENTION_DAYS = 90;\r\n\r\ntype RelationResponse = {\r\n  results: RelationResult[];\r\n  meta: { missingCount: number };\r\n};\r\n\r\nexport const createServiceUtils = ({ strapi }: { strapi: Core.Strapi }) => {\r\n  /**\r\n   * @description\r\n   * Get the difference between the version schema and the content type schema\r\n   */\r\n  const getSchemaAttributesDiff = (\r\n    versionSchemaAttributes: CreateHistoryVersion['schema'],\r\n    contentTypeSchemaAttributes: Struct.SchemaAttributes\r\n  ) => {\r\n    // Omit the same fields that were omitted when creating a history version\r\n    const sanitizedContentTypeSchemaAttributes = omit(\r\n      FIELDS_TO_IGNORE,\r\n      contentTypeSchemaAttributes\r\n    );\r\n\r\n    const reduceDifferenceToAttributesObject = (\r\n      diffKeys: string[],\r\n      source: CreateHistoryVersion['schema']\r\n    ) => {\r\n      return diffKeys.reduce<CreateHistoryVersion['schema']>(\r\n        (previousAttributesObject, diffKey) => {\r\n          previousAttributesObject[diffKey] = source[diffKey];\r\n\r\n          return previousAttributesObject;\r\n        },\r\n        {}\r\n      );\r\n    };\r\n\r\n    const versionSchemaKeys = Object.keys(versionSchemaAttributes);\r\n    const contentTypeSchemaAttributesKeys = Object.keys(sanitizedContentTypeSchemaAttributes);\r\n    // The attribute is new if it's on the content type schema but not on the version schema\r\n    const uniqueToContentType = difference(contentTypeSchemaAttributesKeys, versionSchemaKeys);\r\n    const added = reduceDifferenceToAttributesObject(\r\n      uniqueToContentType,\r\n      sanitizedContentTypeSchemaAttributes\r\n    );\r\n    // The attribute was removed or renamed if it's on the version schema but not on the content type schema\r\n    const uniqueToVersion = difference(versionSchemaKeys, contentTypeSchemaAttributesKeys);\r\n    const removed = reduceDifferenceToAttributesObject(uniqueToVersion, versionSchemaAttributes);\r\n\r\n    return { added, removed };\r\n  };\r\n\r\n  /**\r\n   * @description\r\n   * Gets the value to set for a relation when restoring a document\r\n   * @returns\r\n   * The relation if it exists or null\r\n   */\r\n  const getRelationRestoreValue = async (\r\n    versionRelationData: Data.Entity,\r\n    attribute: Schema.Attribute.RelationWithTarget\r\n  ) => {\r\n    if (Array.isArray(versionRelationData)) {\r\n      if (versionRelationData.length === 0) return versionRelationData;\r\n\r\n      const existingAndMissingRelations = await Promise.all(\r\n        versionRelationData.map((relation) => {\r\n          return strapi.documents(attribute.target).findOne({\r\n            documentId: relation.documentId,\r\n            locale: relation.locale || undefined,\r\n          });\r\n        })\r\n      );\r\n\r\n      return existingAndMissingRelations.filter(\r\n        (relation) => relation !== null\r\n      ) as Modules.Documents.AnyDocument[];\r\n    }\r\n\r\n    return strapi.documents(attribute.target).findOne({\r\n      documentId: versionRelationData.documentId,\r\n      locale: versionRelationData.locale || undefined,\r\n    });\r\n  };\r\n\r\n  /**\r\n   * @description\r\n   * Gets the value to set for a media asset when restoring a document\r\n   * @returns\r\n   * The media asset if it exists or null\r\n   */\r\n  const getMediaRestoreValue = async (\r\n    versionRelationData: Data.Entity,\r\n    attribute: Schema.Attribute.Media<any, boolean>\r\n  ) => {\r\n    if (attribute.multiple) {\r\n      const existingAndMissingMedias = await Promise.all(\r\n        // @ts-expect-error Fix the type definitions so this isn't any\r\n        versionRelationData.map((media) => {\r\n          return strapi.db.query('plugin::upload.file').findOne({ where: { id: media.id } });\r\n        })\r\n      );\r\n\r\n      return existingAndMissingMedias.filter((media) => media != null);\r\n    }\r\n\r\n    return strapi.db\r\n      .query('plugin::upload.file')\r\n      .findOne({ where: { id: versionRelationData.id } });\r\n  };\r\n\r\n  const localesService = strapi.plugin('i18n')?.service('locales');\r\n  const i18nContentTypeService = strapi.plugin('i18n')?.service('content-types');\r\n\r\n  const getDefaultLocale = async () => (localesService ? localesService.getDefaultLocale() : null);\r\n\r\n  const isLocalizedContentType = (model: Schema.ContentType) =>\r\n    i18nContentTypeService ? i18nContentTypeService.isLocalizedContentType(model) : false;\r\n\r\n  /**\r\n   *\r\n   * @description\r\n   * Creates a dictionary of all locales available\r\n   */\r\n  const getLocaleDictionary = async (): Promise<{\r\n    [key: string]: { name: string; code: string };\r\n  }> => {\r\n    if (!localesService) return {};\r\n\r\n    const locales = (await localesService.find()) || [];\r\n    return locales.reduce(\r\n      (\r\n        acc: Record<string, NonNullable<HistoryVersions.HistoryVersionDataResponse['locale']>>,\r\n        locale: NonNullable<HistoryVersions.HistoryVersionDataResponse['locale']>\r\n      ) => {\r\n        acc[locale.code] = { name: locale.name, code: locale.code };\r\n\r\n        return acc;\r\n      },\r\n      {}\r\n    );\r\n  };\r\n\r\n  /**\r\n   *\r\n   * @description\r\n   * Gets the number of retention days defined on the license or configured by the user\r\n   */\r\n  const getRetentionDays = () => {\r\n    const featureConfig = strapi.ee.features.get('cms-content-history');\r\n    const licenseRetentionDays =\r\n      typeof featureConfig === 'object' && featureConfig?.options.retentionDays;\r\n    const userRetentionDays: number = strapi.config.get('admin.history.retentionDays');\r\n\r\n    // Allow users to override the license retention days, but not to increase it\r\n    if (userRetentionDays && userRetentionDays < licenseRetentionDays) {\r\n      return userRetentionDays;\r\n    }\r\n\r\n    // User didn't provide retention days value, use the license or fallback to default\r\n    return Math.min(licenseRetentionDays, DEFAULT_RETENTION_DAYS);\r\n  };\r\n\r\n  const getVersionStatus = async (\r\n    contentTypeUid: HistoryVersions.CreateHistoryVersion['contentType'],\r\n    document: Modules.Documents.AnyDocument | null\r\n  ) => {\r\n    const documentMetadataService = strapi.plugin('content-manager').service('document-metadata');\r\n    const meta = await documentMetadataService.getMetadata(contentTypeUid, document);\r\n\r\n    return documentMetadataService.getStatus(document, meta.availableStatus);\r\n  };\r\n\r\n  /**\r\n   * Lists all the fields of a component, excepts those that will be populated.\r\n   * The goal is to exclude the ID, because when restoring a component,\r\n   * referencing an ID for a component db row that was deleted creates an error.\r\n   * So we never store component IDs to ensure they're re-created while restoring a version.\r\n   */\r\n  const getComponentFields = (componentUID: UID.Component): string[] => {\r\n    return Object.entries(strapi.getModel(componentUID).attributes).reduce<string[]>(\r\n      (fieldsAcc, [key, attribute]) => {\r\n        if (!['relation', 'media', 'component', 'dynamiczone'].includes(attribute.type)) {\r\n          fieldsAcc.push(key);\r\n        }\r\n\r\n        return fieldsAcc;\r\n      },\r\n      []\r\n    );\r\n  };\r\n\r\n  /**\r\n   * @description\r\n   * Creates a populate object that looks for all the relations that need\r\n   * to be saved in history, and populates only the fields needed to later retrieve the content.\r\n   *\r\n   * @param uid - The content type UID\r\n   * @param useDatabaseSyntax - Whether to use the database syntax for populate, defaults to false\r\n   */\r\n  const getDeepPopulate = (uid: UID.Schema, useDatabaseSyntax = false) => {\r\n    const model = strapi.getModel(uid);\r\n    const attributes = Object.entries(model.attributes);\r\n    const fieldSelector = useDatabaseSyntax ? 'select' : 'fields';\r\n\r\n    return attributes.reduce((acc: any, [attributeName, attribute]) => {\r\n      switch (attribute.type) {\r\n        case 'relation': {\r\n          // TODO: Support polymorphic relations\r\n          const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');\r\n          if (isMorphRelation) {\r\n            break;\r\n          }\r\n\r\n          const isVisible = contentTypes.isVisibleAttribute(model, attributeName);\r\n          if (isVisible) {\r\n            acc[attributeName] = { [fieldSelector]: ['documentId', 'locale', 'publishedAt'] };\r\n          }\r\n          break;\r\n        }\r\n\r\n        case 'media': {\r\n          acc[attributeName] = { [fieldSelector]: ['id'] };\r\n          break;\r\n        }\r\n\r\n        case 'component': {\r\n          const populate = getDeepPopulate(attribute.component);\r\n          acc[attributeName] = {\r\n            populate,\r\n            [fieldSelector]: getComponentFields(attribute.component),\r\n          };\r\n          break;\r\n        }\r\n\r\n        case 'dynamiczone': {\r\n          // Use fragments to populate the dynamic zone components\r\n          const populatedComponents = (attribute.components || []).reduce(\r\n            (acc: any, componentUID: UID.Component) => {\r\n              acc[componentUID] = {\r\n                populate: getDeepPopulate(componentUID),\r\n                [fieldSelector]: getComponentFields(componentUID),\r\n              };\r\n              return acc;\r\n            },\r\n            {}\r\n          );\r\n\r\n          acc[attributeName] = { on: populatedComponents };\r\n          break;\r\n        }\r\n        default:\r\n          break;\r\n      }\r\n\r\n      return acc;\r\n    }, {});\r\n  };\r\n\r\n  /**\r\n   * @description\r\n   * Builds a response object for relations containing the related data and a count of missing relations\r\n   */\r\n  const buildMediaResponse = async (values: { id: Data.ID }[]): Promise<RelationResponse> => {\r\n    return (\r\n      values\r\n        // Until we implement proper pagination, limit relations to an arbitrary amount\r\n        .slice(0, 25)\r\n        .reduce(\r\n          async (currentRelationDataPromise, entry) => {\r\n            const currentRelationData = await currentRelationDataPromise;\r\n\r\n            // Entry can be null if it's a toOne relation\r\n            if (!entry) {\r\n              return currentRelationData;\r\n            }\r\n\r\n            const relatedEntry = await strapi.db\r\n              .query('plugin::upload.file')\r\n              .findOne({ where: { id: entry.id } });\r\n\r\n            if (relatedEntry) {\r\n              currentRelationData.results.push(relatedEntry);\r\n            } else {\r\n              // The related content has been deleted\r\n              currentRelationData.meta.missingCount += 1;\r\n            }\r\n\r\n            return currentRelationData;\r\n          },\r\n          Promise.resolve<RelationResponse>({\r\n            results: [],\r\n            meta: { missingCount: 0 },\r\n          })\r\n        )\r\n    );\r\n  };\r\n\r\n  /**\r\n   * @description\r\n   * Builds a response object for media containing the media assets data and a count of missing media assets\r\n   */\r\n  const buildRelationReponse = async (\r\n    values: {\r\n      documentId: string;\r\n      locale: string | null;\r\n    }[],\r\n    attributeSchema: Schema.Attribute.RelationWithTarget\r\n  ): Promise<RelationResponse> => {\r\n    return (\r\n      values\r\n        // Until we implement proper pagination, limit relations to an arbitrary amount\r\n        .slice(0, 25)\r\n        .reduce(\r\n          async (currentRelationDataPromise, entry) => {\r\n            const currentRelationData = await currentRelationDataPromise;\r\n\r\n            // Entry can be null if it's a toOne relation\r\n            if (!entry) {\r\n              return currentRelationData;\r\n            }\r\n\r\n            const relatedEntry = await strapi\r\n              .documents(attributeSchema.target)\r\n              .findOne({ documentId: entry.documentId, locale: entry.locale || undefined });\r\n\r\n            if (relatedEntry) {\r\n              currentRelationData.results.push({\r\n                ...relatedEntry,\r\n                status: await getVersionStatus(attributeSchema.target, relatedEntry),\r\n              });\r\n            } else {\r\n              // The related content has been deleted\r\n              currentRelationData.meta.missingCount += 1;\r\n            }\r\n\r\n            return currentRelationData;\r\n          },\r\n          Promise.resolve<RelationResponse>({\r\n            results: [],\r\n            meta: { missingCount: 0 },\r\n          })\r\n        )\r\n    );\r\n  };\r\n\r\n  return {\r\n    getSchemaAttributesDiff,\r\n    getRelationRestoreValue,\r\n    getMediaRestoreValue,\r\n    getDefaultLocale,\r\n    isLocalizedContentType,\r\n    getLocaleDictionary,\r\n    getRetentionDays,\r\n    getVersionStatus,\r\n    getDeepPopulate,\r\n    buildMediaResponse,\r\n    buildRelationReponse,\r\n  };\r\n};\r\n","import type { Core, Data, Schema, Struct } from '@strapi/types';\r\nimport { async, errors } from '@strapi/utils';\r\nimport { omit } from 'lodash/fp';\r\n\r\nimport { FIELDS_TO_IGNORE, HISTORY_VERSION_UID } from '../constants';\r\nimport type { HistoryVersions } from '../../../../shared/contracts';\r\nimport {\r\n  CreateHistoryVersion,\r\n  HistoryVersionDataResponse,\r\n} from '../../../../shared/contracts/history-versions';\r\nimport { createServiceUtils } from './utils';\r\nimport { getService as getContentManagerService } from '../../utils';\r\n\r\n// Needed because the query engine doesn't return any types yet\r\ntype HistoryVersionQueryResult = Omit<HistoryVersionDataResponse, 'locale'> &\r\n  Pick<CreateHistoryVersion, 'locale'>;\r\n\r\nconst createHistoryService = ({ strapi }: { strapi: Core.Strapi }) => {\r\n  const query = strapi.db.query(HISTORY_VERSION_UID);\r\n  const serviceUtils = createServiceUtils({ strapi });\r\n\r\n  return {\r\n    async createVersion(historyVersionData: HistoryVersions.CreateHistoryVersion) {\r\n      await query.create({\r\n        data: {\r\n          ...historyVersionData,\r\n          createdAt: new Date(),\r\n          createdBy: strapi.requestContext.get()?.state?.user.id,\r\n        },\r\n      });\r\n    },\r\n\r\n    async findVersionsPage(params: HistoryVersions.GetHistoryVersions.Request): Promise<{\r\n      results: HistoryVersions.HistoryVersionDataResponse[];\r\n      pagination: HistoryVersions.Pagination;\r\n    }> {\r\n      const model = strapi.getModel(params.query.contentType);\r\n      const isLocalizedContentType = serviceUtils.isLocalizedContentType(model);\r\n      const defaultLocale = await serviceUtils.getDefaultLocale();\r\n\r\n      let locale = null;\r\n      if (isLocalizedContentType) {\r\n        locale = params.query.locale || defaultLocale;\r\n      }\r\n\r\n      const [{ results, pagination }, localeDictionary] = await Promise.all([\r\n        query.findPage({\r\n          ...params.query,\r\n          where: {\r\n            $and: [\r\n              { contentType: params.query.contentType },\r\n              ...(params.query.documentId ? [{ relatedDocumentId: params.query.documentId }] : []),\r\n              ...(locale ? [{ locale }] : []),\r\n            ],\r\n          },\r\n          populate: ['createdBy'],\r\n          orderBy: [{ createdAt: 'desc' }],\r\n        }),\r\n        serviceUtils.getLocaleDictionary(),\r\n      ]);\r\n      const populateEntryRelations = async (\r\n        entry: HistoryVersionQueryResult\r\n      ): Promise<CreateHistoryVersion['data']> => {\r\n        const entryWithRelations = await Object.entries(entry.schema).reduce(\r\n          async (currentDataWithRelations, [attributeKey, attributeSchema]) => {\r\n            const attributeValue = entry.data[attributeKey];\r\n\r\n            const attributeValues = Array.isArray(attributeValue)\r\n              ? attributeValue\r\n              : [attributeValue];\r\n\r\n            if (attributeSchema.type === 'media') {\r\n              const permissionChecker = getContentManagerService('permission-checker').create({\r\n                userAbility: params.state.userAbility,\r\n                model: 'plugin::upload.file',\r\n              });\r\n\r\n              const response = await serviceUtils.buildMediaResponse(attributeValues);\r\n              const sanitizedResults = await Promise.all(\r\n                response.results.map((media) => permissionChecker.sanitizeOutput(media))\r\n              );\r\n\r\n              return {\r\n                ...(await currentDataWithRelations),\r\n                [attributeKey]: {\r\n                  results: sanitizedResults,\r\n                  meta: response.meta,\r\n                },\r\n              };\r\n            }\r\n\r\n            // TODO: handle relations that are inside components\r\n            if (\r\n              attributeSchema.type === 'relation' &&\r\n              attributeSchema.relation !== 'morphToOne' &&\r\n              attributeSchema.relation !== 'morphToMany'\r\n            ) {\r\n              /**\r\n               * Don't build the relations response object for relations to admin users,\r\n               * because pickAllowedAdminUserFields will sanitize the data in the controller.\r\n               */\r\n              if (attributeSchema.target === 'admin::user') {\r\n                const adminUsers = await Promise.all(\r\n                  attributeValues.map((userToPopulate) => {\r\n                    if (userToPopulate == null) {\r\n                      return null;\r\n                    }\r\n\r\n                    return strapi.query('admin::user').findOne({\r\n                      where: {\r\n                        ...(userToPopulate.id ? { id: userToPopulate.id } : {}),\r\n                        ...(userToPopulate.documentId\r\n                          ? { documentId: userToPopulate.documentId }\r\n                          : {}),\r\n                      },\r\n                    });\r\n                  })\r\n                );\r\n\r\n                return {\r\n                  ...(await currentDataWithRelations),\r\n                  /**\r\n                   * Ideally we would return the same \"{results: [], meta: {}}\" shape, however,\r\n                   * when sanitizing the data as a whole in the controller before sending to the client,\r\n                   * the data for admin relation user is completely sanitized if we return an object here as opposed to an array.\r\n                   */\r\n                  [attributeKey]: adminUsers,\r\n                };\r\n              }\r\n\r\n              const permissionChecker = getContentManagerService('permission-checker').create({\r\n                userAbility: params.state.userAbility,\r\n                model: attributeSchema.target,\r\n              });\r\n\r\n              const response = await serviceUtils.buildRelationReponse(\r\n                attributeValues,\r\n                attributeSchema\r\n              );\r\n              const sanitizedResults = await Promise.all(\r\n                response.results.map((media) => permissionChecker.sanitizeOutput(media))\r\n              );\r\n\r\n              return {\r\n                ...(await currentDataWithRelations),\r\n                [attributeKey]: {\r\n                  results: sanitizedResults,\r\n                  meta: response.meta,\r\n                },\r\n              };\r\n            }\r\n\r\n            // Not a media or relation, nothing to change\r\n            return currentDataWithRelations;\r\n          },\r\n          Promise.resolve(entry.data)\r\n        );\r\n\r\n        return entryWithRelations;\r\n      };\r\n\r\n      const formattedResults = await Promise.all(\r\n        (results as HistoryVersionQueryResult[]).map(async (result) => {\r\n          return {\r\n            ...result,\r\n            data: await populateEntryRelations(result),\r\n            meta: {\r\n              unknownAttributes: serviceUtils.getSchemaAttributesDiff(\r\n                result.schema,\r\n                strapi.getModel(params.query.contentType).attributes\r\n              ),\r\n            },\r\n            locale: result.locale ? localeDictionary[result.locale] : null,\r\n          };\r\n        })\r\n      );\r\n\r\n      return {\r\n        results: formattedResults,\r\n        pagination,\r\n      };\r\n    },\r\n\r\n    async restoreVersion(versionId: Data.ID) {\r\n      const version = await query.findOne({ where: { id: versionId } });\r\n      const contentTypeSchemaAttributes = strapi.getModel(version.contentType).attributes;\r\n      const schemaDiff = serviceUtils.getSchemaAttributesDiff(\r\n        version.schema,\r\n        contentTypeSchemaAttributes\r\n      );\r\n\r\n      // Set all added attribute values to null\r\n      const dataWithoutAddedAttributes = Object.keys(schemaDiff.added).reduce(\r\n        (currentData, addedKey) => {\r\n          currentData[addedKey] = null;\r\n          return currentData;\r\n        },\r\n        // Clone to avoid mutating the original version data\r\n        structuredClone(version.data)\r\n      );\r\n      const sanitizedSchemaAttributes = omit(\r\n        FIELDS_TO_IGNORE,\r\n        contentTypeSchemaAttributes\r\n      ) as Struct.SchemaAttributes;\r\n\r\n      // Set all deleted relation values to null\r\n      const reducer = async.reduce(Object.entries(sanitizedSchemaAttributes));\r\n      const dataWithoutMissingRelations = await reducer(\r\n        async (\r\n          previousRelationAttributes: Record<string, unknown>,\r\n          [name, attribute]: [string, Schema.Attribute.AnyAttribute]\r\n        ) => {\r\n          const versionRelationData = version.data[name];\r\n          if (!versionRelationData) {\r\n            return previousRelationAttributes;\r\n          }\r\n\r\n          if (\r\n            attribute.type === 'relation' &&\r\n            // TODO: handle polymorphic relations\r\n            attribute.relation !== 'morphToOne' &&\r\n            attribute.relation !== 'morphToMany'\r\n          ) {\r\n            const data = await serviceUtils.getRelationRestoreValue(versionRelationData, attribute);\r\n            previousRelationAttributes[name] = data;\r\n          }\r\n\r\n          if (attribute.type === 'media') {\r\n            const data = await serviceUtils.getMediaRestoreValue(versionRelationData, attribute);\r\n            previousRelationAttributes[name] = data;\r\n          }\r\n\r\n          return previousRelationAttributes;\r\n        },\r\n        // Clone to avoid mutating the original version data\r\n        structuredClone(dataWithoutAddedAttributes)\r\n      );\r\n\r\n      const data = omit(['id', ...Object.keys(schemaDiff.removed)], dataWithoutMissingRelations);\r\n      const restoredDocument = await strapi.documents(version.contentType).update({\r\n        documentId: version.relatedDocumentId,\r\n        locale: version.locale,\r\n        data,\r\n      });\r\n\r\n      if (!restoredDocument) {\r\n        throw new errors.ApplicationError('Failed to restore version');\r\n      }\r\n\r\n      return restoredDocument;\r\n    },\r\n  };\r\n};\r\n\r\nexport { createHistoryService };\r\n","import type { Core, Modules, UID } from '@strapi/types';\r\nimport { contentTypes } from '@strapi/utils';\r\n\r\nimport { omit, castArray } from 'lodash/fp';\r\n\r\nimport { scheduleJob } from 'node-schedule';\r\n\r\nimport { getService } from '../utils';\r\nimport { FIELDS_TO_IGNORE, HISTORY_VERSION_UID } from '../constants';\r\n\r\nimport { CreateHistoryVersion } from '../../../../shared/contracts/history-versions';\r\nimport { createServiceUtils } from './utils';\r\n\r\n/**\r\n * Filters out actions that should not create a history version.\r\n */\r\nconst shouldCreateHistoryVersion = (\r\n  context: Modules.Documents.Middleware.Context\r\n): context is Modules.Documents.Middleware.Context & {\r\n  action: 'create' | 'update' | 'clone' | 'publish' | 'unpublish' | 'discardDraft';\r\n  contentType: UID.CollectionType;\r\n} => {\r\n  // Ignore requests that are not related to the content manager\r\n  if (!strapi.requestContext.get()?.request.url.startsWith('/content-manager')) {\r\n    return false;\r\n  }\r\n\r\n  // NOTE: cannot do type narrowing with array includes\r\n  if (\r\n    context.action !== 'create' &&\r\n    context.action !== 'update' &&\r\n    context.action !== 'clone' &&\r\n    context.action !== 'publish' &&\r\n    context.action !== 'unpublish' &&\r\n    context.action !== 'discardDraft'\r\n  ) {\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * When a document is published, the draft version of the document is also updated.\r\n   * It creates confusion for users because they see two history versions each publish action.\r\n   * To avoid this, we silence the update action during a publish request,\r\n   * so that they only see the published version of the document in the history.\r\n   */\r\n  if (\r\n    context.action === 'update' &&\r\n    strapi.requestContext.get()?.request.url.endsWith('/actions/publish')\r\n  ) {\r\n    return false;\r\n  }\r\n\r\n  // Ignore content types not created by the user\r\n  if (!context.contentType.uid.startsWith('api::')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n/**\r\n * Returns the content type schema (and its components schemas).\r\n * Used to determine if changes were made in the content type builder since a history version was created.\r\n * And therefore which fields can be restored and which cannot.\r\n */\r\nconst getSchemas = (uid: UID.CollectionType) => {\r\n  const attributesSchema = strapi.getModel(uid).attributes;\r\n\r\n  // TODO: Handle nested components\r\n  const componentsSchemas = Object.keys(attributesSchema).reduce(\r\n    (currentComponentSchemas, key) => {\r\n      const fieldSchema = attributesSchema[key];\r\n\r\n      if (fieldSchema.type === 'component') {\r\n        const componentSchema = strapi.getModel(fieldSchema.component).attributes;\r\n        return {\r\n          ...currentComponentSchemas,\r\n          [fieldSchema.component]: componentSchema,\r\n        };\r\n      }\r\n\r\n      // Ignore anything that's not a component\r\n      return currentComponentSchemas;\r\n    },\r\n    {} as CreateHistoryVersion['componentsSchemas']\r\n  );\r\n\r\n  return {\r\n    schema: omit(FIELDS_TO_IGNORE, attributesSchema) as CreateHistoryVersion['schema'],\r\n    componentsSchemas,\r\n  };\r\n};\r\n\r\nconst createLifecyclesService = ({ strapi }: { strapi: Core.Strapi }) => {\r\n  const state: {\r\n    deleteExpiredJob: ReturnType<typeof scheduleJob> | null;\r\n    isInitialized: boolean;\r\n  } = {\r\n    deleteExpiredJob: null,\r\n    isInitialized: false,\r\n  };\r\n\r\n  const serviceUtils = createServiceUtils({ strapi });\r\n\r\n  return {\r\n    async bootstrap() {\r\n      // Prevent initializing the service twice\r\n      if (state.isInitialized) {\r\n        return;\r\n      }\r\n\r\n      strapi.documents.use(async (context, next) => {\r\n        const result = (await next()) as any;\r\n\r\n        if (!shouldCreateHistoryVersion(context)) {\r\n          return result;\r\n        }\r\n\r\n        // On create/clone actions, the documentId is not available before creating the action is executed\r\n        const documentId =\r\n          context.action === 'create' || context.action === 'clone'\r\n            ? result.documentId\r\n            : context.params.documentId;\r\n\r\n        // Apply default locale if not available in the request\r\n        const defaultLocale = await serviceUtils.getDefaultLocale();\r\n        const locales = castArray(context.params?.locale || defaultLocale);\r\n        if (!locales.length) {\r\n          return result;\r\n        }\r\n\r\n        // All schemas related to the content type\r\n        const uid = context.contentType.uid;\r\n        const schemas = getSchemas(uid);\r\n        const model = strapi.getModel(uid);\r\n\r\n        const isLocalizedContentType = serviceUtils.isLocalizedContentType(model);\r\n\r\n        // Find all affected entries\r\n        const localeEntries = await strapi.db.query(uid).findMany({\r\n          where: {\r\n            documentId,\r\n            ...(isLocalizedContentType ? { locale: { $in: locales } } : {}),\r\n            ...(contentTypes.hasDraftAndPublish(strapi.contentTypes[uid])\r\n              ? { publishedAt: null }\r\n              : {}),\r\n          },\r\n          populate: serviceUtils.getDeepPopulate(uid, true /* use database syntax */),\r\n        });\r\n\r\n        await strapi.db.transaction(async ({ onCommit }) => {\r\n          // .createVersion() is executed asynchronously,\r\n          // onCommit prevents creating a history version\r\n          // when the transaction has already been committed\r\n          onCommit(async () => {\r\n            for (const entry of localeEntries) {\r\n              const status = await serviceUtils.getVersionStatus(uid, entry);\r\n\r\n              await getService(strapi, 'history').createVersion({\r\n                contentType: uid,\r\n                data: omit(FIELDS_TO_IGNORE, entry) as Modules.Documents.AnyDocument,\r\n                relatedDocumentId: documentId,\r\n                locale: entry.locale,\r\n                status,\r\n                ...schemas,\r\n              });\r\n            }\r\n          });\r\n        });\r\n\r\n        return result;\r\n      });\r\n\r\n      // Schedule a job to delete expired history versions every day at midnight\r\n      state.deleteExpiredJob = scheduleJob('historyDaily', '0 0 * * *', () => {\r\n        const retentionDaysInMilliseconds = serviceUtils.getRetentionDays() * 24 * 60 * 60 * 1000;\r\n        const expirationDate = new Date(Date.now() - retentionDaysInMilliseconds);\r\n\r\n        strapi.db\r\n          .query(HISTORY_VERSION_UID)\r\n          .deleteMany({\r\n            where: {\r\n              created_at: {\r\n                $lt: expirationDate,\r\n              },\r\n            },\r\n          })\r\n          .catch((error) => {\r\n            if (error instanceof Error) {\r\n              strapi.log.error('Error deleting expired history versions', error.message);\r\n            }\r\n          });\r\n      });\r\n\r\n      state.isInitialized = true;\r\n    },\r\n\r\n    async destroy() {\r\n      if (state.deleteExpiredJob) {\r\n        state.deleteExpiredJob.cancel();\r\n      }\r\n    },\r\n  };\r\n};\r\n\r\nexport { createLifecyclesService };\r\n","import type { Plugin } from '@strapi/types';\r\nimport { createHistoryService } from './history';\r\nimport { createLifecyclesService } from './lifecycles';\r\n\r\nexport const services = {\r\n  history: createHistoryService,\r\n  lifecycles: createLifecyclesService,\r\n} satisfies Plugin.LoadedPlugin['services'];\r\n","import type { Plugin } from '@strapi/types';\r\n\r\nconst info = { pluginName: 'content-manager', type: 'admin' };\r\n\r\nconst historyVersionRouter: Plugin.LoadedPlugin['routes'][string] = {\r\n  type: 'admin',\r\n  routes: [\r\n    {\r\n      method: 'GET',\r\n      info,\r\n      path: '/history-versions',\r\n      handler: 'history-version.findMany',\r\n      config: {\r\n        policies: ['admin::isAuthenticatedAdmin'],\r\n      },\r\n    },\r\n    {\r\n      method: 'PUT',\r\n      info,\r\n      path: '/history-versions/:versionId/restore',\r\n      handler: 'history-version.restoreVersion',\r\n      config: {\r\n        policies: ['admin::isAuthenticatedAdmin'],\r\n      },\r\n    },\r\n  ],\r\n};\r\n\r\nexport { historyVersionRouter };\r\n","import type { Plugin } from '@strapi/types';\r\nimport { historyVersionRouter } from './history-version';\r\n\r\n/**\r\n * The routes will me merged with the other Content Manager routers,\r\n * so we need to avoid conficts in the router name, and to prefix the path for each route.\r\n */\r\nexport const routes = {\r\n  'history-version': historyVersionRouter,\r\n} satisfies Plugin.LoadedPlugin['routes'];\r\n","import type { Model } from '@strapi/database';\r\nimport { HISTORY_VERSION_UID } from '../constants';\r\n\r\nconst historyVersion: Model = {\r\n  uid: HISTORY_VERSION_UID,\r\n  tableName: 'strapi_history_versions',\r\n  singularName: 'history-version',\r\n  attributes: {\r\n    id: {\r\n      type: 'increments',\r\n    },\r\n    contentType: {\r\n      type: 'string',\r\n      column: { notNullable: true },\r\n    },\r\n    relatedDocumentId: {\r\n      type: 'string',\r\n      // TODO: notNullable should be true once history can record publish actions\r\n      column: { notNullable: false },\r\n    },\r\n    locale: {\r\n      type: 'string',\r\n    },\r\n    status: {\r\n      type: 'enumeration',\r\n      enum: ['draft', 'published', 'modified'],\r\n    },\r\n    data: {\r\n      type: 'json',\r\n    },\r\n    schema: {\r\n      type: 'json',\r\n    },\r\n    createdAt: {\r\n      type: 'datetime',\r\n      default: () => new Date(),\r\n    },\r\n    // FIXME: joinTable should be optional\r\n    // @ts-expect-error database model is not yet updated to support useJoinTable\r\n    createdBy: {\r\n      type: 'relation',\r\n      relation: 'oneToOne',\r\n      target: 'admin::user',\r\n      useJoinTable: false,\r\n    },\r\n  },\r\n};\r\n\r\nexport { historyVersion };\r\n","import type { Plugin } from '@strapi/types';\r\nimport { controllers } from './controllers';\r\nimport { services } from './services';\r\nimport { routes } from './routes';\r\nimport { getService } from './utils';\r\nimport { historyVersion } from './models/history-version';\r\n\r\n/**\r\n * Check once if the feature is enabled before loading it,\r\n * so that we can assume it is enabled in the other files.\r\n */\r\nconst getFeature = (): Partial<Plugin.LoadedPlugin> => {\r\n  if (strapi.ee.features.isEnabled('cms-content-history')) {\r\n    return {\r\n      register({ strapi }) {\r\n        strapi.get('models').add(historyVersion);\r\n      },\r\n      bootstrap({ strapi }) {\r\n        // Start recording history and saving history versions\r\n        getService(strapi, 'lifecycles').bootstrap();\r\n      },\r\n      destroy({ strapi }) {\r\n        getService(strapi, 'lifecycles').destroy();\r\n      },\r\n      controllers,\r\n      services,\r\n      routes,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Keep registering the model to avoid losing the data if the feature is disabled,\r\n   * or if the license expires.\r\n   */\r\n  return {\r\n    register({ strapi }) {\r\n      strapi.get('models').add(historyVersion);\r\n    },\r\n  };\r\n};\r\n\r\nexport default getFeature();\r\n","export const FEATURE_ID = 'preview';\r\n","import type { Plugin } from '@strapi/types';\r\n\r\nconst info = { pluginName: 'content-manager', type: 'admin' };\r\n\r\nconst previewRouter: Plugin.LoadedPlugin['routes'][string] = {\r\n  type: 'admin',\r\n  routes: [\r\n    {\r\n      method: 'GET',\r\n      info,\r\n      path: '/preview/url/:contentType',\r\n      handler: 'preview.getPreviewUrl',\r\n      config: {\r\n        policies: ['admin::isAuthenticatedAdmin'],\r\n      },\r\n    },\r\n  ],\r\n};\r\n\r\nexport { previewRouter };\r\n","import type { Plugin } from '@strapi/types';\r\nimport { previewRouter } from './preview';\r\n\r\n/**\r\n * The routes will be merged with the other Content Manager routers,\r\n * so we need to avoid conficts in the router name, and to prefix the path for each route.\r\n */\r\nexport const routes = {\r\n  preview: previewRouter,\r\n} satisfies Plugin.LoadedPlugin['routes'];\r\n","import type { Core } from '@strapi/types';\r\n\r\ntype PreviewServices = typeof import('./services').services;\r\n\r\nfunction getService<T extends keyof PreviewServices>(strapi: Core.Strapi, name: T) {\r\n  // Cast is needed because the return type of strapi.service is too vague\r\n  return strapi.service(`plugin::content-manager.${name}`) as ReturnType<PreviewServices[T]>;\r\n}\r\n\r\nexport { getService };\r\n","import * as yup from 'yup';\r\nimport { pick } from 'lodash/fp';\r\n\r\nimport type { Core, UID } from '@strapi/types';\r\nimport { validateYupSchema, errors } from '@strapi/utils';\r\n\r\nimport { Preview } from '../../../../../shared/contracts';\r\nimport type { HandlerParams } from '../../services/preview-config';\r\n\r\nconst getPreviewUrlSchema = yup\r\n  .object()\r\n  .shape({\r\n    // Will be undefined for single types\r\n    documentId: yup.string(),\r\n    locale: yup.string().nullable(),\r\n    status: yup.string(),\r\n  })\r\n  .required();\r\n\r\nexport const validatePreviewUrl = async (\r\n  strapi: Core.Strapi,\r\n  uid: UID.ContentType,\r\n  params: Preview.GetPreviewUrl.Request['query']\r\n): Promise<HandlerParams> => {\r\n  // Validate the request parameters format\r\n  await validateYupSchema(getPreviewUrlSchema)(params);\r\n\r\n  const newParams = pick(['documentId', 'locale', 'status'], params) as HandlerParams;\r\n  const model = strapi.getModel(uid);\r\n\r\n  // If it's not a collection type or single type\r\n  if (!model || model.modelType !== 'contentType') {\r\n    throw new errors.ValidationError('Invalid content type');\r\n  }\r\n\r\n  // Document id is not required for single types\r\n  const isSingleType = model?.kind === 'singleType';\r\n  if (!isSingleType && !params.documentId) {\r\n    throw new errors.ValidationError('documentId is required for Collection Types');\r\n  }\r\n\r\n  // Fill the documentId if it's a single type\r\n  if (isSingleType) {\r\n    const doc = await strapi.documents(uid).findFirst();\r\n\r\n    if (!doc) {\r\n      throw new errors.NotFoundError('Document not found');\r\n    }\r\n\r\n    newParams.documentId = doc?.documentId;\r\n  }\r\n\r\n  /**\r\n   * If status is not specified, follow the following rules:\r\n   * - D&P disabled: status is considered published\r\n   * - D&P enabled: status is considered draft\r\n   */\r\n  if (!newParams.status) {\r\n    const isDPEnabled = model?.options?.draftAndPublish;\r\n    newParams.status = isDPEnabled ? 'draft' : 'published';\r\n  }\r\n\r\n  return newParams;\r\n};\r\n","import type { Core, UID } from '@strapi/types';\r\n\r\nimport { Preview } from '../../../../shared/contracts';\r\n\r\nimport { getService } from '../utils';\r\nimport { validatePreviewUrl } from './validation/preview';\r\n\r\nconst createPreviewController = () => {\r\n  return {\r\n    /**\r\n     * Transforms an entry into a preview URL, so that it can be previewed\r\n     * in the Content Manager.\r\n     */\r\n    async getPreviewUrl(ctx) {\r\n      const uid = ctx.params.contentType as UID.ContentType;\r\n      const query = ctx.request.query as Preview.GetPreviewUrl.Request['query'];\r\n\r\n      // Validate the request parameters\r\n      const params = await validatePreviewUrl(strapi, uid, query);\r\n\r\n      // TODO: Permissions to preview content\r\n\r\n      // Get the preview URL by using the user-defined config handler\r\n      const previewService = getService(strapi, 'preview');\r\n      const url = await previewService.getPreviewUrl(uid, params);\r\n\r\n      // If no url is found, set status to 204\r\n      if (!url) {\r\n        ctx.status = 204;\r\n      }\r\n\r\n      return {\r\n        data: { url },\r\n      } satisfies Preview.GetPreviewUrl.Response;\r\n    },\r\n  } satisfies Core.Controller;\r\n};\r\n\r\nexport { createPreviewController };\r\n","import type { Plugin } from '@strapi/types';\r\nimport { createPreviewController } from './preview';\r\n\r\nexport const controllers = {\r\n  preview: createPreviewController,\r\n  /**\r\n   * Casting is needed because the types aren't aware that Strapi supports\r\n   * passing a controller factory as the value, instead of a controller object directly\r\n   */\r\n} as unknown as Plugin.LoadedPlugin['controllers'];\r\n","import type { Core, UID } from '@strapi/types';\r\nimport { errors } from '@strapi/utils';\r\n\r\nimport { getService } from '../utils';\r\nimport type { HandlerParams } from './preview-config';\r\n\r\n/**\r\n * Responsible of routing an entry to a preview URL.\r\n */\r\nconst createPreviewService = ({ strapi }: { strapi: Core.Strapi }) => {\r\n  const config = getService(strapi, 'preview-config');\r\n\r\n  return {\r\n    async getPreviewUrl(uid: UID.ContentType, params: HandlerParams) {\r\n      const handler = config.getPreviewHandler();\r\n\r\n      try {\r\n        // Try to get the preview URL from the user-defined handler\r\n        return handler(uid, params);\r\n      } catch (error) {\r\n        // Log the error and throw a generic error\r\n        strapi.log.error(`Failed to get preview URL: ${error}`);\r\n        throw new errors.ApplicationError('Failed to get preview URL');\r\n      }\r\n\r\n      return;\r\n    },\r\n  };\r\n};\r\n\r\nexport { createPreviewService };\r\n","import { mergeWith } from 'lodash/fp';\r\n\r\nimport type { Core, UID } from '@strapi/types';\r\nimport { errors } from '@strapi/utils';\r\n\r\nexport type HandlerParams = {\r\n  documentId: string;\r\n  locale: string;\r\n  status: 'published' | 'draft';\r\n};\r\n\r\nexport interface PreviewConfig {\r\n  enabled: boolean;\r\n  config: {\r\n    // List of CSP allowed origins. This is a shortcut to setting it up inside `config/middlewares.js`\r\n    allowedOrigins: string[];\r\n    handler: (uid: UID.Schema, params: HandlerParams) => string | undefined;\r\n  };\r\n}\r\n\r\n/**\r\n * Utility to extend Strapi configuration middlewares. Mainly used to extend the CSP directives from the security middleware.\r\n */\r\nconst extendMiddlewareConfiguration = (middleware = { name: '', config: {} }) => {\r\n  const middlewares = strapi.config.get('middlewares') as (string | object)[];\r\n\r\n  const configuredMiddlewares = middlewares.map((currentMiddleware) => {\r\n    if (currentMiddleware === middleware.name) {\r\n      // Use the new config object if the middleware has no config property yet\r\n      return middleware;\r\n    }\r\n\r\n    // @ts-expect-error - currentMiddleware is not a string\r\n    if (currentMiddleware.name === middleware.name) {\r\n      // Deep merge (+ concat arrays) the new config with the current middleware config\r\n      return mergeWith(\r\n        (objValue, srcValue) => {\r\n          if (Array.isArray(objValue)) {\r\n            return objValue.concat(srcValue);\r\n          }\r\n\r\n          return undefined;\r\n        },\r\n        currentMiddleware,\r\n        middleware\r\n      );\r\n    }\r\n\r\n    return currentMiddleware;\r\n  });\r\n\r\n  strapi.config.set('middlewares', configuredMiddlewares);\r\n};\r\n\r\n/**\r\n * Read configuration for static preview\r\n */\r\nconst createPreviewConfigService = ({ strapi }: { strapi: Core.Strapi }) => {\r\n  return {\r\n    register() {\r\n      if (!this.isEnabled()) {\r\n        return;\r\n      }\r\n\r\n      const config = strapi.config.get('admin.preview') as PreviewConfig;\r\n\r\n      /**\r\n       * Register the allowed origins for CSP, so the preview URL can be displayed\r\n       */\r\n      if (config.config?.allowedOrigins) {\r\n        extendMiddlewareConfiguration({\r\n          name: 'strapi::security',\r\n          config: {\r\n            contentSecurityPolicy: {\r\n              directives: {\r\n                'frame-src': config.config.allowedOrigins,\r\n              },\r\n            },\r\n          },\r\n        });\r\n      }\r\n    },\r\n\r\n    isEnabled() {\r\n      const config = strapi.config.get('admin.preview') as PreviewConfig;\r\n\r\n      if (!config) {\r\n        return false;\r\n      }\r\n\r\n      return config?.enabled ?? true;\r\n    },\r\n\r\n    /**\r\n     * Validate if the configuration is valid\r\n     */\r\n    validate() {\r\n      if (!this.isEnabled()) {\r\n        return;\r\n      }\r\n\r\n      const handler = this.getPreviewHandler();\r\n\r\n      // Handler must be a function\r\n      if (typeof handler !== 'function') {\r\n        throw new errors.ValidationError(\r\n          'Preview configuration is invalid. Handler must be a function'\r\n        );\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Utility to get the preview handler from the configuration\r\n     */\r\n    getPreviewHandler(): PreviewConfig['config']['handler'] {\r\n      const config = strapi.config.get('admin.preview') as PreviewConfig;\r\n\r\n      const emptyHandler = () => {\r\n        return undefined;\r\n      };\r\n\r\n      if (!this.isEnabled()) {\r\n        return emptyHandler;\r\n      }\r\n\r\n      return config?.config?.handler || emptyHandler;\r\n    },\r\n  };\r\n};\r\n\r\nexport { createPreviewConfigService };\r\n","import type { Plugin } from '@strapi/types';\r\n\r\nimport { createPreviewService } from './preview';\r\nimport { createPreviewConfigService } from './preview-config';\r\n\r\nexport const services = {\r\n  preview: createPreviewService,\r\n  'preview-config': createPreviewConfigService,\r\n} satisfies Plugin.LoadedPlugin['services'];\r\n","import type { Plugin } from '@strapi/types';\r\n\r\nimport { FEATURE_ID } from './constants';\r\nimport { routes } from './routes';\r\nimport { controllers } from './controllers';\r\nimport { services } from './services';\r\nimport { getService } from './utils';\r\n\r\n/**\r\n * Check once if the feature is enabled before loading it,\r\n * so that we can assume it is enabled in the other files.\r\n */\r\nconst getFeature = (): Partial<Plugin.LoadedPlugin> => {\r\n  if (!strapi.features.future.isEnabled(FEATURE_ID)) {\r\n    return {};\r\n  }\r\n\r\n  // TODO: Add license registry check when it's available\r\n  // if (!strapi.ee.features.isEnabled('cms-content-preview')) {\r\n  //   return {};\r\n  // }\r\n\r\n  return {\r\n    register() {\r\n      const config = getService(strapi, 'preview-config');\r\n      config.validate();\r\n      config.register();\r\n    },\r\n    bootstrap() {},\r\n    routes,\r\n    controllers,\r\n    services,\r\n  };\r\n};\r\n\r\nexport default getFeature();\r\n","import type { Plugin } from '@strapi/types';\r\nimport history from './history';\r\nimport preview from './preview';\r\n\r\nconst register: Plugin.LoadedPlugin['register'] = async ({ strapi }) => {\r\n  await history.register?.({ strapi });\r\n  await preview.register?.({ strapi });\r\n};\r\n\r\nexport default register;\r\n","const ALLOWED_WEBHOOK_EVENTS = {\r\n  ENTRY_PUBLISH: 'entry.publish',\r\n  ENTRY_UNPUBLISH: 'entry.unpublish',\r\n};\r\n\r\nexport { ALLOWED_WEBHOOK_EVENTS };\r\n","import { getService } from './utils';\r\nimport { ALLOWED_WEBHOOK_EVENTS } from './constants';\r\nimport history from './history';\r\nimport preview from './preview';\r\n\r\nexport default async () => {\r\n  Object.entries(ALLOWED_WEBHOOK_EVENTS).forEach(([key, value]) => {\r\n    strapi.get('webhookStore').addAllowedEvent(key, value);\r\n  });\r\n\r\n  getService('field-sizes').setCustomFieldInputSizes();\r\n  await getService('components').syncConfigurations();\r\n  await getService('content-types').syncConfigurations();\r\n  await getService('permission').registerPermissions();\r\n\r\n  await history.bootstrap?.({ strapi });\r\n  await preview.bootstrap?.({ strapi });\r\n};\r\n","import type { Plugin } from '@strapi/types';\r\nimport history from './history';\r\n\r\nconst destroy: Plugin.LoadedPlugin['destroy'] = async ({ strapi }) => {\r\n  await history.destroy?.({ strapi });\r\n};\r\n\r\nexport default destroy;\r\n","import type { UID, Core, Struct } from '@strapi/types';\r\nimport type { Context, Next } from 'koa';\r\nimport isNil from 'lodash/isNil';\r\n\r\ninterface ContentType extends Struct.ContentTypeSchema {\r\n  plugin?: string;\r\n}\r\n\r\nexport default async (ctx: Context, next: Next) => {\r\n  const { model }: { model: UID.ContentType } = ctx.params;\r\n\r\n  const ct: ContentType = strapi.contentTypes[model];\r\n\r\n  if (!ct) {\r\n    return ctx.send({ error: 'contentType.notFound' }, 404);\r\n  }\r\n\r\n  let controllers;\r\n  if (!ct.plugin || ct.plugin === 'admin') {\r\n    controllers = strapi.admin.controllers;\r\n  } else {\r\n    controllers = strapi.plugin(ct.plugin).controllers;\r\n  }\r\n\r\n  const { route }: { route: Core.Route } = ctx.state;\r\n\r\n  if (typeof route.handler !== 'string') {\r\n    return next();\r\n  }\r\n\r\n  const [, action] = route.handler.split('.');\r\n\r\n  let actionConfig: any;\r\n  if (!ct.plugin || ct.plugin === 'admin') {\r\n    actionConfig = strapi.config.get(`admin.layout.${ct.modelName}.actions.${action}`);\r\n  } else {\r\n    actionConfig = strapi.plugin(ct.plugin).config(`layout.${ct.modelName}.actions.${action}`);\r\n  }\r\n\r\n  if (!isNil(actionConfig)) {\r\n    const [controller, action] = actionConfig.split('.');\r\n\r\n    if (controller && action) {\r\n      return controllers[controller.toLowerCase()][action](ctx, next);\r\n    }\r\n  }\r\n\r\n  await next();\r\n};\r\n","import { routing } from '../middlewares';\r\n\r\nexport default {\r\n  type: 'admin',\r\n  routes: [\r\n    {\r\n      method: 'GET',\r\n      path: '/init',\r\n      handler: 'init.getInitData',\r\n      config: {\r\n        policies: [],\r\n      },\r\n    },\r\n    {\r\n      method: 'GET',\r\n      path: '/content-types',\r\n      handler: 'content-types.findContentTypes',\r\n      config: {\r\n        policies: [],\r\n      },\r\n    },\r\n    {\r\n      method: 'GET',\r\n      path: '/content-types-settings',\r\n      handler: 'content-types.findContentTypesSettings',\r\n      config: {\r\n        policies: [],\r\n      },\r\n    },\r\n    {\r\n      method: 'GET',\r\n      path: '/content-types/:uid/configuration',\r\n      handler: 'content-types.findContentTypeConfiguration',\r\n      config: {\r\n        policies: [],\r\n      },\r\n    },\r\n    {\r\n      method: 'PUT',\r\n      path: '/content-types/:uid/configuration',\r\n      handler: 'content-types.updateContentTypeConfiguration',\r\n      config: {\r\n        policies: ['admin::isAuthenticatedAdmin'],\r\n      },\r\n    },\r\n\r\n    {\r\n      method: 'GET',\r\n      path: '/components',\r\n      handler: 'components.findComponents',\r\n      config: {\r\n        policies: [],\r\n      },\r\n    },\r\n    {\r\n      method: 'GET',\r\n      path: '/components/:uid/configuration',\r\n      handler: 'components.findComponentConfiguration',\r\n      config: {\r\n        policies: [],\r\n      },\r\n    },\r\n    {\r\n      method: 'PUT',\r\n      path: '/components/:uid/configuration',\r\n      handler: 'components.updateComponentConfiguration',\r\n      config: {\r\n        policies: [],\r\n      },\r\n    },\r\n\r\n    {\r\n      method: 'POST',\r\n      path: '/uid/generate',\r\n      handler: 'uid.generateUID',\r\n      config: {\r\n        policies: [],\r\n      },\r\n    },\r\n    {\r\n      method: 'POST',\r\n      path: '/uid/check-availability',\r\n      handler: 'uid.checkUIDAvailability',\r\n      config: {\r\n        policies: [],\r\n      },\r\n    },\r\n    {\r\n      method: 'GET',\r\n      path: '/relations/:model/:targetField',\r\n      handler: 'relations.findAvailable',\r\n      config: {\r\n        policies: ['admin::isAuthenticatedAdmin'],\r\n      },\r\n    },\r\n    {\r\n      method: 'GET',\r\n      path: '/relations/:model/:id/:targetField',\r\n      handler: 'relations.findExisting',\r\n      config: {\r\n        policies: ['admin::isAuthenticatedAdmin'],\r\n      },\r\n    },\r\n    {\r\n      method: 'GET',\r\n      path: '/single-types/:model',\r\n      handler: 'single-types.find',\r\n      config: {\r\n        middlewares: [routing],\r\n        policies: [\r\n          'admin::isAuthenticatedAdmin',\r\n          {\r\n            name: 'plugin::content-manager.hasPermissions',\r\n            config: { actions: ['plugin::content-manager.explorer.read'] },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    {\r\n      method: 'PUT',\r\n      path: '/single-types/:model',\r\n      handler: 'single-types.createOrUpdate',\r\n      config: {\r\n        middlewares: [routing],\r\n        policies: [\r\n          'admin::isAuthenticatedAdmin',\r\n          {\r\n            name: 'plugin::content-manager.hasPermissions',\r\n            config: {\r\n              actions: [\r\n                'plugin::content-manager.explorer.create',\r\n                'plugin::content-manager.explorer.update',\r\n              ],\r\n              hasAtLeastOne: true,\r\n            },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    {\r\n      method: 'DELETE',\r\n      path: '/single-types/:model',\r\n      handler: 'single-types.delete',\r\n      config: {\r\n        middlewares: [routing],\r\n        policies: [\r\n          'admin::isAuthenticatedAdmin',\r\n          {\r\n            name: 'plugin::content-manager.hasPermissions',\r\n            config: { actions: ['plugin::content-manager.explorer.delete'] },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    {\r\n      method: 'POST',\r\n      path: '/single-types/:model/actions/publish',\r\n      handler: 'single-types.publish',\r\n      config: {\r\n        middlewares: [routing],\r\n        policies: [\r\n          'admin::isAuthenticatedAdmin',\r\n          {\r\n            name: 'plugin::content-manager.hasPermissions',\r\n            config: { actions: ['plugin::content-manager.explorer.publish'] },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    {\r\n      method: 'POST',\r\n      path: '/single-types/:model/actions/unpublish',\r\n      handler: 'single-types.unpublish',\r\n      config: {\r\n        middlewares: [routing],\r\n        policies: [\r\n          'admin::isAuthenticatedAdmin',\r\n          {\r\n            name: 'plugin::content-manager.hasPermissions',\r\n            config: { actions: ['plugin::content-manager.explorer.publish'] },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    {\r\n      method: 'POST',\r\n      path: '/single-types/:model/actions/discard',\r\n      handler: 'single-types.discard',\r\n      config: {\r\n        middlewares: [routing],\r\n        policies: [\r\n          'admin::isAuthenticatedAdmin',\r\n          {\r\n            name: 'plugin::content-manager.hasPermissions',\r\n            config: { actions: ['plugin::content-manager.explorer.update'] },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    {\r\n      method: 'GET',\r\n      path: '/single-types/:model/actions/countDraftRelations',\r\n      handler: 'single-types.countDraftRelations',\r\n      config: {\r\n        middlewares: [routing],\r\n        policies: [\r\n          'admin::isAuthenticatedAdmin',\r\n          {\r\n            name: 'plugin::content-manager.hasPermissions',\r\n            config: { actions: ['plugin::content-manager.explorer.read'] },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    {\r\n      method: 'GET',\r\n      path: '/collection-types/:model',\r\n      handler: 'collection-types.find',\r\n      config: {\r\n        middlewares: [routing],\r\n        policies: [\r\n          'admin::isAuthenticatedAdmin',\r\n          {\r\n            name: 'plugin::content-manager.hasPermissions',\r\n            config: { actions: ['plugin::content-manager.explorer.read'] },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    {\r\n      method: 'POST',\r\n      path: '/collection-types/:model',\r\n      handler: 'collection-types.create',\r\n      config: {\r\n        middlewares: [routing],\r\n        policies: [\r\n          'admin::isAuthenticatedAdmin',\r\n          {\r\n            name: 'plugin::content-manager.hasPermissions',\r\n            config: { actions: ['plugin::content-manager.explorer.create'] },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    {\r\n      method: 'POST',\r\n      path: '/collection-types/:model/clone/:sourceId',\r\n      handler: 'collection-types.clone',\r\n      config: {\r\n        middlewares: [routing],\r\n        policies: [\r\n          'admin::isAuthenticatedAdmin',\r\n          {\r\n            name: 'plugin::content-manager.hasPermissions',\r\n            config: { actions: ['plugin::content-manager.explorer.create'] },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    {\r\n      method: 'POST',\r\n      path: '/collection-types/:model/auto-clone/:sourceId',\r\n      handler: 'collection-types.autoClone',\r\n      config: {\r\n        middlewares: [routing],\r\n        policies: [\r\n          'admin::isAuthenticatedAdmin',\r\n          {\r\n            name: 'plugin::content-manager.hasPermissions',\r\n            config: { actions: ['plugin::content-manager.explorer.create'] },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    {\r\n      method: 'GET',\r\n      path: '/collection-types/:model/:id',\r\n      handler: 'collection-types.findOne',\r\n      config: {\r\n        middlewares: [routing],\r\n        policies: [\r\n          'admin::isAuthenticatedAdmin',\r\n          {\r\n            name: 'plugin::content-manager.hasPermissions',\r\n            config: { actions: ['plugin::content-manager.explorer.read'] },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    {\r\n      method: 'PUT',\r\n      path: '/collection-types/:model/:id',\r\n      handler: 'collection-types.update',\r\n      config: {\r\n        middlewares: [routing],\r\n        policies: [\r\n          'admin::isAuthenticatedAdmin',\r\n          {\r\n            name: 'plugin::content-manager.hasPermissions',\r\n            config: { actions: ['plugin::content-manager.explorer.update'] },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    {\r\n      method: 'DELETE',\r\n      path: '/collection-types/:model/:id',\r\n      handler: 'collection-types.delete',\r\n      config: {\r\n        middlewares: [routing],\r\n        policies: [\r\n          'admin::isAuthenticatedAdmin',\r\n          {\r\n            name: 'plugin::content-manager.hasPermissions',\r\n            config: { actions: ['plugin::content-manager.explorer.delete'] },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    {\r\n      method: 'POST',\r\n      path: '/collection-types/:model/actions/publish',\r\n      handler: 'collection-types.publish',\r\n      config: {\r\n        middlewares: [routing],\r\n        policies: [\r\n          'admin::isAuthenticatedAdmin',\r\n          {\r\n            name: 'plugin::content-manager.hasPermissions',\r\n            config: { actions: ['plugin::content-manager.explorer.publish'] },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    {\r\n      method: 'POST',\r\n      path: '/collection-types/:model/:id/actions/publish',\r\n      handler: 'collection-types.publish',\r\n      config: {\r\n        middlewares: [routing],\r\n        policies: [\r\n          'admin::isAuthenticatedAdmin',\r\n          {\r\n            name: 'plugin::content-manager.hasPermissions',\r\n            config: { actions: ['plugin::content-manager.explorer.publish'] },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    {\r\n      method: 'POST',\r\n      path: '/collection-types/:model/:id/actions/unpublish',\r\n      handler: 'collection-types.unpublish',\r\n      config: {\r\n        middlewares: [routing],\r\n        policies: [\r\n          'admin::isAuthenticatedAdmin',\r\n          {\r\n            name: 'plugin::content-manager.hasPermissions',\r\n            config: { actions: ['plugin::content-manager.explorer.publish'] },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    {\r\n      method: 'POST',\r\n      path: '/collection-types/:model/:id/actions/discard',\r\n      handler: 'collection-types.discard',\r\n      config: {\r\n        middlewares: [routing],\r\n        policies: [\r\n          'admin::isAuthenticatedAdmin',\r\n          {\r\n            name: 'plugin::content-manager.hasPermissions',\r\n            config: { actions: ['plugin::content-manager.explorer.update'] },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    {\r\n      method: 'POST',\r\n      path: '/collection-types/:model/actions/bulkDelete',\r\n      handler: 'collection-types.bulkDelete',\r\n      config: {\r\n        middlewares: [routing],\r\n        policies: [\r\n          'admin::isAuthenticatedAdmin',\r\n          {\r\n            name: 'plugin::content-manager.hasPermissions',\r\n            config: { actions: ['plugin::content-manager.explorer.delete'] },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    {\r\n      method: 'POST',\r\n      path: '/collection-types/:model/actions/bulkPublish',\r\n      handler: 'collection-types.bulkPublish',\r\n      config: {\r\n        middlewares: [routing],\r\n        policies: [\r\n          'admin::isAuthenticatedAdmin',\r\n          {\r\n            name: 'plugin::content-manager.hasPermissions',\r\n            config: { actions: ['plugin::content-manager.explorer.publish'] },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    {\r\n      method: 'POST',\r\n      path: '/collection-types/:model/actions/bulkUnpublish',\r\n      handler: 'collection-types.bulkUnpublish',\r\n      config: {\r\n        middlewares: [routing],\r\n        policies: [\r\n          'admin::isAuthenticatedAdmin',\r\n          {\r\n            name: 'plugin::content-manager.hasPermissions',\r\n            config: { actions: ['plugin::content-manager.explorer.publish'] },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    {\r\n      method: 'GET',\r\n      path: '/collection-types/:model/:id/actions/countDraftRelations',\r\n      handler: 'collection-types.countDraftRelations',\r\n      config: {\r\n        middlewares: [routing],\r\n        policies: [\r\n          'admin::isAuthenticatedAdmin',\r\n          {\r\n            name: 'plugin::content-manager.hasPermissions',\r\n            config: { actions: ['plugin::content-manager.explorer.read'] },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n    {\r\n      method: 'GET',\r\n      path: '/collection-types/:model/actions/countManyEntriesDraftRelations',\r\n      handler: 'collection-types.countManyEntriesDraftRelations',\r\n      config: {\r\n        middlewares: [routing],\r\n        policies: [\r\n          'admin::isAuthenticatedAdmin',\r\n          {\r\n            name: 'plugin::content-manager.hasPermissions',\r\n            config: { actions: ['plugin::content-manager.explorer.read'] },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n  ],\r\n};\r\n","import admin from './admin';\r\nimport history from '../history';\r\nimport preview from '../preview';\r\n\r\nexport default {\r\n  admin,\r\n  ...(history.routes ? history.routes : {}),\r\n  ...(preview.routes ? preview.routes : {}),\r\n};\r\n","import { yup, validateYupSchemaSync } from '@strapi/utils';\r\n\r\nconst hasPermissionsSchema = yup.object({\r\n  actions: yup.array().of(yup.string()),\r\n  hasAtLeastOne: yup.boolean(),\r\n});\r\n\r\nexport const validateHasPermissionsInput = validateYupSchemaSync(hasPermissionsSchema);\r\n","import type { Context } from 'koa';\r\nimport { policy } from '@strapi/utils';\r\nimport { validateHasPermissionsInput } from '../validation/policies/hasPermissions';\r\n\r\nconst { createPolicy } = policy;\r\n\r\nexport default createPolicy({\r\n  name: 'plugin::content-manager.hasPermissions',\r\n  validator: validateHasPermissionsInput,\r\n  /**\r\n   * NOTE: Action aliases are currently not checked at this level (policy).\r\n   *       This is currently the intended behavior to avoid changing the behavior of API related permissions.\r\n   *       If you want to add support for it, please create a dedicated RFC with a list of potential side effect this could have.\r\n   */\r\n  handler(ctx: Context, config = {}) {\r\n    const { actions = [], hasAtLeastOne = false }: { actions: string[]; hasAtLeastOne: boolean } =\r\n      config;\r\n\r\n    const { userAbility } = ctx.state;\r\n    const { model }: { model: string } = ctx.params;\r\n\r\n    const isAuthorized = hasAtLeastOne\r\n      ? actions.some((action) => userAbility.can(action, model))\r\n      : actions.every((action) => userAbility.can(action, model));\r\n\r\n    return isAuthorized;\r\n  },\r\n});\r\n","import hasPermissions from './hasPermissions';\r\n\r\nexport default {\r\n  hasPermissions,\r\n};\r\n","import _ from 'lodash';\r\nimport { intersection } from 'lodash/fp';\r\nimport { contentTypes as contentTypesUtils } from '@strapi/utils';\r\n\r\nconst { getNonVisibleAttributes, getWritableAttributes } = contentTypesUtils;\r\nconst { PUBLISHED_AT_ATTRIBUTE, CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE } =\r\n  contentTypesUtils.constants;\r\n\r\nconst NON_SORTABLES = ['component', 'json', 'media', 'richtext', 'dynamiczone', 'blocks'];\r\nconst SORTABLE_RELATIONS = ['oneToOne', 'manyToOne'];\r\n\r\nconst NON_LISTABLES = ['json', 'password', 'richtext', 'dynamiczone', 'blocks'];\r\nconst LISTABLE_RELATIONS = ['oneToOne', 'oneToMany', 'manyToOne', 'manyToMany'];\r\n\r\n// hidden fields are fields that are configured to be hidden from list, and edit views\r\nconst isHidden = (schema: any, name: any) => {\r\n  if (!_.has(schema.attributes, name)) {\r\n    return false;\r\n  }\r\n\r\n  const isHidden = _.get(schema, ['config', 'attributes', name, 'hidden'], false);\r\n  if (isHidden === true) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nconst isListable = (schema: any, name: any) => {\r\n  if (!_.has(schema.attributes, name)) {\r\n    return false;\r\n  }\r\n\r\n  if (isHidden(schema, name)) {\r\n    return false;\r\n  }\r\n\r\n  const attribute = schema.attributes[name];\r\n  if (NON_LISTABLES.includes(attribute.type)) {\r\n    return false;\r\n  }\r\n\r\n  if (isRelation(attribute) && !LISTABLE_RELATIONS.includes(attribute.relationType)) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nconst isSortable = (schema: any, name: any) => {\r\n  if (!_.has(schema.attributes, name)) {\r\n    return false;\r\n  }\r\n\r\n  if (schema.modelType === 'component' && name === 'id') return false;\r\n\r\n  const attribute = schema.attributes[name];\r\n  if (NON_SORTABLES.includes(attribute.type)) {\r\n    return false;\r\n  }\r\n\r\n  if (isRelation(attribute) && !SORTABLE_RELATIONS.includes(attribute.relationType)) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nconst isSearchable = (schema: any, name: any) => {\r\n  return isSortable(schema, name);\r\n};\r\n\r\nconst isVisible = (schema: any, name: any) => {\r\n  if (!_.has(schema.attributes, name)) {\r\n    return false;\r\n  }\r\n\r\n  if (isHidden(schema, name)) {\r\n    return false;\r\n  }\r\n\r\n  if (isTimestamp(schema, name) || name === 'id') {\r\n    return false;\r\n  }\r\n\r\n  if (isPublicationField(name)) {\r\n    return false;\r\n  }\r\n\r\n  if (isCreatorField(schema, name)) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nconst isPublicationField = (name: any) => PUBLISHED_AT_ATTRIBUTE === name;\r\n\r\nconst isTimestamp = (schema: any, name: any) => {\r\n  if (!_.has(schema.attributes, name)) {\r\n    return false;\r\n  }\r\n\r\n  const timestamps = contentTypesUtils.getTimestamps(schema);\r\n  if (!timestamps || !Array.isArray(timestamps)) {\r\n    return false;\r\n  }\r\n\r\n  if (timestamps.includes(name)) {\r\n    return true;\r\n  }\r\n};\r\n\r\nconst isCreatorField = (schema: any, name: any) => {\r\n  if (!_.has(schema.attributes, name)) {\r\n    return false;\r\n  }\r\n\r\n  const creatorFields = contentTypesUtils.getCreatorFields(schema);\r\n  if (!creatorFields || !Array.isArray(creatorFields)) {\r\n    return false;\r\n  }\r\n\r\n  if (creatorFields.includes(name)) {\r\n    return true;\r\n  }\r\n};\r\n\r\nconst isRelation = (attribute: any) => attribute.type === 'relation';\r\n\r\nconst hasRelationAttribute = (schema: any, name: any) => {\r\n  if (!_.has(schema.attributes, name)) {\r\n    return false;\r\n  }\r\n\r\n  if (isHidden(schema, name)) {\r\n    return false;\r\n  }\r\n\r\n  if (!isVisible(schema, name)) {\r\n    return false;\r\n  }\r\n\r\n  return isRelation(schema.attributes[name]);\r\n};\r\n\r\nconst hasEditableAttribute = (schema: any, name: any) => {\r\n  if (!_.has(schema.attributes, name)) {\r\n    return false;\r\n  }\r\n\r\n  if (isHidden(schema, name)) {\r\n    return false;\r\n  }\r\n\r\n  if (!isVisible(schema, name)) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nconst findFirstStringAttribute = (schema: any) => {\r\n  return Object.keys(schema.attributes || {}).find((key) => {\r\n    const { type } = schema.attributes[key];\r\n    return type === 'string' && key !== 'id';\r\n  });\r\n};\r\n\r\nconst getDefaultMainField = (schema: any) => findFirstStringAttribute(schema) || 'id';\r\n\r\n/**\r\n * Returns list of all sortable attributes for a given content type schema\r\n * TODO V5: Refactor non visible fields to be a part of content-manager schema so we can use isSortable instead\r\n * @param {*} schema\r\n * @returns\r\n */\r\nconst getSortableAttributes = (schema: any) => {\r\n  const validAttributes = Object.keys(schema.attributes).filter((key) => isListable(schema, key));\r\n\r\n  const model = strapi.getModel(schema.uid);\r\n  const nonVisibleWritableAttributes = intersection(\r\n    getNonVisibleAttributes(model),\r\n    getWritableAttributes(model)\r\n  );\r\n\r\n  return [\r\n    'id',\r\n    ...validAttributes,\r\n    ...nonVisibleWritableAttributes,\r\n    CREATED_BY_ATTRIBUTE,\r\n    UPDATED_BY_ATTRIBUTE,\r\n  ];\r\n};\r\n\r\nexport {\r\n  isSortable,\r\n  isVisible,\r\n  isSearchable,\r\n  isRelation,\r\n  isListable,\r\n  hasEditableAttribute,\r\n  hasRelationAttribute,\r\n  getDefaultMainField,\r\n  getSortableAttributes,\r\n};\r\n","import { isEmpty, pick, pipe, propOr, isEqual } from 'lodash/fp';\r\nimport { traverse } from '@strapi/utils';\r\nimport qs from 'qs';\r\nimport { isSortable, getDefaultMainField, getSortableAttributes } from './attributes';\r\n\r\n/** General settings */\r\nconst DEFAULT_SETTINGS = {\r\n  bulkable: true,\r\n  filterable: true,\r\n  searchable: true,\r\n  pageSize: 10,\r\n};\r\n\r\nconst settingsFields = [\r\n  'searchable',\r\n  'filterable',\r\n  'bulkable',\r\n  'pageSize',\r\n  'mainField',\r\n  'defaultSortBy',\r\n  'defaultSortOrder',\r\n];\r\n\r\nconst getModelSettings = pipe([propOr({}, 'config.settings'), pick(settingsFields)]);\r\n\r\nasync function isValidDefaultSort(schema: any, value: any) {\r\n  const parsedValue = qs.parse(value);\r\n\r\n  const omitNonSortableAttributes = ({ schema, key }: any, { remove }: any) => {\r\n    const sortableAttributes = getSortableAttributes(schema);\r\n    if (!sortableAttributes.includes(key)) {\r\n      remove(key);\r\n    }\r\n  };\r\n\r\n  const sanitizedValue = await traverse.traverseQuerySort(\r\n    omitNonSortableAttributes,\r\n    { schema, getModel: strapi.getModel.bind(strapi) },\r\n    parsedValue\r\n  );\r\n\r\n  // If any of the keys has been removed, the sort attribute is not valid\r\n  return isEqual(parsedValue, sanitizedValue);\r\n}\r\n\r\nconst createDefaultSettings = async (schema: any) => {\r\n  const defaultField = getDefaultMainField(schema);\r\n\r\n  return {\r\n    ...DEFAULT_SETTINGS,\r\n    mainField: defaultField,\r\n    defaultSortBy: defaultField,\r\n    defaultSortOrder: 'ASC',\r\n    ...getModelSettings(schema),\r\n  };\r\n};\r\n\r\nconst syncSettings = async (configuration: any, schema: any) => {\r\n  if (isEmpty(configuration.settings)) return createDefaultSettings(schema);\r\n\r\n  const defaultField = getDefaultMainField(schema);\r\n\r\n  const { mainField = defaultField, defaultSortBy = defaultField } = configuration.settings || {};\r\n\r\n  return {\r\n    ...configuration.settings,\r\n    mainField: isSortable(schema, mainField) ? mainField : defaultField,\r\n    defaultSortBy: (await isValidDefaultSort(schema, defaultSortBy)) ? defaultSortBy : defaultField,\r\n  };\r\n};\r\n\r\nexport { isValidDefaultSort, createDefaultSettings, syncSettings };\r\n","import { yup } from '@strapi/utils';\r\nimport { getService } from '../../utils';\r\nimport { isListable, hasEditableAttribute } from '../../services/utils/configuration/attributes';\r\nimport { isValidDefaultSort } from '../../services/utils/configuration/settings';\r\n\r\n/**\r\n * Creates the validation schema for content-type configurations\r\n */\r\nexport default (schema: any, opts = {}) =>\r\n  yup\r\n    .object()\r\n    .shape({\r\n      settings: createSettingsSchema(schema).default(null).nullable(),\r\n      metadatas: createMetadasSchema(schema).default(null).nullable(),\r\n      layouts: createLayoutsSchema(schema, opts).default(null).nullable(),\r\n      options: yup.object().optional(),\r\n    })\r\n    .noUnknown();\r\n\r\nconst createSettingsSchema = (schema: any) => {\r\n  const validAttributes = Object.keys(schema.attributes).filter((key) => isListable(schema, key));\r\n\r\n  return yup\r\n    .object()\r\n    .shape({\r\n      bulkable: yup.boolean().required(),\r\n      filterable: yup.boolean().required(),\r\n      pageSize: yup.number().integer().min(10).max(100).required(),\r\n      searchable: yup.boolean().required(),\r\n      // should be reset when the type changes\r\n      mainField: yup.string().oneOf(validAttributes.concat('id')).default('id'),\r\n      // should be reset when the type changes\r\n      defaultSortBy: yup\r\n        .string()\r\n        .test('is-valid-sort-attribute', '${path} is not a valid sort attribute', async (value) =>\r\n          isValidDefaultSort(schema, value)\r\n        )\r\n        .default('id'),\r\n      defaultSortOrder: yup.string().oneOf(['ASC', 'DESC']).default('ASC'),\r\n    })\r\n    .noUnknown();\r\n};\r\n\r\nconst createMetadasSchema = (schema: any) => {\r\n  return yup.object().shape(\r\n    Object.keys(schema.attributes).reduce((acc: any, key) => {\r\n      acc[key] = yup\r\n        .object()\r\n        .shape({\r\n          edit: yup\r\n            .object()\r\n            .shape({\r\n              label: yup.string(),\r\n              description: yup.string(),\r\n              placeholder: yup.string(),\r\n              editable: yup.boolean(),\r\n              visible: yup.boolean(),\r\n              mainField: yup.lazy((value) => {\r\n                if (!value) {\r\n                  return yup.string();\r\n                }\r\n\r\n                const targetSchema = getService('content-types').findContentType(\r\n                  schema.attributes[key].targetModel\r\n                );\r\n\r\n                if (!targetSchema) {\r\n                  return yup.string();\r\n                }\r\n\r\n                const validAttributes = Object.keys(targetSchema.attributes).filter((key) =>\r\n                  isListable(targetSchema, key)\r\n                );\r\n\r\n                return yup.string().oneOf(validAttributes.concat('id')).default('id');\r\n              }),\r\n            })\r\n            .noUnknown()\r\n            .required(),\r\n          list: yup\r\n            .object()\r\n            .shape({\r\n              label: yup.string(),\r\n              searchable: yup.boolean(),\r\n              sortable: yup.boolean(),\r\n            })\r\n            .noUnknown()\r\n            .required(),\r\n        })\r\n        .noUnknown();\r\n\r\n      return acc;\r\n    }, {})\r\n  );\r\n};\r\n\r\nconst createArrayTest = ({ allowUndefined = false } = {}) => ({\r\n  name: 'isArray',\r\n  message: '${path} is required and must be an array',\r\n  test: (val: any) => (allowUndefined === true && val === undefined ? true : Array.isArray(val)),\r\n});\r\n\r\nconst createLayoutsSchema = (schema: any, opts = {}) => {\r\n  const validAttributes = Object.keys(schema.attributes).filter((key) => isListable(schema, key));\r\n\r\n  const editAttributes = Object.keys(schema.attributes).filter((key) =>\r\n    hasEditableAttribute(schema, key)\r\n  );\r\n\r\n  return yup.object().shape({\r\n    edit: yup\r\n      .array()\r\n      .of(\r\n        yup.array().of(\r\n          yup\r\n            .object()\r\n            .shape({\r\n              name: yup.string().oneOf(editAttributes).required(),\r\n              size: yup.number().integer().positive().required(),\r\n            })\r\n            .noUnknown()\r\n        )\r\n      )\r\n      .test(createArrayTest(opts)),\r\n    list: yup.array().of(yup.string().oneOf(validAttributes)).test(createArrayTest(opts)),\r\n  });\r\n};\r\n","import _ from 'lodash';\r\nimport { yup, validateYupSchema, errors } from '@strapi/utils';\r\nimport createModelConfigurationSchema from './model-configuration';\r\n\r\nconst { PaginationError, ValidationError } = errors;\r\nconst TYPES = ['singleType', 'collectionType'];\r\n\r\n/**\r\n * Validates type kind\r\n */\r\nconst kindSchema = yup.string().oneOf(TYPES).nullable();\r\n\r\nconst bulkActionInputSchema = yup\r\n  .object({\r\n    documentIds: yup.array().of(yup.strapiID()).min(1).required(),\r\n  })\r\n  .required();\r\n\r\nconst generateUIDInputSchema = yup.object({\r\n  contentTypeUID: yup.string().required(),\r\n  field: yup.string().required(),\r\n  data: yup.object().required(),\r\n});\r\n\r\nconst checkUIDAvailabilityInputSchema = yup.object({\r\n  contentTypeUID: yup.string().required(),\r\n  field: yup.string().required(),\r\n  value: yup\r\n    .string()\r\n    .matches(/^[A-Za-z0-9-_.~]*$/)\r\n    .required(),\r\n});\r\n\r\nconst validateUIDField = (contentTypeUID: any, field: any) => {\r\n  const model = strapi.contentTypes[contentTypeUID];\r\n\r\n  if (!model) {\r\n    throw new ValidationError('ContentType not found');\r\n  }\r\n\r\n  if (\r\n    !_.has(model, ['attributes', field]) ||\r\n    _.get(model, ['attributes', field, 'type']) !== 'uid'\r\n  ) {\r\n    throw new ValidationError(`${field} must be a valid \\`uid\\` attribute`);\r\n  }\r\n};\r\n\r\nconst validatePagination = ({ page, pageSize }: any) => {\r\n  const pageNumber = parseInt(page, 10);\r\n  const pageSizeNumber = parseInt(pageSize, 10);\r\n\r\n  if (Number.isNaN(pageNumber) || pageNumber < 1) {\r\n    throw new PaginationError('invalid pageNumber param');\r\n  }\r\n  if (Number.isNaN(pageSizeNumber) || pageSizeNumber < 1) {\r\n    throw new PaginationError('invalid pageSize param');\r\n  }\r\n};\r\n\r\nconst validateKind = validateYupSchema(kindSchema);\r\nconst validateBulkActionInput = validateYupSchema(bulkActionInputSchema);\r\nconst validateGenerateUIDInput = validateYupSchema(generateUIDInputSchema);\r\nconst validateCheckUIDAvailabilityInput = validateYupSchema(checkUIDAvailabilityInputSchema);\r\n\r\nexport {\r\n  createModelConfigurationSchema,\r\n  validateUIDField,\r\n  validatePagination,\r\n  validateKind,\r\n  validateBulkActionInput,\r\n  validateGenerateUIDInput,\r\n  validateCheckUIDAvailabilityInput,\r\n};\r\n","import { set } from 'lodash/fp';\r\nimport strapiUtils from '@strapi/utils';\r\nimport { ProhibitedCloningField } from '../../../../shared/contracts/collection-types';\r\n\r\nconst { isVisibleAttribute } = strapiUtils.contentTypes;\r\n\r\n/**\r\n * Use an array of strings to represent the path to a field, so we can show breadcrumbs in the admin\r\n * We can't use special characters as delimiters, because the path includes display names\r\n * for dynamic zone components, which can contain any character.\r\n */\r\n\r\nfunction checkRelation(model: any, attributeName: any, path: string[]): ProhibitedCloningField[] {\r\n  // we don't care about createdBy, updatedBy, localizations etc.\r\n  if (!isVisibleAttribute(model, attributeName)) {\r\n    // Return empty array and not null so we can always spread the result\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Only one-to-many and one-to-one (when they're reversed, not one-way) are dangerous,\r\n   * because the other relations don't \"steal\" the relation from the entry we're cloning\r\n   */\r\n  const { relation, inversedBy, mappedBy } = model.attributes[attributeName];\r\n\r\n  if (\r\n    ['oneToOne', 'oneToMany'].includes(relation) &&\r\n    [mappedBy, inversedBy].some((key) => key != null)\r\n  ) {\r\n    return [[[...path, attributeName], 'relation']];\r\n  }\r\n\r\n  return [];\r\n}\r\n\r\nconst getProhibitedCloningFields = (\r\n  uid: any,\r\n  pathPrefix: string[] = []\r\n): ProhibitedCloningField[] => {\r\n  const model = strapi.getModel(uid);\r\n\r\n  const prohibitedFields = Object.keys(model.attributes).reduce<ProhibitedCloningField[]>(\r\n    (acc, attributeName) => {\r\n      const attribute: any = model.attributes[attributeName];\r\n      const attributePath = [...pathPrefix, attributeName];\r\n\r\n      switch (attribute.type) {\r\n        case 'relation':\r\n          return [...acc, ...checkRelation(model, attributeName, pathPrefix)];\r\n        case 'component':\r\n          return [...acc, ...getProhibitedCloningFields(attribute.component, attributePath)];\r\n        case 'dynamiczone':\r\n          return [\r\n            ...acc,\r\n            ...(attribute.components || []).flatMap((componentUID: any) =>\r\n              getProhibitedCloningFields(componentUID, [\r\n                ...attributePath,\r\n                strapi.getModel(componentUID).info.displayName,\r\n              ])\r\n            ),\r\n          ];\r\n        case 'uid':\r\n          return [...acc, [attributePath, 'unique']];\r\n        default:\r\n          if (attribute?.unique) {\r\n            return [...acc, [attributePath, 'unique']];\r\n          }\r\n          return acc;\r\n      }\r\n    },\r\n    []\r\n  );\r\n\r\n  return prohibitedFields;\r\n};\r\n\r\n/**\r\n * Iterates all attributes of the content type, and removes the ones that are not creatable.\r\n *   - If it's a relation, it sets the value to [] or null.\r\n *   - If it's a regular attribute, it sets the value to null.\r\n * When cloning, if you don't set a field it will be copied from the original entry. So we need to\r\n * remove the fields that the user can't create.\r\n */\r\nconst excludeNotCreatableFields =\r\n  (uid: any, permissionChecker: any) =>\r\n  (body: any, path = []): any => {\r\n    const model = strapi.getModel(uid);\r\n    const canCreate = (path: any) => permissionChecker.can.create(null, path);\r\n\r\n    return Object.keys(model.attributes).reduce((body, attributeName) => {\r\n      const attribute = model.attributes[attributeName];\r\n      const attributePath = [...path, attributeName].join('.');\r\n\r\n      // Ignore the attribute if it's not visible\r\n      if (!isVisibleAttribute(model, attributeName)) {\r\n        return body;\r\n      }\r\n\r\n      switch (attribute.type) {\r\n        // Relation should be empty if the user can't create it\r\n        case 'relation': {\r\n          if (canCreate(attributePath)) return body;\r\n          return set(attributePath, { set: [] }, body);\r\n        }\r\n        // Go deeper into the component\r\n        case 'component': {\r\n          return excludeNotCreatableFields(attribute.component, permissionChecker)(body, [\r\n            ...path,\r\n            attributeName,\r\n          ] as any);\r\n        }\r\n        // Attribute should be null if the user can't create it\r\n        default: {\r\n          if (canCreate(attributePath)) return body;\r\n          return set(attributePath, null, body);\r\n        }\r\n      }\r\n    }, body);\r\n  };\r\n\r\nexport { getProhibitedCloningFields, excludeNotCreatableFields };\r\n","import { errors, yup, validateYupSchema, contentTypes } from '@strapi/utils';\r\nimport type { UID } from '@strapi/types';\r\n\r\ninterface Options {\r\n  allowMultipleLocales?: boolean;\r\n}\r\n\r\nconst singleLocaleSchema = yup.string().nullable();\r\n\r\nconst multipleLocaleSchema = yup.lazy((value) =>\r\n  Array.isArray(value) ? yup.array().of(singleLocaleSchema.required()) : singleLocaleSchema\r\n);\r\n\r\nconst statusSchema = yup.mixed().oneOf(['draft', 'published'], 'Invalid status');\r\n\r\n/**\r\n * From a request or query object, validates and returns the locale and status of the document.\r\n * If the status is not provided and Draft & Publish is disabled, it defaults to 'published'.\r\n */\r\nexport const getDocumentLocaleAndStatus = async (\r\n  request: any,\r\n  model: UID.Schema,\r\n  opts: Options = { allowMultipleLocales: false }\r\n) => {\r\n  const { allowMultipleLocales } = opts;\r\n  const { locale, status: providedStatus, ...rest } = request || {};\r\n\r\n  const defaultStatus = contentTypes.hasDraftAndPublish(strapi.getModel(model))\r\n    ? undefined\r\n    : 'published';\r\n  const status = providedStatus !== undefined ? providedStatus : defaultStatus;\r\n\r\n  const schema = yup.object().shape({\r\n    locale: allowMultipleLocales ? multipleLocaleSchema : singleLocaleSchema,\r\n    status: statusSchema,\r\n  });\r\n\r\n  try {\r\n    await validateYupSchema(schema, { strict: true, abortEarly: false })(request);\r\n\r\n    return { locale, status, ...rest };\r\n  } catch (error: any) {\r\n    throw new errors.ValidationError(`Validation error: ${error.message}`);\r\n  }\r\n};\r\n","import { UID } from '@strapi/types';\r\nimport { async } from '@strapi/utils';\r\n\r\nimport { getService } from '../../utils';\r\n\r\nimport { DocumentVersion, GetMetadataOptions } from '../../services/document-metadata';\r\n\r\nimport type {\r\n  AvailableLocaleDocument,\r\n  AvailableStatusDocument,\r\n} from '../../../../shared/contracts/collection-types';\r\n\r\n/**\r\n * Format a document with metadata. Making sure the metadata response is\r\n * correctly sanitized for the current user\r\n */\r\nexport const formatDocumentWithMetadata = async (\r\n  permissionChecker: any,\r\n  uid: UID.ContentType,\r\n  document: DocumentVersion,\r\n  opts: GetMetadataOptions = {}\r\n) => {\r\n  const documentMetadata = getService('document-metadata');\r\n\r\n  const serviceOutput = await documentMetadata.formatDocumentWithMetadata(uid, document, opts);\r\n\r\n  let {\r\n    meta: { availableLocales, availableStatus },\r\n  } = serviceOutput;\r\n\r\n  const metadataSanitizer = permissionChecker.sanitizeOutput;\r\n\r\n  availableLocales = await async.map(\r\n    availableLocales,\r\n    async (localeDocument: AvailableLocaleDocument) => metadataSanitizer(localeDocument)\r\n  );\r\n\r\n  availableStatus = await async.map(\r\n    availableStatus,\r\n    async (statusDocument: AvailableStatusDocument) => metadataSanitizer(statusDocument)\r\n  );\r\n\r\n  return {\r\n    ...serviceOutput,\r\n    meta: {\r\n      availableLocales,\r\n      availableStatus,\r\n    },\r\n  };\r\n};\r\n","import { isNil } from 'lodash/fp';\r\n\r\nimport { setCreatorFields, async, errors } from '@strapi/utils';\r\nimport type { Modules, UID } from '@strapi/types';\r\n\r\nimport { getService } from '../utils';\r\nimport { validateBulkActionInput } from './validation';\r\nimport { getProhibitedCloningFields, excludeNotCreatableFields } from './utils/clone';\r\nimport { getDocumentLocaleAndStatus } from './validation/dimensions';\r\nimport { formatDocumentWithMetadata } from './utils/metadata';\r\n\r\ntype Options = Modules.Documents.Params.Pick<UID.ContentType, 'populate:object'>;\r\n\r\n/**\r\n * Create a new document.\r\n *\r\n * @param ctx - Koa context\r\n * @param opts - Options\r\n * @param opts.populate - Populate options of the returned document.\r\n *                        By default documentManager will populate all relations.\r\n */\r\nconst createDocument = async (ctx: any, opts?: Options) => {\r\n  const { userAbility, user } = ctx.state;\r\n  const { model } = ctx.params;\r\n  const { body } = ctx.request;\r\n\r\n  const documentManager = getService('document-manager');\r\n  const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n  if (permissionChecker.cannot.create()) {\r\n    throw new errors.ForbiddenError();\r\n  }\r\n\r\n  const pickPermittedFields = permissionChecker.sanitizeCreateInput;\r\n  const setCreator = setCreatorFields({ user });\r\n  const sanitizeFn = async.pipe(pickPermittedFields, setCreator as any);\r\n  const sanitizedBody = await sanitizeFn(body);\r\n\r\n  const { locale, status } = await getDocumentLocaleAndStatus(body, model);\r\n\r\n  return documentManager.create(model, {\r\n    data: sanitizedBody as any,\r\n    locale,\r\n    status,\r\n    populate: opts?.populate,\r\n  });\r\n\r\n  // TODO: Revert the creation if create permission conditions are not met\r\n  // if (permissionChecker.cannot.create(document)) {\r\n  //   throw new errors.ForbiddenError();\r\n  // }\r\n};\r\n\r\n/**\r\n * Update a document version.\r\n * - If the document version exists, it will be updated.\r\n * - If the document version does not exist, a new document locale will be created.\r\n *   By default documentManager will populate all relations.\r\n *\r\n * @param ctx - Koa context\r\n * @param opts - Options\r\n * @param opts.populate - Populate options of the returned document\r\n */\r\nconst updateDocument = async (ctx: any, opts?: Options) => {\r\n  const { userAbility, user } = ctx.state;\r\n  const { id, model } = ctx.params;\r\n  const { body } = ctx.request;\r\n\r\n  const documentManager = getService('document-manager');\r\n  const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n  if (permissionChecker.cannot.update()) {\r\n    throw new errors.ForbiddenError();\r\n  }\r\n\r\n  // Populate necessary fields to check permissions\r\n  const permissionQuery = await permissionChecker.sanitizedQuery.update(ctx.query);\r\n  const populate = await getService('populate-builder')(model)\r\n    .populateFromQuery(permissionQuery)\r\n    .build();\r\n\r\n  const { locale } = await getDocumentLocaleAndStatus(body, model);\r\n\r\n  // Load document version to update\r\n  const [documentVersion, documentExists] = await Promise.all([\r\n    documentManager.findOne(id, model, { populate, locale, status: 'draft' }),\r\n    documentManager.exists(model, id),\r\n  ]);\r\n\r\n  if (!documentExists) {\r\n    throw new errors.NotFoundError();\r\n  }\r\n\r\n  // If version is not found, but document exists,\r\n  // the intent is to create a new document locale\r\n  if (documentVersion) {\r\n    if (permissionChecker.cannot.update(documentVersion)) {\r\n      throw new errors.ForbiddenError();\r\n    }\r\n  } else if (permissionChecker.cannot.create()) {\r\n    throw new errors.ForbiddenError();\r\n  }\r\n\r\n  const pickPermittedFields = documentVersion\r\n    ? permissionChecker.sanitizeUpdateInput(documentVersion)\r\n    : permissionChecker.sanitizeCreateInput;\r\n  const setCreator = documentVersion\r\n    ? setCreatorFields({ user, isEdition: true })\r\n    : setCreatorFields({ user });\r\n  const sanitizeFn = async.pipe(pickPermittedFields, setCreator as any);\r\n  const sanitizedBody = await sanitizeFn(body);\r\n\r\n  return documentManager.update(documentVersion?.documentId || id, model, {\r\n    data: sanitizedBody as any,\r\n    populate: opts?.populate,\r\n    locale,\r\n  });\r\n};\r\n\r\nexport default {\r\n  async find(ctx: any) {\r\n    const { userAbility } = ctx.state;\r\n    const { model } = ctx.params;\r\n    const { query } = ctx.request;\r\n\r\n    const documentMetadata = getService('document-metadata');\r\n    const documentManager = getService('document-manager');\r\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n    if (permissionChecker.cannot.read()) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    const permissionQuery = await permissionChecker.sanitizedQuery.read(query);\r\n\r\n    const populate = await getService('populate-builder')(model)\r\n      .populateFromQuery(permissionQuery)\r\n      .populateDeep(1)\r\n      .countRelations({ toOne: false, toMany: true })\r\n      .build();\r\n\r\n    const { locale, status } = await getDocumentLocaleAndStatus(query, model);\r\n\r\n    const { results: documents, pagination } = await documentManager.findPage(\r\n      { ...permissionQuery, populate, locale, status },\r\n      model\r\n    );\r\n\r\n    // TODO: Skip this part if not necessary (if D&P disabled or columns not displayed in the view)\r\n    const documentsAvailableStatus = await documentMetadata.getManyAvailableStatus(\r\n      model,\r\n      documents\r\n    );\r\n\r\n    const setStatus = (document: any) => {\r\n      // Available status of document\r\n      const availableStatuses = documentsAvailableStatus.filter(\r\n        (d: any) => d.documentId === document.documentId\r\n      );\r\n      // Compute document version status\r\n      document.status = documentMetadata.getStatus(document, availableStatuses);\r\n      return document;\r\n    };\r\n\r\n    const results = await async.map(\r\n      documents,\r\n      async.pipe(permissionChecker.sanitizeOutput, setStatus)\r\n    );\r\n\r\n    ctx.body = {\r\n      results,\r\n      pagination,\r\n    };\r\n  },\r\n\r\n  async findOne(ctx: any) {\r\n    const { userAbility } = ctx.state;\r\n    const { model, id } = ctx.params;\r\n\r\n    const documentManager = getService('document-manager');\r\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n    if (permissionChecker.cannot.read()) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    const permissionQuery = await permissionChecker.sanitizedQuery.read(ctx.query);\r\n    const populate = await getService('populate-builder')(model)\r\n      .populateFromQuery(permissionQuery)\r\n      .populateDeep(Infinity)\r\n      .countRelations()\r\n      .build();\r\n\r\n    const { locale, status } = await getDocumentLocaleAndStatus(ctx.query, model);\r\n\r\n    const version = await documentManager.findOne(id, model, {\r\n      populate,\r\n      locale,\r\n      status,\r\n    });\r\n\r\n    if (!version) {\r\n      // Check if document exists\r\n      const exists = await documentManager.exists(model, id);\r\n      if (!exists) {\r\n        return ctx.notFound();\r\n      }\r\n\r\n      // If the requested locale doesn't exist, return an empty response\r\n      const { meta } = await formatDocumentWithMetadata(\r\n        permissionChecker,\r\n        model,\r\n        // @ts-expect-error TODO: fix\r\n        { documentId: id, locale, publishedAt: null },\r\n        { availableLocales: true, availableStatus: false }\r\n      );\r\n\r\n      ctx.body = { data: {}, meta };\r\n\r\n      return;\r\n    }\r\n\r\n    // if the user has condition that needs populated content, it's not applied because entity don't have relations populated\r\n    if (permissionChecker.cannot.read(version)) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    // TODO: Count populated relations by permissions\r\n    const sanitizedDocument = await permissionChecker.sanitizeOutput(version);\r\n    ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedDocument);\r\n  },\r\n\r\n  async create(ctx: any) {\r\n    const { userAbility } = ctx.state;\r\n    const { model } = ctx.params;\r\n\r\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n    const [totalEntries, document] = await Promise.all([\r\n      strapi.db.query(model).count(),\r\n      createDocument(ctx),\r\n    ]);\r\n\r\n    const sanitizedDocument = await permissionChecker.sanitizeOutput(document);\r\n    ctx.status = 201;\r\n    ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedDocument, {\r\n      // Empty metadata as it's not relevant for a new document\r\n      availableLocales: false,\r\n      availableStatus: false,\r\n    });\r\n\r\n    if (totalEntries === 0) {\r\n      strapi.telemetry.send('didCreateFirstContentTypeEntry', {\r\n        eventProperties: { model },\r\n      });\r\n    }\r\n  },\r\n\r\n  async update(ctx: any) {\r\n    const { userAbility } = ctx.state;\r\n    const { model } = ctx.params;\r\n\r\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n    const updatedVersion = await updateDocument(ctx);\r\n\r\n    const sanitizedVersion = await permissionChecker.sanitizeOutput(updatedVersion);\r\n    ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedVersion);\r\n  },\r\n\r\n  async clone(ctx: any) {\r\n    const { userAbility, user } = ctx.state;\r\n    const { model, sourceId: id } = ctx.params;\r\n    const { body } = ctx.request;\r\n\r\n    const documentManager = getService('document-manager');\r\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n    if (permissionChecker.cannot.create()) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    const permissionQuery = await permissionChecker.sanitizedQuery.create(ctx.query);\r\n    const populate = await getService('populate-builder')(model)\r\n      .populateFromQuery(permissionQuery)\r\n      .build();\r\n\r\n    const { locale } = await getDocumentLocaleAndStatus(body, model);\r\n    const document = await documentManager.findOne(id, model, {\r\n      populate,\r\n      locale,\r\n      status: 'draft',\r\n    });\r\n\r\n    if (!document) {\r\n      return ctx.notFound();\r\n    }\r\n\r\n    const pickPermittedFields = permissionChecker.sanitizeCreateInput;\r\n    const setCreator = setCreatorFields({ user });\r\n    const excludeNotCreatable = excludeNotCreatableFields(model, permissionChecker);\r\n    const sanitizeFn = async.pipe(pickPermittedFields, setCreator as any, excludeNotCreatable);\r\n    const sanitizedBody = await sanitizeFn(body);\r\n\r\n    const clonedDocument = await documentManager.clone(document.documentId, sanitizedBody, model);\r\n\r\n    const sanitizedDocument = await permissionChecker.sanitizeOutput(clonedDocument);\r\n    ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedDocument, {\r\n      // Empty metadata as it's not relevant for a new document\r\n      availableLocales: false,\r\n      availableStatus: false,\r\n    });\r\n  },\r\n\r\n  async autoClone(ctx: any) {\r\n    const { model } = ctx.params;\r\n\r\n    // Check if the model has fields that prevent auto cloning\r\n    const prohibitedFields = getProhibitedCloningFields(model);\r\n\r\n    if (prohibitedFields.length > 0) {\r\n      return ctx.badRequest(\r\n        'Entity could not be cloned as it has unique and/or relational fields. ' +\r\n          'Please edit those fields manually and save to complete the cloning.',\r\n        {\r\n          prohibitedFields,\r\n        }\r\n      );\r\n    }\r\n\r\n    await this.clone(ctx);\r\n  },\r\n\r\n  async delete(ctx: any) {\r\n    const { userAbility } = ctx.state;\r\n    const { id, model } = ctx.params;\r\n\r\n    const documentManager = getService('document-manager');\r\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n    if (permissionChecker.cannot.delete()) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    const permissionQuery = await permissionChecker.sanitizedQuery.delete(ctx.query);\r\n    const populate = await getService('populate-builder')(model)\r\n      .populateFromQuery(permissionQuery)\r\n      .build();\r\n\r\n    const { locale } = await getDocumentLocaleAndStatus(ctx.query, model);\r\n\r\n    // Find locales to delete\r\n    const documentLocales = await documentManager.findLocales(id, model, { populate, locale });\r\n\r\n    if (documentLocales.length === 0) {\r\n      return ctx.notFound();\r\n    }\r\n\r\n    for (const document of documentLocales) {\r\n      if (permissionChecker.cannot.delete(document)) {\r\n        return ctx.forbidden();\r\n      }\r\n    }\r\n\r\n    const result = await documentManager.delete(id, model, { locale });\r\n\r\n    ctx.body = await permissionChecker.sanitizeOutput(result);\r\n  },\r\n\r\n  /**\r\n   * Publish a document version.\r\n   * Supports creating/saving a document and publishing it in one request.\r\n   */\r\n  async publish(ctx: any) {\r\n    const { userAbility } = ctx.state;\r\n    // If id does not exist, the document has to be created\r\n    const { id, model } = ctx.params;\r\n    const { body } = ctx.request;\r\n\r\n    const documentManager = getService('document-manager');\r\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n    if (permissionChecker.cannot.publish()) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    const publishedDocument = await strapi.db.transaction(async () => {\r\n      // Create or update document\r\n      const permissionQuery = await permissionChecker.sanitizedQuery.publish(ctx.query);\r\n      const populate = await getService('populate-builder')(model)\r\n        .populateFromQuery(permissionQuery)\r\n        .populateDeep(Infinity)\r\n        .countRelations()\r\n        .build();\r\n\r\n      let document: any;\r\n\r\n      const { locale } = await getDocumentLocaleAndStatus(body, model);\r\n\r\n      /**\r\n       * Publish can be called on two scenarios:\r\n       * 1. Create a new document and publish it in one request\r\n       * 2. Update an existing document and publish it in one request\r\n       *\r\n       * Based on user permissions:\r\n       * 1. User cannot create a document, but can publish\r\n       *    Action will be forbidden as user cannot create a document\r\n       * 2. User can update and publish a document\r\n       *    Action will be allowed, but document will not be updated, only published with the latest draft\r\n       */\r\n      const isCreate = isNil(id);\r\n      if (isCreate) {\r\n        if (permissionChecker.cannot.create()) {\r\n          throw new errors.ForbiddenError();\r\n        }\r\n\r\n        document = await createDocument(ctx, { populate });\r\n      }\r\n\r\n      const isUpdate = !isCreate;\r\n      if (isUpdate) {\r\n        // check if the document exists\r\n        const documentExists = documentManager.exists(model, id)!;\r\n\r\n        if (!documentExists) {\r\n          throw new errors.NotFoundError('Document not found');\r\n        }\r\n\r\n        // check the document version\r\n        document = await documentManager.findOne(id!, model, { populate, locale });\r\n\r\n        if (!document) {\r\n          // update and publish the new version\r\n          if (\r\n            permissionChecker.cannot.create({ locale }) ||\r\n            permissionChecker.cannot.publish({ locale })\r\n          ) {\r\n            throw new errors.ForbiddenError();\r\n          }\r\n          document = await updateDocument(ctx);\r\n        } else if (permissionChecker.can.update(document)) {\r\n          await updateDocument(ctx);\r\n        }\r\n      }\r\n\r\n      if (permissionChecker.cannot.publish(document)) {\r\n        throw new errors.ForbiddenError();\r\n      }\r\n\r\n      const publishResult = await documentManager.publish(document.documentId, model, {\r\n        locale,\r\n        // TODO: Allow setting creator fields on publish\r\n        // data: setCreatorFields({ user, isEdition: true })({}),\r\n      });\r\n\r\n      if (!publishResult || publishResult.length === 0) {\r\n        throw new errors.NotFoundError('Document not found or already published.');\r\n      }\r\n\r\n      return publishResult[0];\r\n    });\r\n\r\n    const sanitizedDocument = await permissionChecker.sanitizeOutput(publishedDocument);\r\n    ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedDocument);\r\n  },\r\n\r\n  async bulkPublish(ctx: any) {\r\n    const { userAbility } = ctx.state;\r\n    const { model } = ctx.params;\r\n    const { body } = ctx.request;\r\n    const { documentIds } = body;\r\n\r\n    await validateBulkActionInput(body);\r\n\r\n    const documentManager = getService('document-manager');\r\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n    if (permissionChecker.cannot.publish()) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    const permissionQuery = await permissionChecker.sanitizedQuery.publish(ctx.query);\r\n    const populate = await getService('populate-builder')(model)\r\n      .populateFromQuery(permissionQuery)\r\n      .populateDeep(Infinity)\r\n      .countRelations()\r\n      .build();\r\n\r\n    const { locale } = await getDocumentLocaleAndStatus(body, model, {\r\n      allowMultipleLocales: true,\r\n    });\r\n\r\n    const entityPromises = documentIds.map((documentId: any) =>\r\n      documentManager.findLocales(documentId, model, { populate, locale, isPublished: false })\r\n    );\r\n    const entities = (await Promise.all(entityPromises)).flat();\r\n\r\n    for (const entity of entities) {\r\n      if (!entity) {\r\n        return ctx.notFound();\r\n      }\r\n\r\n      if (permissionChecker.cannot.publish(entity)) {\r\n        return ctx.forbidden();\r\n      }\r\n    }\r\n\r\n    const count = await documentManager.publishMany(model, documentIds, locale);\r\n    ctx.body = { count };\r\n  },\r\n\r\n  async bulkUnpublish(ctx: any) {\r\n    const { userAbility } = ctx.state;\r\n    const { model } = ctx.params;\r\n    const { body } = ctx.request;\r\n    const { documentIds } = body;\r\n\r\n    await validateBulkActionInput(body);\r\n\r\n    const documentManager = getService('document-manager');\r\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n    if (permissionChecker.cannot.unpublish()) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    const { locale } = await getDocumentLocaleAndStatus(body, model, {\r\n      allowMultipleLocales: true,\r\n    });\r\n\r\n    const entityPromises = documentIds.map((documentId: any) =>\r\n      documentManager.findLocales(documentId, model, { locale, isPublished: true })\r\n    );\r\n    const entities = (await Promise.all(entityPromises)).flat();\r\n\r\n    for (const entity of entities) {\r\n      if (!entity) {\r\n        return ctx.notFound();\r\n      }\r\n\r\n      if (permissionChecker.cannot.publish(entity)) {\r\n        return ctx.forbidden();\r\n      }\r\n    }\r\n\r\n    const entitiesIds = entities.map((document) => document.documentId);\r\n\r\n    const { count } = await documentManager.unpublishMany(entitiesIds, model, { locale });\r\n\r\n    ctx.body = { count };\r\n  },\r\n\r\n  async unpublish(ctx: any) {\r\n    const { userAbility } = ctx.state;\r\n    const { id, model } = ctx.params;\r\n    const {\r\n      body: { discardDraft, ...body },\r\n    } = ctx.request;\r\n\r\n    const documentManager = getService('document-manager');\r\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n    if (permissionChecker.cannot.unpublish()) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    if (discardDraft && permissionChecker.cannot.discard()) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    const permissionQuery = await permissionChecker.sanitizedQuery.unpublish(ctx.query);\r\n\r\n    const populate = await getService('populate-builder')(model)\r\n      .populateFromQuery(permissionQuery)\r\n      .build();\r\n\r\n    // TODO allow multiple locales for bulk locale unpublish\r\n    const { locale } = await getDocumentLocaleAndStatus(body, model);\r\n    const document = await documentManager.findOne(id, model, {\r\n      populate,\r\n      locale,\r\n      status: 'published',\r\n    });\r\n\r\n    if (!document) {\r\n      throw new errors.NotFoundError();\r\n    }\r\n\r\n    if (permissionChecker.cannot.unpublish(document)) {\r\n      throw new errors.ForbiddenError();\r\n    }\r\n\r\n    if (discardDraft && permissionChecker.cannot.discard(document)) {\r\n      throw new errors.ForbiddenError();\r\n    }\r\n\r\n    await strapi.db.transaction(async () => {\r\n      if (discardDraft) {\r\n        await documentManager.discardDraft(document.documentId, model, { locale });\r\n      }\r\n\r\n      ctx.body = await async.pipe(\r\n        (document) => documentManager.unpublish(document.documentId, model, { locale }),\r\n        permissionChecker.sanitizeOutput,\r\n        (document) => formatDocumentWithMetadata(permissionChecker, model, document)\r\n      )(document);\r\n    });\r\n  },\r\n\r\n  async discard(ctx: any) {\r\n    const { userAbility } = ctx.state;\r\n    const { id, model } = ctx.params;\r\n    const { body } = ctx.request;\r\n\r\n    const documentManager = getService('document-manager');\r\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n    if (permissionChecker.cannot.discard()) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    const permissionQuery = await permissionChecker.sanitizedQuery.discard(ctx.query);\r\n    const populate = await getService('populate-builder')(model)\r\n      .populateFromQuery(permissionQuery)\r\n      .build();\r\n\r\n    const { locale } = await getDocumentLocaleAndStatus(body, model);\r\n    const document = await documentManager.findOne(id, model, {\r\n      populate,\r\n      locale,\r\n      status: 'published',\r\n    });\r\n\r\n    // Can not discard a document that is not published\r\n    if (!document) {\r\n      return ctx.notFound();\r\n    }\r\n\r\n    if (permissionChecker.cannot.discard(document)) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    ctx.body = await async.pipe(\r\n      (document) => documentManager.discardDraft(document.documentId, model, { locale }),\r\n      permissionChecker.sanitizeOutput,\r\n      (document) => formatDocumentWithMetadata(permissionChecker, model, document)\r\n    )(document);\r\n  },\r\n\r\n  async bulkDelete(ctx: any) {\r\n    const { userAbility } = ctx.state;\r\n    const { model } = ctx.params;\r\n    const { query, body } = ctx.request;\r\n    const { documentIds } = body;\r\n\r\n    await validateBulkActionInput(body);\r\n\r\n    const documentManager = getService('document-manager');\r\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n    if (permissionChecker.cannot.delete()) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    const permissionQuery = await permissionChecker.sanitizedQuery.delete(query);\r\n    const populate = await getService('populate-builder')(model)\r\n      .populateFromQuery(permissionQuery)\r\n      .build();\r\n\r\n    const { locale } = await getDocumentLocaleAndStatus(body, model);\r\n\r\n    const documentLocales = await documentManager.findLocales(documentIds, model, {\r\n      populate,\r\n      locale,\r\n    });\r\n\r\n    if (documentLocales.length === 0) {\r\n      return ctx.notFound();\r\n    }\r\n\r\n    for (const document of documentLocales) {\r\n      if (permissionChecker.cannot.delete(document)) {\r\n        return ctx.forbidden();\r\n      }\r\n    }\r\n\r\n    // We filter out documentsIds that maybe doesn't exist in a specific locale\r\n    const localeDocumentsIds = documentLocales.map((document) => document.documentId);\r\n\r\n    const { count } = await documentManager.deleteMany(localeDocumentsIds, model, { locale });\r\n\r\n    ctx.body = { count };\r\n  },\r\n\r\n  async countDraftRelations(ctx: any) {\r\n    const { userAbility } = ctx.state;\r\n    const { model, id } = ctx.params;\r\n\r\n    const documentManager = getService('document-manager');\r\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n    if (permissionChecker.cannot.read()) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    const permissionQuery = await permissionChecker.sanitizedQuery.read(ctx.query);\r\n    const populate = await getService('populate-builder')(model)\r\n      .populateFromQuery(permissionQuery)\r\n      .build();\r\n\r\n    const { locale, status } = await getDocumentLocaleAndStatus(ctx.query, model);\r\n    const entity = await documentManager.findOne(id, model, { populate, locale, status });\r\n\r\n    if (!entity) {\r\n      return ctx.notFound();\r\n    }\r\n\r\n    if (permissionChecker.cannot.read(entity)) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    const number = await documentManager.countDraftRelations(id, model, locale);\r\n\r\n    return {\r\n      data: number,\r\n    };\r\n  },\r\n\r\n  async countManyEntriesDraftRelations(ctx: any) {\r\n    const { userAbility } = ctx.state;\r\n    const ids = ctx.request.query.documentIds as string[];\r\n    const locale = ctx.request.query.locale as string[];\r\n    const { model } = ctx.params;\r\n\r\n    const documentManager = getService('document-manager');\r\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n    if (permissionChecker.cannot.read()) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    const documents = await documentManager.findMany(\r\n      {\r\n        filters: {\r\n          documentId: ids,\r\n        },\r\n        locale,\r\n      },\r\n      model\r\n    );\r\n\r\n    if (!documents) {\r\n      return ctx.notFound();\r\n    }\r\n\r\n    const number = await documentManager.countManyEntriesDraftRelations(ids, model, locale);\r\n\r\n    return {\r\n      data: number,\r\n    };\r\n  },\r\n};\r\n","import { getService } from '../utils';\r\nimport { createModelConfigurationSchema } from './validation';\r\n\r\nexport default {\r\n  findComponents(ctx: any) {\r\n    const components = getService('components').findAllComponents();\r\n    const { toDto } = getService('data-mapper');\r\n\r\n    ctx.body = { data: components.map(toDto) };\r\n  },\r\n\r\n  async findComponentConfiguration(ctx: any) {\r\n    const { uid } = ctx.params;\r\n\r\n    const componentService = getService('components');\r\n\r\n    const component = componentService.findComponent(uid);\r\n\r\n    if (!component) {\r\n      return ctx.notFound('component.notFound');\r\n    }\r\n\r\n    const configuration = await componentService.findConfiguration(component);\r\n    const componentsConfigurations = await componentService.findComponentsConfigurations(component);\r\n\r\n    ctx.body = {\r\n      data: {\r\n        component: configuration,\r\n        components: componentsConfigurations,\r\n      },\r\n    };\r\n  },\r\n\r\n  async updateComponentConfiguration(ctx: any) {\r\n    const { uid } = ctx.params;\r\n    const { body } = ctx.request;\r\n\r\n    const componentService = getService('components');\r\n\r\n    const component = componentService.findComponent(uid);\r\n\r\n    if (!component) {\r\n      return ctx.notFound('component.notFound');\r\n    }\r\n\r\n    let input;\r\n    try {\r\n      input = await createModelConfigurationSchema(component).validate(body, {\r\n        abortEarly: false,\r\n        stripUnknown: true,\r\n        strict: true,\r\n      });\r\n    } catch (error: any) {\r\n      return ctx.badRequest(null, {\r\n        name: 'validationError',\r\n        errors: error.errors,\r\n      });\r\n    }\r\n\r\n    const newConfiguration = await componentService.updateConfiguration(component, input);\r\n\r\n    ctx.body = { data: newConfiguration };\r\n  },\r\n};\r\n","import { has, assoc, mapValues, prop } from 'lodash/fp';\r\nimport { getService } from '../utils';\r\nimport { createModelConfigurationSchema, validateKind } from './validation';\r\n\r\nconst hasEditMainField = has('edit.mainField');\r\nconst getEditMainField = prop('edit.mainField');\r\nconst assocListMainField = assoc('list.mainField');\r\n\r\nconst assocMainField = (metadata: any) =>\r\n  hasEditMainField(metadata) ? assocListMainField(getEditMainField(metadata), metadata) : metadata;\r\n\r\nexport default {\r\n  async findContentTypes(ctx: any) {\r\n    const { kind } = ctx.query;\r\n\r\n    try {\r\n      await validateKind(kind);\r\n    } catch (error) {\r\n      return ctx.send({ error }, 400);\r\n    }\r\n\r\n    const contentTypes = getService('content-types').findContentTypesByKind(kind);\r\n    const { toDto } = getService('data-mapper');\r\n\r\n    ctx.body = { data: contentTypes.map(toDto) };\r\n  },\r\n\r\n  async findContentTypesSettings(ctx: any) {\r\n    const { findAllContentTypes, findConfiguration } = getService('content-types');\r\n\r\n    const contentTypes = await findAllContentTypes();\r\n    const configurations = await Promise.all(\r\n      contentTypes.map(async (contentType: any) => {\r\n        const { uid, settings } = await findConfiguration(contentType);\r\n        return { uid, settings };\r\n      })\r\n    );\r\n\r\n    ctx.body = {\r\n      data: configurations,\r\n    };\r\n  },\r\n\r\n  async findContentTypeConfiguration(ctx: any) {\r\n    const { uid } = ctx.params;\r\n\r\n    const contentTypeService = getService('content-types');\r\n\r\n    const contentType = await contentTypeService.findContentType(uid);\r\n\r\n    if (!contentType) {\r\n      return ctx.notFound('contentType.notFound');\r\n    }\r\n\r\n    const configuration = await contentTypeService.findConfiguration(contentType);\r\n\r\n    const confWithUpdatedMetadata = {\r\n      ...configuration,\r\n      metadatas: mapValues(assocMainField, configuration.metadatas),\r\n    };\r\n\r\n    const components = await contentTypeService.findComponentsConfigurations(contentType);\r\n\r\n    ctx.body = {\r\n      data: {\r\n        contentType: confWithUpdatedMetadata,\r\n        components,\r\n      },\r\n    };\r\n  },\r\n\r\n  async updateContentTypeConfiguration(ctx: any) {\r\n    const { userAbility } = ctx.state;\r\n    const { uid } = ctx.params;\r\n    const { body } = ctx.request;\r\n\r\n    const contentTypeService = getService('content-types');\r\n    const metricsService = getService('metrics');\r\n\r\n    const contentType = await contentTypeService.findContentType(uid);\r\n\r\n    if (!contentType) {\r\n      return ctx.notFound('contentType.notFound');\r\n    }\r\n\r\n    if (!getService('permission').canConfigureContentType({ userAbility, contentType })) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    let input;\r\n    try {\r\n      input = await createModelConfigurationSchema(contentType).validate(body, {\r\n        abortEarly: false,\r\n        stripUnknown: true,\r\n        strict: true,\r\n      });\r\n    } catch (error: any) {\r\n      return ctx.badRequest(null, {\r\n        name: 'validationError',\r\n        errors: error.errors,\r\n      });\r\n    }\r\n\r\n    const newConfiguration = await contentTypeService.updateConfiguration(contentType, input);\r\n\r\n    await metricsService.sendDidConfigureListView(contentType, newConfiguration);\r\n\r\n    const confWithUpdatedMetadata = {\r\n      ...newConfiguration,\r\n      metadatas: mapValues(assocMainField, newConfiguration.metadatas),\r\n    };\r\n\r\n    const components = await contentTypeService.findComponentsConfigurations(contentType);\r\n\r\n    ctx.body = {\r\n      data: {\r\n        contentType: confWithUpdatedMetadata,\r\n        components,\r\n      },\r\n    };\r\n  },\r\n};\r\n","import { getService } from '../utils';\r\n\r\nexport default {\r\n  getInitData(ctx: any) {\r\n    const { toDto } = getService('data-mapper');\r\n    const { findAllComponents } = getService('components');\r\n    const { getAllFieldSizes } = getService('field-sizes');\r\n    const { findAllContentTypes } = getService('content-types');\r\n\r\n    ctx.body = {\r\n      data: {\r\n        fieldSizes: getAllFieldSizes(),\r\n        components: findAllComponents().map(toDto),\r\n        contentTypes: findAllContentTypes().map(toDto),\r\n      },\r\n    };\r\n  },\r\n};\r\n","import { yup, validateYupSchema } from '@strapi/utils';\r\n\r\nconst validateFindAvailableSchema = yup\r\n  .object()\r\n  .shape({\r\n    component: yup.string(),\r\n    id: yup.strapiID(),\r\n    _q: yup.string(),\r\n    idsToOmit: yup.array().of(yup.strapiID()),\r\n    idsToInclude: yup.array().of(yup.strapiID()),\r\n    page: yup.number().integer().min(1),\r\n    pageSize: yup.number().integer().min(1).max(100),\r\n    locale: yup.string().nullable(),\r\n    status: yup.string().oneOf(['published', 'draft']).nullable(),\r\n  })\r\n  .required();\r\n\r\nconst validateFindExistingSchema = yup\r\n  .object()\r\n  .shape({\r\n    page: yup.number().integer().min(1),\r\n    pageSize: yup.number().integer().min(1).max(100),\r\n    locale: yup.string().nullable(),\r\n    status: yup.string().oneOf(['published', 'draft']).nullable(),\r\n  })\r\n  .required();\r\n\r\nconst validateFindAvailable = validateYupSchema(validateFindAvailableSchema, { strict: false });\r\nconst validateFindExisting = validateYupSchema(validateFindExistingSchema, { strict: false });\r\n\r\nexport { validateFindAvailable, validateFindExisting };\r\n","import { prop, uniq, uniqBy, concat, flow, isEmpty } from 'lodash/fp';\r\n\r\nimport { isOperatorOfType, contentTypes, relations, errors } from '@strapi/utils';\r\nimport type { Data, Modules, UID } from '@strapi/types';\r\n\r\nimport { getService } from '../utils';\r\nimport { validateFindAvailable, validateFindExisting } from './validation/relations';\r\nimport { isListable } from '../services/utils/configuration/attributes';\r\n\r\nconst { PUBLISHED_AT_ATTRIBUTE, UPDATED_AT_ATTRIBUTE } = contentTypes.constants;\r\n\r\ninterface RelationEntity {\r\n  id: Data.ID;\r\n  documentId: Modules.Documents.ID;\r\n  updatedAt: string | Date;\r\n  publishedAt?: string | Date;\r\n  [key: string]: unknown;\r\n}\r\n\r\nconst addFiltersClause = (params: any, filtersClause: any) => {\r\n  params.filters = params.filters || {};\r\n  params.filters.$and = params.filters.$and || [];\r\n  params.filters.$and.push(filtersClause);\r\n};\r\n\r\nconst sanitizeMainField = (model: any, mainField: any, userAbility: any) => {\r\n  const permissionChecker = getService('permission-checker').create({\r\n    userAbility,\r\n    model: model.uid,\r\n  });\r\n\r\n  // Whether the main field can be displayed or not, regardless of permissions.\r\n  const isMainFieldListable = isListable(model, mainField);\r\n  // Whether the user has the permission to access the model's main field (using RBAC abilities)\r\n  const canReadMainField = permissionChecker.can.read(null, mainField);\r\n\r\n  if (!isMainFieldListable || !canReadMainField) {\r\n    // Default to 'id' if the actual main field shouldn't be displayed\r\n    return 'id';\r\n  }\r\n\r\n  // Edge cases\r\n\r\n  // 1. Enforce 'name' as the main field for users and permissions' roles\r\n  if (model.uid === 'plugin::users-permissions.role') {\r\n    return 'name';\r\n  }\r\n\r\n  return mainField;\r\n};\r\n\r\n/**\r\n *\r\n * All relations sent to this function should have the same status or no status\r\n */\r\nconst addStatusToRelations = async (targetUid: UID.Schema, relations: RelationEntity[]) => {\r\n  if (!contentTypes.hasDraftAndPublish(strapi.getModel(targetUid))) {\r\n    return relations;\r\n  }\r\n\r\n  const documentMetadata = getService('document-metadata');\r\n\r\n  if (!relations.length) {\r\n    return relations;\r\n  }\r\n\r\n  const firstRelation = relations[0];\r\n\r\n  const filters: any = {\r\n    documentId: { $in: relations.map((r) => r.documentId) },\r\n    // NOTE: find the \"opposite\" status\r\n    publishedAt: firstRelation.publishedAt !== null ? { $null: true } : { $notNull: true },\r\n  };\r\n\r\n  const availableStatus = await strapi.query(targetUid).findMany({\r\n    select: ['id', 'documentId', 'locale', 'updatedAt', 'createdAt', 'publishedAt'],\r\n    filters,\r\n  });\r\n\r\n  return relations.map((relation: RelationEntity) => {\r\n    const availableStatuses = availableStatus.filter(\r\n      (availableDocument: RelationEntity) =>\r\n        availableDocument.documentId === relation.documentId &&\r\n        (relation.locale ? availableDocument.locale === relation.locale : true)\r\n    );\r\n\r\n    return {\r\n      ...relation,\r\n      status: documentMetadata.getStatus(relation, availableStatuses),\r\n    };\r\n  });\r\n};\r\n\r\nconst getPublishedAtClause = (status: string, uid: UID.Schema) => {\r\n  const model = strapi.getModel(uid);\r\n\r\n  /**\r\n   * If dp is disabled, ignore the filter\r\n   */\r\n  if (!model || !contentTypes.hasDraftAndPublish(model)) {\r\n    return {};\r\n  }\r\n\r\n  // Prioritize the draft status in case it's not provided\r\n  return status === 'published' ? { $notNull: true } : { $null: true };\r\n};\r\n\r\nconst validateLocale = (sourceUid: UID.Schema, targetUid: UID.ContentType, locale?: string) => {\r\n  const sourceModel = strapi.getModel(sourceUid);\r\n  const targetModel = strapi.getModel(targetUid);\r\n\r\n  const isLocalized = strapi.plugin('i18n').service('content-types').isLocalizedContentType;\r\n  const isSourceLocalized = isLocalized(sourceModel);\r\n  const isTargetLocalized = isLocalized(targetModel);\r\n\r\n  return {\r\n    locale,\r\n    isSourceLocalized,\r\n    isTargetLocalized,\r\n  };\r\n};\r\n\r\nconst validateStatus = (\r\n  sourceUid: UID.Schema,\r\n  status?: Modules.Documents.Params.PublicationStatus.Kind\r\n) => {\r\n  const sourceModel = strapi.getModel(sourceUid);\r\n\r\n  const isDP = contentTypes.hasDraftAndPublish;\r\n  const isSourceDP = isDP(sourceModel);\r\n\r\n  // Default to draft if not set\r\n  if (!isSourceDP) return { status: undefined };\r\n\r\n  switch (status) {\r\n    case 'published':\r\n      return { status: 'published' };\r\n    default:\r\n      // Assign to draft if the status is not valid\r\n      return { status: 'draft' };\r\n  }\r\n};\r\n\r\nexport default {\r\n  async extractAndValidateRequestInfo(ctx: any, id?: Data.ID) {\r\n    const { userAbility } = ctx.state;\r\n    const { model, targetField } = ctx.params;\r\n\r\n    const sourceSchema = strapi.getModel(model);\r\n    if (!sourceSchema) {\r\n      throw new errors.ValidationError(`The model ${model} doesn't exist`);\r\n    }\r\n\r\n    const attribute: any = sourceSchema.attributes[targetField];\r\n    if (!attribute || attribute.type !== 'relation') {\r\n      throw new errors.ValidationError(\r\n        `The relational field ${targetField} doesn't exist on ${model}`\r\n      );\r\n    }\r\n\r\n    const sourceUid = model;\r\n    const targetUid = attribute.target;\r\n\r\n    const { locale, isSourceLocalized, isTargetLocalized } = validateLocale(\r\n      sourceUid,\r\n      targetUid,\r\n      ctx.request?.query?.locale\r\n    );\r\n    const { status } = validateStatus(sourceUid, ctx.request?.query?.status);\r\n\r\n    const permissionChecker = getService('permission-checker').create({\r\n      userAbility,\r\n      model,\r\n    });\r\n\r\n    const isComponent = sourceSchema.modelType === 'component';\r\n    if (!isComponent) {\r\n      if (permissionChecker.cannot.read(null, targetField)) {\r\n        return ctx.forbidden();\r\n      }\r\n    }\r\n\r\n    let entryId: string | number | null = null;\r\n\r\n    if (id) {\r\n      const where: Record<string, any> = {};\r\n\r\n      if (!isComponent) {\r\n        where.documentId = id;\r\n\r\n        if (status) {\r\n          where.publishedAt = getPublishedAtClause(status, sourceUid);\r\n        }\r\n\r\n        if (locale && isSourceLocalized) {\r\n          where.locale = locale;\r\n        }\r\n      } else {\r\n        // If the source is a component, we only need to filter by the\r\n        // component's entity id\r\n        where.id = id;\r\n      }\r\n\r\n      const permissionQuery = await permissionChecker.sanitizedQuery.read(ctx.query);\r\n      const populate = await getService('populate-builder')(model)\r\n        .populateFromQuery(permissionQuery)\r\n        .build();\r\n\r\n      const currentEntity = await strapi.db.query(model).findOne({\r\n        where,\r\n        populate,\r\n      });\r\n\r\n      // We need to check if the entity exists\r\n      // and if the user has the permission to read it in this way\r\n      // There may be multiple entities (publication states) under this\r\n      // documentId + locale. We only need to check if one exists\r\n      if (!currentEntity) {\r\n        throw new errors.NotFoundError();\r\n      }\r\n\r\n      if (!isComponent) {\r\n        if (permissionChecker.cannot.read(currentEntity, targetField)) {\r\n          throw new errors.ForbiddenError();\r\n        }\r\n      }\r\n\r\n      entryId = currentEntity.id;\r\n    }\r\n\r\n    const modelConfig = isComponent\r\n      ? await getService('components').findConfiguration(sourceSchema)\r\n      : await getService('content-types').findConfiguration(sourceSchema);\r\n\r\n    const targetSchema = strapi.getModel(targetUid);\r\n\r\n    const mainField = flow(\r\n      prop(`metadatas.${targetField}.edit.mainField`),\r\n      (mainField) => mainField || 'id',\r\n      (mainField) => sanitizeMainField(targetSchema, mainField, userAbility)\r\n    )(modelConfig);\r\n\r\n    const fieldsToSelect = uniq([\r\n      mainField,\r\n      PUBLISHED_AT_ATTRIBUTE,\r\n      UPDATED_AT_ATTRIBUTE,\r\n      'documentId',\r\n    ]);\r\n\r\n    if (isTargetLocalized) {\r\n      fieldsToSelect.push('locale');\r\n    }\r\n\r\n    return {\r\n      entryId,\r\n      locale,\r\n      status,\r\n      attribute,\r\n      fieldsToSelect,\r\n      mainField,\r\n      source: { schema: sourceSchema, isLocalized: isSourceLocalized },\r\n      target: { schema: targetSchema, isLocalized: isTargetLocalized },\r\n      sourceSchema,\r\n      targetSchema,\r\n      targetField,\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Used to find new relations to add in a relational field.\r\n   *\r\n   * Component and document relations are dealt a bit differently (they don't have a document_id).\r\n   */\r\n  async findAvailable(ctx: any) {\r\n    const { id } = ctx.request.query;\r\n\r\n    await validateFindAvailable(ctx.request.query);\r\n\r\n    const {\r\n      locale,\r\n      status,\r\n      targetField,\r\n      fieldsToSelect,\r\n      mainField,\r\n      source: {\r\n        schema: { uid: sourceUid, modelType: sourceModelType },\r\n        isLocalized: isSourceLocalized,\r\n      },\r\n      target: {\r\n        schema: { uid: targetUid },\r\n        isLocalized: isTargetLocalized,\r\n      },\r\n    } = await this.extractAndValidateRequestInfo(ctx, id);\r\n\r\n    const { idsToOmit, idsToInclude, _q, ...query } = ctx.request.query;\r\n\r\n    const permissionChecker = getService('permission-checker').create({\r\n      userAbility: ctx.state.userAbility,\r\n      model: targetUid,\r\n    });\r\n    const permissionQuery = await permissionChecker.sanitizedQuery.read(query);\r\n\r\n    const queryParams = {\r\n      sort: mainField,\r\n      // cannot select other fields as the user may not have the permissions\r\n      fields: fieldsToSelect,\r\n      ...permissionQuery,\r\n    };\r\n\r\n    // If no status is requested, we find all the draft relations and later update them\r\n    // with the latest available status\r\n    addFiltersClause(queryParams, {\r\n      publishedAt: getPublishedAtClause(status, targetUid),\r\n    });\r\n\r\n    // We will only filter by locale if the target content type is localized\r\n    const filterByLocale = isTargetLocalized && locale;\r\n    if (filterByLocale) {\r\n      addFiltersClause(queryParams, { locale });\r\n    }\r\n\r\n    if (id) {\r\n      /**\r\n       * Exclude the relations that are already related to the source\r\n       *\r\n       * We also optionally filter the target relations by the requested\r\n       * status and locale if provided.\r\n       */\r\n      const subQuery = strapi.db.queryBuilder(sourceUid);\r\n\r\n      // The alias refers to the DB table of the target content type model\r\n      const alias = subQuery.getAlias();\r\n\r\n      const where: Record<string, any> = {\r\n        [`${alias}.id`]: { $notNull: true },\r\n        [`${alias}.document_id`]: { $notNull: true },\r\n      };\r\n\r\n      /**\r\n       * Content Types -> Specify document id\r\n       * Components    -> Specify entity id (they don't have a document id)\r\n       */\r\n      if (sourceModelType === 'contentType') {\r\n        where.document_id = id;\r\n      } else {\r\n        where.id = id;\r\n      }\r\n\r\n      // Add the status and locale filters if they are provided\r\n      const publishedAt = getPublishedAtClause(status, targetUid);\r\n      if (!isEmpty(publishedAt)) {\r\n        where[`${alias}.published_at`] = publishedAt;\r\n      }\r\n\r\n      // If target has localization we need to filter by locale\r\n      if (isTargetLocalized && locale) {\r\n        where[`${alias}.locale`] = locale;\r\n      }\r\n\r\n      if (isSourceLocalized && locale) {\r\n        where.locale = locale;\r\n      }\r\n\r\n      /**\r\n       * UI can provide a list of ids to omit,\r\n       * those are the relations user set in the UI but has not persisted.\r\n       * We don't want to include them in the available relations.\r\n       */\r\n      if ((idsToInclude?.length ?? 0) !== 0) {\r\n        where[`${alias}.id`].$notIn = idsToInclude;\r\n      }\r\n\r\n      const knexSubQuery = subQuery\r\n        .where(where)\r\n        .join({ alias, targetField })\r\n        .select(`${alias}.id`)\r\n        .getKnexQuery();\r\n\r\n      addFiltersClause(queryParams, {\r\n        id: { $notIn: knexSubQuery },\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Apply a filter to the mainField based on the search query and filter operator\r\n     * searching should be allowed only on mainField for permission reasons\r\n     */\r\n    if (_q) {\r\n      const _filter = isOperatorOfType('where', query._filter) ? query._filter : '$containsi';\r\n      addFiltersClause(queryParams, { [mainField]: { [_filter]: _q } });\r\n    }\r\n\r\n    if (idsToOmit?.length > 0) {\r\n      // If we have ids to omit, we should filter them out\r\n      addFiltersClause(queryParams, {\r\n        id: { $notIn: uniq(idsToOmit) },\r\n      });\r\n    }\r\n\r\n    const dbQuery = strapi.get('query-params').transform(targetUid, queryParams);\r\n\r\n    const res = await strapi.db.query(targetUid).findPage(dbQuery);\r\n\r\n    ctx.body = {\r\n      ...res,\r\n      results: await addStatusToRelations(targetUid, res.results),\r\n    };\r\n  },\r\n\r\n  async findExisting(ctx: any) {\r\n    const { userAbility } = ctx.state;\r\n    const { id } = ctx.params;\r\n\r\n    await validateFindExisting(ctx.request.query);\r\n\r\n    const {\r\n      entryId,\r\n      attribute,\r\n      targetField,\r\n      fieldsToSelect,\r\n      status,\r\n      source: { schema: sourceSchema },\r\n      target: { schema: targetSchema },\r\n    } = await this.extractAndValidateRequestInfo(ctx, id);\r\n\r\n    const { uid: sourceUid } = sourceSchema;\r\n    const { uid: targetUid } = targetSchema;\r\n\r\n    const permissionQuery = await getService('permission-checker')\r\n      .create({ userAbility, model: targetUid })\r\n      .sanitizedQuery.read({ fields: fieldsToSelect });\r\n\r\n    /**\r\n     * loadPages can not be used for single relations,\r\n     * this unifies the loading regardless of it's type\r\n     *\r\n     * NOTE: Relations need to be loaded using any db.query method\r\n     *       to ensure the proper ordering is applied\r\n     */\r\n    const dbQuery = strapi.db.query(sourceUid);\r\n    const loadRelations = relations.isAnyToMany(attribute)\r\n      ? (...args: Parameters<typeof dbQuery.loadPages>) => dbQuery.loadPages(...args)\r\n      : (...args: Parameters<typeof dbQuery.load>) =>\r\n          dbQuery\r\n            .load(...args)\r\n            // Ensure response is an array\r\n            .then((res) => ({ results: res ? [res] : [] }));\r\n\r\n    const filters: {\r\n      publishedAt?: Record<string, any>;\r\n    } = {};\r\n\r\n    if (sourceSchema?.options?.draftAndPublish) {\r\n      if (targetSchema?.options?.draftAndPublish) {\r\n        if (status === 'published') {\r\n          filters.publishedAt = { $notNull: true };\r\n        } else {\r\n          filters.publishedAt = { $null: true };\r\n        }\r\n      }\r\n    } else if (targetSchema?.options?.draftAndPublish) {\r\n      // NOTE: we must return the drafts as some targets might not have a published version yet\r\n      filters.publishedAt = { $null: true };\r\n    }\r\n\r\n    /**\r\n     * If user does not have access to specific relations (custom conditions),\r\n     * only the ids of the relations are returned.\r\n     *\r\n     * - First query loads all the ids.\r\n     * - Second one also loads the main field, and excludes forbidden relations.\r\n     *\r\n     * The response contains the union of the two queries.\r\n     */\r\n    const res = await loadRelations({ id: entryId }, targetField, {\r\n      select: ['id', 'documentId', 'locale', 'publishedAt', 'updatedAt'],\r\n      ordering: 'desc',\r\n      page: ctx.request.query.page,\r\n      pageSize: ctx.request.query.pageSize,\r\n      filters,\r\n    });\r\n\r\n    /**\r\n     * Add all ids to load in permissionQuery\r\n     * If any of the relations are not accessible, the permissionQuery will exclude them\r\n     */\r\n    const loadedIds = res.results.map((item: any) => item.id);\r\n    addFiltersClause(permissionQuery, { id: { $in: loadedIds } });\r\n\r\n    /**\r\n     * Load the relations with the main field, the sanitized permission query\r\n     * will exclude the relations the user does not have access to.\r\n     *\r\n     * Pagination is not necessary as the permissionQuery contains the ids to load.\r\n     */\r\n    const sanitizedRes = await loadRelations({ id: entryId }, targetField, {\r\n      ...strapi.get('query-params').transform(targetUid, permissionQuery),\r\n      ordering: 'desc',\r\n    });\r\n\r\n    // NOTE: the order is very import to make sure sanitized relations are kept in priority\r\n    const relationsUnion = uniqBy('id', concat(sanitizedRes.results, res.results));\r\n\r\n    ctx.body = {\r\n      pagination: res.pagination || {\r\n        page: 1,\r\n        pageCount: 1,\r\n        pageSize: 10,\r\n        total: relationsUnion.length,\r\n      },\r\n      results: await addStatusToRelations(targetUid, relationsUnion),\r\n    };\r\n  },\r\n};\r\n","import type { UID, Modules } from '@strapi/types';\r\nimport { setCreatorFields, async, errors } from '@strapi/utils';\r\n\r\nimport { getDocumentLocaleAndStatus } from './validation/dimensions';\r\nimport { getService } from '../utils';\r\nimport { formatDocumentWithMetadata } from './utils/metadata';\r\n\r\ntype OptionsWithPopulate = Modules.Documents.Params.Pick<UID.ContentType, 'populate:object'>;\r\n\r\nconst buildPopulateFromQuery = async (query: any, model: any) => {\r\n  return getService('populate-builder')(model)\r\n    .populateFromQuery(query)\r\n    .populateDeep(Infinity)\r\n    .countRelations()\r\n    .build();\r\n};\r\n\r\nconst findDocument = async (query: any, uid: UID.SingleType, opts: any = {}) => {\r\n  const documentManager = getService('document-manager');\r\n  const populate = await buildPopulateFromQuery(query, uid);\r\n\r\n  return (\r\n    documentManager\r\n      .findMany({ ...opts, populate }, uid)\r\n      // Return the first document found\r\n      .then((documents: any) => documents[0])\r\n  );\r\n};\r\n\r\nconst createOrUpdateDocument = async (ctx: any, opts?: OptionsWithPopulate) => {\r\n  const { user, userAbility } = ctx.state;\r\n  const { model } = ctx.params;\r\n  const { body, query } = ctx.request;\r\n\r\n  const documentManager = getService('document-manager');\r\n  const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n  if (permissionChecker.cannot.create() && permissionChecker.cannot.update()) {\r\n    throw new errors.ForbiddenError();\r\n  }\r\n\r\n  const sanitizedQuery = await permissionChecker.sanitizedQuery.update(query);\r\n\r\n  const { locale } = await getDocumentLocaleAndStatus(body, model);\r\n\r\n  // Load document version to update\r\n  const [documentVersion, otherDocumentVersion] = await Promise.all([\r\n    findDocument(sanitizedQuery, model, { locale, status: 'draft' }),\r\n    // Find the first document to check if it exists\r\n    strapi.db.query(model).findOne({ select: ['documentId'] }),\r\n  ]);\r\n\r\n  const documentId = otherDocumentVersion?.documentId;\r\n\r\n  const pickPermittedFields = documentVersion\r\n    ? permissionChecker.sanitizeUpdateInput(documentVersion)\r\n    : permissionChecker.sanitizeCreateInput;\r\n\r\n  const setCreator = documentVersion\r\n    ? setCreatorFields({ user, isEdition: true })\r\n    : setCreatorFields({ user });\r\n\r\n  const sanitizeFn = async.pipe(pickPermittedFields, setCreator as any);\r\n\r\n  // If version is not found, but document exists,\r\n  // the intent is to create a new document locale\r\n  if (documentVersion) {\r\n    if (permissionChecker.cannot.update(documentVersion)) {\r\n      throw new errors.ForbiddenError();\r\n    }\r\n  } else if (permissionChecker.cannot.create()) {\r\n    throw new errors.ForbiddenError();\r\n  }\r\n\r\n  const sanitizedBody = await sanitizeFn(body);\r\n\r\n  if (!documentId) {\r\n    return documentManager.create(model, {\r\n      data: sanitizedBody,\r\n      ...sanitizedQuery,\r\n      locale,\r\n    });\r\n  }\r\n\r\n  return documentManager.update(documentId, model, {\r\n    data: sanitizedBody as any,\r\n    populate: opts?.populate,\r\n    locale,\r\n  });\r\n};\r\n\r\nexport default {\r\n  async find(ctx: any) {\r\n    const { userAbility } = ctx.state;\r\n    const { model } = ctx.params;\r\n    const { query = {} } = ctx.request;\r\n\r\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n    if (permissionChecker.cannot.read()) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    const permissionQuery = await permissionChecker.sanitizedQuery.read(query);\r\n    const { locale, status } = await getDocumentLocaleAndStatus(query, model);\r\n\r\n    const version = await findDocument(permissionQuery, model, { locale, status });\r\n\r\n    // allow user with create permission to know a single type is not created\r\n    if (!version) {\r\n      if (permissionChecker.cannot.create()) {\r\n        return ctx.forbidden();\r\n      }\r\n      // Check if document exists\r\n      const document = await strapi.db.query(model).findOne({});\r\n\r\n      if (!document) {\r\n        return ctx.notFound();\r\n      }\r\n\r\n      // If the requested locale doesn't exist, return an empty response\r\n      const { meta } = await formatDocumentWithMetadata(\r\n        permissionChecker,\r\n        model,\r\n        // @ts-expect-error - fix types\r\n        { documentId: document.documentId, locale, publishedAt: null },\r\n        { availableLocales: true, availableStatus: false }\r\n      );\r\n      ctx.body = { data: {}, meta };\r\n      return;\r\n    }\r\n\r\n    if (permissionChecker.cannot.read(version)) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    const sanitizedDocument = await permissionChecker.sanitizeOutput(version);\r\n    ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedDocument);\r\n  },\r\n\r\n  async createOrUpdate(ctx: any) {\r\n    const { userAbility } = ctx.state;\r\n    const { model } = ctx.params;\r\n\r\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n    const document = await createOrUpdateDocument(ctx);\r\n    const sanitizedDocument = await permissionChecker.sanitizeOutput(document);\r\n    ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedDocument);\r\n  },\r\n\r\n  async delete(ctx: any) {\r\n    const { userAbility } = ctx.state;\r\n    const { model } = ctx.params;\r\n    const { query = {} } = ctx.request;\r\n\r\n    const documentManager = getService('document-manager');\r\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n    if (permissionChecker.cannot.delete()) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    const sanitizedQuery = await permissionChecker.sanitizedQuery.delete(query);\r\n    const populate = await buildPopulateFromQuery(sanitizedQuery, model);\r\n\r\n    const { locale } = await getDocumentLocaleAndStatus(query, model);\r\n    const documentLocales = await documentManager.findLocales(undefined, model, {\r\n      populate,\r\n      locale,\r\n    });\r\n\r\n    if (documentLocales.length === 0) {\r\n      return ctx.notFound();\r\n    }\r\n\r\n    for (const document of documentLocales) {\r\n      if (permissionChecker.cannot.delete(document)) {\r\n        return ctx.forbidden();\r\n      }\r\n    }\r\n\r\n    const deletedEntity = await documentManager.delete(documentLocales.at(0).documentId, model, {\r\n      locale,\r\n    });\r\n\r\n    ctx.body = await permissionChecker.sanitizeOutput(deletedEntity);\r\n  },\r\n\r\n  async publish(ctx: any) {\r\n    const { userAbility } = ctx.state;\r\n    const { model } = ctx.params;\r\n    const { query = {} } = ctx.request;\r\n\r\n    const documentManager = getService('document-manager');\r\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n    if (permissionChecker.cannot.publish()) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    const publishedDocument = await strapi.db.transaction(async () => {\r\n      const sanitizedQuery = await permissionChecker.sanitizedQuery.publish(query);\r\n      const populate = await buildPopulateFromQuery(sanitizedQuery, model);\r\n      const document = await createOrUpdateDocument(ctx, { populate });\r\n\r\n      if (!document) {\r\n        throw new errors.NotFoundError();\r\n      }\r\n\r\n      if (permissionChecker.cannot.publish(document)) {\r\n        throw new errors.ForbiddenError();\r\n      }\r\n\r\n      const { locale } = await getDocumentLocaleAndStatus(document, model);\r\n      const publishResult = await documentManager.publish(document.documentId, model, { locale });\r\n\r\n      return publishResult.at(0);\r\n    });\r\n\r\n    const sanitizedDocument = await permissionChecker.sanitizeOutput(publishedDocument);\r\n    ctx.body = await formatDocumentWithMetadata(permissionChecker, model, sanitizedDocument);\r\n  },\r\n\r\n  async unpublish(ctx: any) {\r\n    const { userAbility } = ctx.state;\r\n    const { model } = ctx.params;\r\n    const {\r\n      body: { discardDraft, ...body },\r\n      query = {},\r\n    } = ctx.request;\r\n\r\n    const documentManager = getService('document-manager');\r\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n    if (permissionChecker.cannot.unpublish()) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    if (discardDraft && permissionChecker.cannot.discard()) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    const sanitizedQuery = await permissionChecker.sanitizedQuery.unpublish(query);\r\n    const { locale } = await getDocumentLocaleAndStatus(body, model);\r\n\r\n    const document = await findDocument(sanitizedQuery, model, { locale });\r\n\r\n    if (!document) {\r\n      return ctx.notFound();\r\n    }\r\n\r\n    if (permissionChecker.cannot.unpublish(document)) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    if (discardDraft && permissionChecker.cannot.discard(document)) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    await strapi.db.transaction(async () => {\r\n      if (discardDraft) {\r\n        await documentManager.discardDraft(document.documentId, model, { locale });\r\n      }\r\n\r\n      ctx.body = await async.pipe(\r\n        (document) => documentManager.unpublish(document.documentId, model, { locale }),\r\n        permissionChecker.sanitizeOutput,\r\n        (document) => formatDocumentWithMetadata(permissionChecker, model, document)\r\n      )(document);\r\n    });\r\n  },\r\n\r\n  async discard(ctx: any) {\r\n    const { userAbility } = ctx.state;\r\n    const { model } = ctx.params;\r\n    const { body, query = {} } = ctx.request;\r\n\r\n    const documentManager = getService('document-manager');\r\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n    if (permissionChecker.cannot.discard()) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    const sanitizedQuery = await permissionChecker.sanitizedQuery.discard(query);\r\n    const { locale } = await getDocumentLocaleAndStatus(body, model);\r\n\r\n    const document = await findDocument(sanitizedQuery, model, { locale, status: 'published' });\r\n\r\n    // Can not discard a document that is not published\r\n    if (!document) {\r\n      return ctx.notFound();\r\n    }\r\n\r\n    if (permissionChecker.cannot.discard(document)) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    ctx.body = await async.pipe(\r\n      (document) => documentManager.discardDraft(document.documentId, model, { locale }),\r\n      permissionChecker.sanitizeOutput,\r\n      (document) => formatDocumentWithMetadata(permissionChecker, model, document)\r\n    )(document);\r\n  },\r\n\r\n  async countDraftRelations(ctx: any) {\r\n    const { userAbility } = ctx.state;\r\n    const { model } = ctx.params;\r\n    const { query } = ctx.request;\r\n    const documentManager = getService('document-manager');\r\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\r\n\r\n    const { locale } = await getDocumentLocaleAndStatus(query, model);\r\n\r\n    if (permissionChecker.cannot.read()) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    const document = await findDocument({}, model);\r\n    if (!document) {\r\n      return ctx.notFound();\r\n    }\r\n\r\n    if (permissionChecker.cannot.read(document)) {\r\n      return ctx.forbidden();\r\n    }\r\n\r\n    const number = await documentManager.countDraftRelations(document.documentId, model, locale);\r\n\r\n    return {\r\n      data: number,\r\n    };\r\n  },\r\n};\r\n","import type { UID } from '@strapi/types';\r\nimport { getService } from '../utils';\r\nimport { getDocumentLocaleAndStatus } from './validation/dimensions';\r\n\r\nimport {\r\n  validateGenerateUIDInput,\r\n  validateCheckUIDAvailabilityInput,\r\n  validateUIDField,\r\n} from './validation';\r\n\r\nexport default {\r\n  async generateUID(ctx: any) {\r\n    const { contentTypeUID, field, data } = await validateGenerateUIDInput(ctx.request.body);\r\n\r\n    const { query = {} } = ctx.request;\r\n    const { locale } = await getDocumentLocaleAndStatus(query, contentTypeUID as UID.Schema);\r\n\r\n    await validateUIDField(contentTypeUID, field);\r\n\r\n    const uidService = getService('uid');\r\n\r\n    ctx.body = {\r\n      data: await uidService.generateUIDField({ contentTypeUID, field, data, locale }),\r\n    };\r\n  },\r\n\r\n  async checkUIDAvailability(ctx: any) {\r\n    const { contentTypeUID, field, value } = await validateCheckUIDAvailabilityInput(\r\n      ctx.request.body\r\n    );\r\n\r\n    const { query = {} } = ctx.request;\r\n    const { locale } = await getDocumentLocaleAndStatus(query, contentTypeUID as UID.Schema);\r\n\r\n    await validateUIDField(contentTypeUID, field);\r\n\r\n    const uidService = getService('uid');\r\n\r\n    const isAvailable = await uidService.checkUIDAvailability({\r\n      contentTypeUID,\r\n      field,\r\n      value,\r\n      locale,\r\n    });\r\n\r\n    ctx.body = {\r\n      isAvailable,\r\n      suggestion: !isAvailable\r\n        ? await uidService.findUniqueUID({ contentTypeUID, field, value, locale })\r\n        : null,\r\n    };\r\n  },\r\n};\r\n","import collectionTypes from './collection-types';\r\nimport components from './components';\r\nimport contentTypes from './content-types';\r\nimport init from './init';\r\nimport relations from './relations';\r\nimport singleTypes from './single-types';\r\nimport uid from './uid';\r\nimport history from '../history';\r\nimport preview from '../preview';\r\n\r\nexport default {\r\n  'collection-types': collectionTypes,\r\n  components,\r\n  'content-types': contentTypes,\r\n  init,\r\n  relations,\r\n  'single-types': singleTypes,\r\n  uid,\r\n  ...(history.controllers ? history.controllers : {}),\r\n  ...(preview.controllers ? preview.controllers : {}),\r\n};\r\n","import _ from 'lodash';\r\n\r\nconst keys = {\r\n  CONFIGURATION: 'configuration',\r\n};\r\n\r\nconst getStore = () => strapi.store({ type: 'plugin', name: 'content_manager' });\r\n\r\n/** Model configuration */\r\nconst EMPTY_CONFIG = {\r\n  settings: {},\r\n  metadatas: {},\r\n  layouts: {},\r\n};\r\n\r\nconst configurationKey = (key: any) => `${keys.CONFIGURATION}_${key}`;\r\n\r\nconst getModelConfiguration = async (key: any) => {\r\n  const config = await getStore().get({ key: configurationKey(key) });\r\n  return _.merge({}, EMPTY_CONFIG, config);\r\n};\r\n\r\nconst setModelConfiguration = async (key: string, value: any) => {\r\n  const storedConfig = (await getStore().get({ key: configurationKey(key) })) || {};\r\n  const currentConfig = { ...storedConfig };\r\n\r\n  Object.keys(value).forEach((key) => {\r\n    if (value[key] !== null && value[key] !== undefined) {\r\n      _.set(currentConfig, key, value[key]);\r\n    }\r\n  });\r\n\r\n  if (!_.isEqual(currentConfig, storedConfig)) {\r\n    return getStore().set({\r\n      key: configurationKey(key),\r\n      value: currentConfig,\r\n    });\r\n  }\r\n};\r\n\r\nconst deleteKey = (key: any) => {\r\n  return strapi.db\r\n    .query('strapi::core-store')\r\n    .delete({ where: { key: `plugin_content_manager_configuration_${key}` } });\r\n};\r\n\r\nconst findByKey = async (key: any) => {\r\n  const results = await strapi.db.query('strapi::core-store').findMany({\r\n    where: {\r\n      key: {\r\n        $startsWith: key,\r\n      },\r\n    },\r\n  });\r\n\r\n  return results.map(({ value }) => JSON.parse(value));\r\n};\r\n\r\nconst getAllConfigurations = () => findByKey('plugin_content_manager_configuration');\r\n\r\nexport default {\r\n  getAllConfigurations,\r\n  findByKey,\r\n  getModelConfiguration,\r\n  setModelConfiguration,\r\n  deleteKey,\r\n  keys,\r\n};\r\n","import _ from 'lodash';\r\nimport { getService } from '../../../utils';\r\nimport {\r\n  isSortable,\r\n  isSearchable,\r\n  isVisible,\r\n  isListable,\r\n  isRelation,\r\n  getDefaultMainField,\r\n} from './attributes';\r\n\r\nfunction createDefaultMetadatas(schema: any) {\r\n  return {\r\n    ...Object.keys(schema.attributes).reduce((acc: any, name) => {\r\n      acc[name] = createDefaultMetadata(schema, name);\r\n      return acc;\r\n    }, {}),\r\n    id: {\r\n      edit: {},\r\n      list: {\r\n        label: 'id',\r\n        searchable: true,\r\n        sortable: true,\r\n      },\r\n    },\r\n  };\r\n}\r\n\r\nfunction createDefaultMetadata(schema: any, name: any) {\r\n  const edit = {\r\n    label: name,\r\n    description: '',\r\n    placeholder: '',\r\n    visible: isVisible(schema, name),\r\n    editable: true,\r\n  } as any;\r\n\r\n  const fieldAttributes = schema.attributes[name];\r\n  if (isRelation(fieldAttributes)) {\r\n    const { targetModel } = fieldAttributes;\r\n\r\n    const targetSchema = getTargetSchema(targetModel);\r\n\r\n    if (targetSchema) {\r\n      edit.mainField = getDefaultMainField(targetSchema);\r\n    }\r\n  }\r\n\r\n  _.assign(\r\n    edit,\r\n    _.pick(_.get(schema, ['config', 'metadatas', name, 'edit'], {}), [\r\n      'label',\r\n      'description',\r\n      'placeholder',\r\n      'visible',\r\n      'editable',\r\n      'mainField',\r\n    ])\r\n  );\r\n\r\n  const list = {\r\n    // @ts-expect-error we need to specify these properties\r\n    label: name,\r\n    // @ts-expect-error we need to specify these properties\r\n    searchable: isSearchable(schema, name),\r\n    // @ts-expect-error we need to specify these properties\r\n    sortable: isSortable(schema, name),\r\n    ..._.pick(_.get(schema, ['config', 'metadatas', name, 'list'], {}), [\r\n      'label',\r\n      'searchable',\r\n      'sortable',\r\n    ]),\r\n  };\r\n\r\n  return { edit, list };\r\n}\r\n\r\n/** Synchronisation functions */\r\n\r\nasync function syncMetadatas(configuration: any, schema: any) {\r\n  // clear all keys that do not exist anymore\r\n  if (_.isEmpty(configuration.metadatas)) {\r\n    return createDefaultMetadatas(schema);\r\n  }\r\n\r\n  // remove old keys\r\n  const metasWithValidKeys = _.pick(configuration.metadatas, Object.keys(schema.attributes));\r\n\r\n  // add new keys and missing fields\r\n  const metasWithDefaults = _.merge({}, createDefaultMetadatas(schema), metasWithValidKeys);\r\n\r\n  // clear the invalid mainFields\r\n  const updatedMetas = Object.keys(metasWithDefaults).reduce((acc, key) => {\r\n    const { edit, list } = metasWithDefaults[key];\r\n    const attr = schema.attributes[key];\r\n\r\n    const updatedMeta = { edit, list };\r\n    // update sortable attr\r\n    if (list.sortable && !isSortable(schema, key)) {\r\n      _.set(updatedMeta, ['list', 'sortable'], false);\r\n      _.set(acc, [key], updatedMeta);\r\n    }\r\n\r\n    if (list.searchable && !isSearchable(schema, key)) {\r\n      _.set(updatedMeta, ['list', 'searchable'], false);\r\n      _.set(acc, [key], updatedMeta);\r\n    }\r\n\r\n    if (!_.has(edit, 'mainField')) return acc;\r\n\r\n    // remove mainField if the attribute is not a relation anymore\r\n    if (!isRelation(attr)) {\r\n      _.set(updatedMeta, 'edit', _.omit(edit, ['mainField']));\r\n      _.set(acc, [key], updatedMeta);\r\n      return acc;\r\n    }\r\n\r\n    // if the mainField is id you can keep it\r\n    if (edit.mainField === 'id') return acc;\r\n\r\n    // check the mainField in the targetModel\r\n    const targetSchema = getTargetSchema(attr.targetModel);\r\n\r\n    if (!targetSchema) return acc;\r\n\r\n    if (!isSortable(targetSchema, edit.mainField) && !isListable(targetSchema, edit.mainField)) {\r\n      _.set(updatedMeta, ['edit', 'mainField'], getDefaultMainField(targetSchema));\r\n      _.set(acc, [key], updatedMeta);\r\n      return acc;\r\n    }\r\n\r\n    return acc;\r\n  }, {});\r\n\r\n  return _.assign(metasWithDefaults, updatedMetas);\r\n}\r\n\r\nconst getTargetSchema = (targetModel: any) => {\r\n  return getService('content-types').findContentType(targetModel);\r\n};\r\n\r\nexport { createDefaultMetadatas, syncMetadatas };\r\n","import _ from 'lodash';\r\nimport { getService } from '../../../utils';\r\nimport { isListable, hasEditableAttribute, hasRelationAttribute } from './attributes';\r\n\r\nconst DEFAULT_LIST_LENGTH = 4;\r\nconst MAX_ROW_SIZE = 12;\r\n\r\nconst isAllowedFieldSize = (type: any, size: any) => {\r\n  const { getFieldSize } = getService('field-sizes');\r\n  const fieldSize = getFieldSize(type);\r\n\r\n  // Check if field was locked to another size\r\n  if (!fieldSize.isResizable && size !== fieldSize.default) {\r\n    return false;\r\n  }\r\n\r\n  // Otherwise allow unless it's bigger than a row\r\n  return size <= MAX_ROW_SIZE;\r\n};\r\n\r\nconst getDefaultFieldSize = (attribute: any) => {\r\n  const { hasFieldSize, getFieldSize } = getService('field-sizes');\r\n\r\n  // Check if it's a custom field with a custom size and get the default size for the field type\r\n  return getFieldSize(hasFieldSize(attribute.customField) ? attribute.customField : attribute.type)\r\n    .default;\r\n};\r\n\r\nasync function createDefaultLayouts(schema: any) {\r\n  return {\r\n    // @ts-expect-error necessary to provide this default layout\r\n    list: createDefaultListLayout(schema),\r\n    // @ts-expect-error necessary to provide this default layout\r\n    edit: createDefaultEditLayout(schema),\r\n    ..._.pick(_.get(schema, ['config', 'layouts'], {}), ['list', 'edit']),\r\n  };\r\n}\r\n\r\nfunction createDefaultListLayout(schema: any) {\r\n  return Object.keys(schema.attributes)\r\n    .filter((name) => isListable(schema, name))\r\n    .slice(0, DEFAULT_LIST_LENGTH);\r\n}\r\n\r\nconst rowSize = (els: any) => els.reduce((sum: any, el: any) => sum + el.size, 0);\r\n\r\nfunction createDefaultEditLayout(schema: any) {\r\n  const keys = Object.keys(schema.attributes).filter((name) => hasEditableAttribute(schema, name));\r\n\r\n  return appendToEditLayout([], keys, schema);\r\n}\r\n\r\n/** Synchronisation functions */\r\n\r\nfunction syncLayouts(configuration: any, schema: any) {\r\n  if (_.isEmpty(configuration.layouts)) return createDefaultLayouts(schema);\r\n\r\n  const { list = [], editRelations = [], edit = [] } = configuration.layouts || {};\r\n\r\n  let cleanList = list.filter((attr: any) => isListable(schema, attr));\r\n\r\n  // TODO V5: remove editRelations\r\n  const cleanEditRelations = editRelations.filter((attr: any) =>\r\n    hasRelationAttribute(schema, attr)\r\n  );\r\n\r\n  // backward compatibility with when relations were on the side of the layout\r\n  // it migrates the displayed relations to the main edit layout\r\n  const elementsToReAppend = [...cleanEditRelations];\r\n  let cleanEdit: unknown[] = [];\r\n  for (const row of edit) {\r\n    const newRow: unknown[] = [];\r\n\r\n    for (const el of row) {\r\n      if (!hasEditableAttribute(schema, el.name)) continue;\r\n\r\n      // Check if the field is a custom field with a custom size.\r\n      // If so, use the custom size instead of the type size\r\n      const { hasFieldSize } = getService('field-sizes');\r\n      const fieldType = hasFieldSize(schema.attributes[el.name].customField)\r\n        ? schema.attributes[el.name].customField\r\n        : schema.attributes[el.name].type;\r\n\r\n      /* if the type of a field was changed (ex: string -> json) or a new field was added in the schema\r\n         and the new type doesn't allow the size of the previous type, append the field at the end of layouts\r\n      */\r\n      if (!isAllowedFieldSize(fieldType, el.size)) {\r\n        elementsToReAppend.push(el.name);\r\n        continue;\r\n      }\r\n\r\n      newRow.push(el);\r\n    }\r\n\r\n    if (newRow.length > 0) {\r\n      cleanEdit.push(newRow);\r\n    }\r\n  }\r\n\r\n  cleanEdit = appendToEditLayout(cleanEdit as any, elementsToReAppend, schema);\r\n\r\n  const newAttributes = _.difference(\r\n    Object.keys(schema.attributes),\r\n    Object.keys(configuration.metadatas)\r\n  );\r\n\r\n  /** Add new attributes where they belong */\r\n\r\n  if (cleanList.length < DEFAULT_LIST_LENGTH) {\r\n    // add newAttributes\r\n    // only add valid listable attributes\r\n    cleanList = _.uniq(\r\n      cleanList\r\n        .concat(newAttributes.filter((key) => isListable(schema, key)))\r\n        .slice(0, DEFAULT_LIST_LENGTH)\r\n    );\r\n  }\r\n\r\n  // add new attributes to edit view\r\n  const newEditAttributes = newAttributes.filter((key) => hasEditableAttribute(schema, key));\r\n\r\n  cleanEdit = appendToEditLayout(cleanEdit, newEditAttributes, schema);\r\n\r\n  return {\r\n    list: cleanList.length > 0 ? cleanList : createDefaultListLayout(schema),\r\n    edit: cleanEdit.length > 0 ? cleanEdit : createDefaultEditLayout(schema),\r\n  };\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/default-param-last\r\nconst appendToEditLayout = (layout: any = [], keysToAppend: any, schema: any) => {\r\n  if (keysToAppend.length === 0) return layout;\r\n  let currentRowIndex = Math.max(layout.length - 1, 0);\r\n\r\n  // init currentRow if necessary\r\n  if (!layout[currentRowIndex]) {\r\n    layout[currentRowIndex] = [];\r\n  }\r\n\r\n  for (const key of keysToAppend) {\r\n    const attribute = schema.attributes[key];\r\n\r\n    const attributeSize = getDefaultFieldSize(attribute);\r\n    const currenRowSize = rowSize(layout[currentRowIndex]);\r\n\r\n    if (currenRowSize + attributeSize > MAX_ROW_SIZE) {\r\n      currentRowIndex += 1;\r\n      layout[currentRowIndex] = [];\r\n    }\r\n\r\n    layout[currentRowIndex].push({\r\n      name: key,\r\n      size: attributeSize,\r\n    });\r\n  }\r\n\r\n  return layout;\r\n};\r\n\r\nexport { createDefaultLayouts, syncLayouts };\r\n","import { createModelConfigurationSchema } from '../../../controllers/validation';\r\nimport { createDefaultSettings, syncSettings } from './settings';\r\nimport { createDefaultMetadatas, syncMetadatas } from './metadatas';\r\nimport { createDefaultLayouts, syncLayouts } from './layouts';\r\n\r\nasync function validateCustomConfig(schema: any) {\r\n  try {\r\n    await createModelConfigurationSchema(schema, {\r\n      allowUndefined: true,\r\n    }).validate(schema.config);\r\n  } catch (error: any) {\r\n    throw new Error(\r\n      `Invalid Model configuration for model ${schema.uid}. Verify your {{ modelName }}.config.js(on) file:\\n  - ${error.message}\\n`\r\n    );\r\n  }\r\n}\r\n\r\nasync function createDefaultConfiguration(schema: any) {\r\n  await validateCustomConfig(schema);\r\n\r\n  return {\r\n    settings: await createDefaultSettings(schema),\r\n    metadatas: await createDefaultMetadatas(schema),\r\n    layouts: await createDefaultLayouts(schema),\r\n  };\r\n}\r\n\r\nasync function syncConfiguration(conf: any, schema: any) {\r\n  await validateCustomConfig(schema);\r\n\r\n  return {\r\n    settings: await syncSettings(conf, schema),\r\n    layouts: await syncLayouts(conf, schema),\r\n    metadatas: await syncMetadatas(conf, schema),\r\n  };\r\n}\r\n\r\nexport { createDefaultConfiguration, syncConfiguration };\r\n","import { intersection, difference } from 'lodash';\r\n\r\nimport type { Settings, Metadatas, Layouts } from '../../../shared/contracts/content-types';\r\n\r\nimport { createDefaultConfiguration, syncConfiguration } from './utils/configuration';\r\n\r\nexport type ConfigurationUpdate = {\r\n  settings: Settings;\r\n  metadatas: Metadatas;\r\n  layouts: Layouts;\r\n  options?: Record<string, unknown>;\r\n};\r\n\r\nexport default ({\r\n  isComponent,\r\n  prefix,\r\n  storeUtils,\r\n  getModels,\r\n}: {\r\n  isComponent?: boolean;\r\n  prefix: string;\r\n  storeUtils: any;\r\n  getModels: any;\r\n}) => {\r\n  const uidToStoreKey = (uid: string) => {\r\n    return `${prefix}::${uid}`;\r\n  };\r\n\r\n  const getConfiguration = (uid: string) => {\r\n    const storeKey = uidToStoreKey(uid);\r\n\r\n    return storeUtils.getModelConfiguration(storeKey);\r\n  };\r\n\r\n  const setConfiguration = (uid: string, input: ConfigurationUpdate) => {\r\n    const configuration = {\r\n      ...input,\r\n      uid,\r\n      isComponent: isComponent ?? undefined,\r\n    };\r\n\r\n    const storeKey = uidToStoreKey(uid);\r\n    return storeUtils.setModelConfiguration(storeKey, configuration);\r\n  };\r\n\r\n  const deleteConfiguration = (uid: string) => {\r\n    const storeKey = uidToStoreKey(uid);\r\n\r\n    return storeUtils.deleteKey(storeKey);\r\n  };\r\n\r\n  const syncConfigurations = async () => {\r\n    const models = getModels();\r\n\r\n    const configurations = await storeUtils.findByKey(\r\n      `plugin_content_manager_configuration_${prefix}`\r\n    );\r\n\r\n    const updateConfiguration = async (uid: string) => {\r\n      const conf = configurations.find((conf: any) => conf.uid === uid);\r\n\r\n      return setConfiguration(uid, await syncConfiguration(conf, models[uid]));\r\n    };\r\n\r\n    const generateNewConfiguration = async (uid: string) => {\r\n      return setConfiguration(uid, await createDefaultConfiguration(models[uid]));\r\n    };\r\n\r\n    const currentUIDS = Object.keys(models);\r\n    const DBUIDs = configurations.map(({ uid }: any) => uid);\r\n\r\n    const contentTypesToUpdate = intersection(currentUIDS, DBUIDs);\r\n    const contentTypesToAdd = difference(currentUIDS, DBUIDs);\r\n    const contentTypesToDelete = difference(DBUIDs, currentUIDS);\r\n\r\n    // delete old schemas\r\n    await Promise.all(contentTypesToDelete.map((uid) => deleteConfiguration(uid)));\r\n\r\n    // create new schemas\r\n    await Promise.all(contentTypesToAdd.map((uid) => generateNewConfiguration(uid)));\r\n\r\n    // update current schemas\r\n    await Promise.all(contentTypesToUpdate.map((uid) => updateConfiguration(uid)));\r\n  };\r\n\r\n  return {\r\n    getConfiguration,\r\n    setConfiguration,\r\n    deleteConfiguration,\r\n    syncConfigurations,\r\n  };\r\n};\r\n","import { has, isNil, mapValues } from 'lodash/fp';\r\n\r\nimport type { UID, Struct, Core } from '@strapi/types';\r\nimport type { Configuration } from '../../../shared/contracts/content-types';\r\nimport type { ConfigurationUpdate } from './configuration';\r\n\r\nimport { getService } from '../utils';\r\nimport storeUtils from './utils/store';\r\nimport createConfigurationService from './configuration';\r\n\r\nconst STORE_KEY_PREFIX = 'components';\r\n\r\nconst configurationService = createConfigurationService({\r\n  storeUtils,\r\n  isComponent: true,\r\n  prefix: STORE_KEY_PREFIX,\r\n  getModels() {\r\n    const { toContentManagerModel } = getService('data-mapper');\r\n\r\n    return mapValues(toContentManagerModel, strapi.components);\r\n  },\r\n});\r\n\r\nexport default ({ strapi }: { strapi: Core.Strapi }) => ({\r\n  findAllComponents() {\r\n    const { toContentManagerModel } = getService('data-mapper');\r\n\r\n    return Object.values(strapi.components).map(toContentManagerModel);\r\n  },\r\n\r\n  findComponent(uid: UID.Component) {\r\n    const { toContentManagerModel } = getService('data-mapper');\r\n\r\n    const component = strapi.components[uid];\r\n\r\n    return isNil(component) ? component : toContentManagerModel(component);\r\n  },\r\n\r\n  async findConfiguration(component: Struct.ComponentSchema) {\r\n    const configuration: Configuration = await configurationService.getConfiguration(component.uid);\r\n\r\n    return {\r\n      uid: component.uid,\r\n      category: component.category,\r\n      ...configuration,\r\n    };\r\n  },\r\n\r\n  async updateConfiguration(\r\n    component: Struct.ComponentSchema,\r\n    newConfiguration: ConfigurationUpdate\r\n  ) {\r\n    await configurationService.setConfiguration(component.uid, newConfiguration);\r\n\r\n    return this.findConfiguration(component);\r\n  },\r\n\r\n  async findComponentsConfigurations(model: Struct.ComponentSchema) {\r\n    const componentsMap: Record<\r\n      string,\r\n      Configuration & { category: string; isComponent: boolean }\r\n    > = {};\r\n\r\n    const getComponentConfigurations = async (uid: UID.Component) => {\r\n      const component = this.findComponent(uid);\r\n\r\n      if (has(uid, componentsMap)) {\r\n        return;\r\n      }\r\n\r\n      const componentConfiguration = await this.findConfiguration(component);\r\n      const componentsConfigurations = await this.findComponentsConfigurations(component);\r\n\r\n      Object.assign(componentsMap, {\r\n        [uid]: componentConfiguration,\r\n        ...componentsConfigurations,\r\n      });\r\n    };\r\n\r\n    for (const key of Object.keys(model.attributes)) {\r\n      const attribute = model.attributes[key];\r\n\r\n      if (attribute.type === 'component') {\r\n        await getComponentConfigurations(attribute.component);\r\n      }\r\n\r\n      if (attribute.type === 'dynamiczone') {\r\n        for (const componentUid of attribute.components) {\r\n          await getComponentConfigurations(componentUid);\r\n        }\r\n      }\r\n    }\r\n\r\n    return componentsMap;\r\n  },\r\n\r\n  syncConfigurations() {\r\n    return configurationService.syncConfigurations();\r\n  },\r\n});\r\n","import { isNil, mapValues } from 'lodash/fp';\r\nimport { contentTypes as contentTypesUtils } from '@strapi/utils';\r\n\r\nimport type { UID, Struct, Core } from '@strapi/types';\r\n\r\nimport type { ConfigurationUpdate } from './configuration';\r\n\r\nimport { getService } from '../utils';\r\nimport storeUtils from './utils/store';\r\nimport createConfigurationService from './configuration';\r\n\r\nconst configurationService = createConfigurationService({\r\n  storeUtils,\r\n  prefix: 'content_types',\r\n  getModels() {\r\n    const { toContentManagerModel } = getService('data-mapper');\r\n\r\n    return mapValues(toContentManagerModel, strapi.contentTypes);\r\n  },\r\n});\r\n\r\nconst service = ({ strapi }: { strapi: Core.Strapi }) => ({\r\n  findAllContentTypes() {\r\n    const { toContentManagerModel } = getService('data-mapper');\r\n\r\n    return Object.values(strapi.contentTypes).map(toContentManagerModel);\r\n  },\r\n\r\n  findContentType(uid: UID.ContentType) {\r\n    const { toContentManagerModel } = getService('data-mapper');\r\n\r\n    const contentType = strapi.contentTypes[uid];\r\n\r\n    return isNil(contentType) ? contentType : toContentManagerModel(contentType);\r\n  },\r\n\r\n  findDisplayedContentTypes() {\r\n    return this.findAllContentTypes().filter(\r\n      // TODO\r\n      // @ts-expect-error should be resolved from data-mapper types\r\n      ({ isDisplayed }: { isDisplayed: boolean }) => isDisplayed === true\r\n    );\r\n  },\r\n\r\n  findContentTypesByKind(kind: { kind: Struct.ContentTypeKind | undefined }) {\r\n    if (!kind) {\r\n      return this.findAllContentTypes();\r\n    }\r\n\r\n    // @ts-expect-error TODO when adding types\r\n    return this.findAllContentTypes().filter(contentTypesUtils.isKind(kind));\r\n  },\r\n\r\n  async findConfiguration(contentType: Struct.ContentTypeSchema) {\r\n    const configuration = await configurationService.getConfiguration(contentType.uid);\r\n\r\n    return {\r\n      uid: contentType.uid,\r\n      ...configuration,\r\n    };\r\n  },\r\n\r\n  async updateConfiguration(\r\n    contentType: Struct.ContentTypeSchema,\r\n    newConfiguration: ConfigurationUpdate\r\n  ) {\r\n    await configurationService.setConfiguration(contentType.uid, newConfiguration);\r\n\r\n    return this.findConfiguration(contentType);\r\n  },\r\n\r\n  findComponentsConfigurations(contentType: Struct.ContentTypeSchema) {\r\n    // delegate to componentService\r\n    return getService('components').findComponentsConfigurations(contentType);\r\n  },\r\n\r\n  syncConfigurations() {\r\n    return configurationService.syncConfigurations();\r\n  },\r\n});\r\n\r\nexport default service;\r\n","import { pick, getOr } from 'lodash/fp';\r\nimport { contentTypes as contentTypesUtils } from '@strapi/utils';\r\n\r\nimport type { Schema, Struct } from '@strapi/types';\r\n\r\nconst dtoFields = [\r\n  'uid',\r\n  'isDisplayed',\r\n  'apiID',\r\n  'kind',\r\n  'category',\r\n  'info',\r\n  'options',\r\n  'pluginOptions',\r\n  'attributes',\r\n  'pluginOptions',\r\n];\r\n\r\nexport default () => ({\r\n  toContentManagerModel(contentType: Struct.ComponentSchema) {\r\n    return {\r\n      ...contentType,\r\n      apiID: contentType.modelName,\r\n      isDisplayed: isVisible(contentType),\r\n      attributes: {\r\n        id: {\r\n          type: 'integer',\r\n        },\r\n        ...formatAttributes(contentType),\r\n      },\r\n    };\r\n  },\r\n\r\n  toDto: pick(dtoFields),\r\n});\r\n\r\nconst formatAttributes = (contentType: Struct.ComponentSchema) => {\r\n  const { getVisibleAttributes, getTimestamps, getCreatorFields } = contentTypesUtils;\r\n\r\n  // only get attributes that can be seen in the auto generated Edit view or List view\r\n  return getVisibleAttributes(contentType)\r\n    .concat(getTimestamps(contentType))\r\n    .concat(getCreatorFields(contentType))\r\n    .reduce((acc: any, key: string) => {\r\n      const attribute = contentType.attributes[key];\r\n\r\n      // ignore morph until they are handled in the front\r\n      if (attribute.type === 'relation' && attribute.relation.toLowerCase().includes('morph')) {\r\n        return acc;\r\n      }\r\n\r\n      acc[key] = formatAttribute(key, attribute);\r\n      return acc;\r\n    }, {});\r\n};\r\n\r\n// FIXME: not needed\r\nconst formatAttribute = (key: any, attribute: Schema.Attribute.AnyAttribute) => {\r\n  if (attribute.type === 'relation') {\r\n    return toRelation(attribute);\r\n  }\r\n\r\n  return attribute;\r\n};\r\n\r\n// FIXME: not needed\r\nconst toRelation = (attribute: Schema.Attribute.Relation) => {\r\n  return {\r\n    ...attribute,\r\n    type: 'relation',\r\n    targetModel: 'target' in attribute ? attribute.target : undefined,\r\n    relationType: attribute.relation,\r\n  };\r\n};\r\n\r\nconst isVisible = (model: Struct.ComponentSchema): boolean =>\r\n  getOr(true, 'pluginOptions.content-manager.visible', model) === true;\r\n","import { errors } from '@strapi/utils';\r\nimport type { Core, Modules } from '@strapi/types';\r\n\r\nconst { ApplicationError } = errors;\r\n\r\ntype FieldSize = Modules.CustomFields.CustomFieldServerOptions['inputSize'];\r\n\r\nconst needsFullSize: FieldSize = {\r\n  default: 12,\r\n  isResizable: false,\r\n};\r\n\r\nconst smallSize: FieldSize = {\r\n  default: 4,\r\n  isResizable: true,\r\n};\r\n\r\nconst defaultSize: FieldSize = {\r\n  default: 6,\r\n  isResizable: true,\r\n};\r\n\r\nconst fieldSizes: Record<string, FieldSize> = {\r\n  // Full row and not resizable\r\n  dynamiczone: needsFullSize,\r\n  component: needsFullSize,\r\n  json: needsFullSize,\r\n  richtext: needsFullSize,\r\n  blocks: needsFullSize,\r\n  // Small and resizable\r\n  checkbox: smallSize,\r\n  boolean: smallSize,\r\n  date: smallSize,\r\n  time: smallSize,\r\n  biginteger: smallSize,\r\n  decimal: smallSize,\r\n  float: smallSize,\r\n  integer: smallSize,\r\n  number: smallSize,\r\n  // Medium and resizable\r\n  datetime: defaultSize,\r\n  email: defaultSize,\r\n  enumeration: defaultSize,\r\n  media: defaultSize,\r\n  password: defaultSize,\r\n  relation: defaultSize,\r\n  string: defaultSize,\r\n  text: defaultSize,\r\n  timestamp: defaultSize,\r\n  uid: defaultSize,\r\n};\r\n\r\nconst createFieldSizesService = ({ strapi }: { strapi: Core.Strapi }) => {\r\n  const fieldSizesService = {\r\n    getAllFieldSizes() {\r\n      return fieldSizes;\r\n    },\r\n\r\n    hasFieldSize(type: string) {\r\n      return !!fieldSizes[type];\r\n    },\r\n\r\n    getFieldSize(type?: string) {\r\n      if (!type) {\r\n        throw new ApplicationError('The type is required');\r\n      }\r\n\r\n      const fieldSize = fieldSizes[type];\r\n      if (!fieldSize) {\r\n        throw new ApplicationError(`Could not find field size for type ${type}`);\r\n      }\r\n\r\n      return fieldSize;\r\n    },\r\n\r\n    setFieldSize(type: string, size: FieldSize) {\r\n      if (!type) {\r\n        throw new ApplicationError('The type is required');\r\n      }\r\n\r\n      if (!size) {\r\n        throw new ApplicationError('The size is required');\r\n      }\r\n\r\n      fieldSizes[type] = size;\r\n    },\r\n\r\n    setCustomFieldInputSizes() {\r\n      // Find all custom fields already registered\r\n      const customFields = strapi.get('custom-fields').getAll();\r\n\r\n      // If they have a custom field size, register it\r\n      // TODO types can be inferred when customFields is typed\r\n      Object.entries(customFields).forEach(([uid, customField]: [string, any]) => {\r\n        if (customField.inputSize) {\r\n          fieldSizesService.setFieldSize(uid, customField.inputSize);\r\n        }\r\n      });\r\n    },\r\n  };\r\n\r\n  return fieldSizesService;\r\n};\r\n\r\nexport default createFieldSizesService;\r\n","import { intersection, prop } from 'lodash/fp';\r\nimport { relations } from '@strapi/utils';\r\nimport type { Core, Struct } from '@strapi/types';\r\nimport type { Configuration } from '../../../shared/contracts/content-types';\r\n\r\nconst { getRelationalFields } = relations;\r\n\r\nexport default ({ strapi }: { strapi: Core.Strapi }) => {\r\n  const sendDidConfigureListView = async (\r\n    contentType: Struct.ContentTypeSchema,\r\n    configuration: Configuration\r\n  ) => {\r\n    const displayedFields = prop('length', configuration.layouts.list);\r\n    const relationalFields = getRelationalFields(contentType);\r\n    const displayedRelationalFields = intersection(\r\n      relationalFields,\r\n      configuration.layouts.list\r\n    ).length;\r\n\r\n    const data = {\r\n      eventProperties: { containsRelationalFields: !!displayedRelationalFields },\r\n    };\r\n\r\n    if (data.eventProperties.containsRelationalFields) {\r\n      Object.assign(data.eventProperties, {\r\n        displayedFields,\r\n        displayedRelationalFields,\r\n      });\r\n    }\r\n\r\n    try {\r\n      await strapi.telemetry.send('didConfigureListView', data);\r\n    } catch (e) {\r\n      // silence\r\n    }\r\n  };\r\n\r\n  return {\r\n    sendDidConfigureListView,\r\n  };\r\n};\r\n","import { async } from '@strapi/utils';\r\nimport type { Core, UID, Modules } from '@strapi/types';\r\n\r\nconst ACTIONS = {\r\n  read: 'plugin::content-manager.explorer.read',\r\n  create: 'plugin::content-manager.explorer.create',\r\n  update: 'plugin::content-manager.explorer.update',\r\n  delete: 'plugin::content-manager.explorer.delete',\r\n  publish: 'plugin::content-manager.explorer.publish',\r\n  unpublish: 'plugin::content-manager.explorer.publish',\r\n  discard: 'plugin::content-manager.explorer.update',\r\n} as const;\r\n\r\ntype Entity = Modules.EntityService.Result<UID.ContentType>;\r\ntype Query = {\r\n  page?: string;\r\n  pageSize?: string;\r\n  sort?: string;\r\n};\r\n\r\nconst createPermissionChecker =\r\n  (strapi: Core.Strapi) =>\r\n  ({ userAbility, model }: { userAbility: any; model: string }) => {\r\n    const permissionsManager = strapi.service('admin::permission').createPermissionsManager({\r\n      ability: userAbility,\r\n      model,\r\n    });\r\n\r\n    const { actionProvider } = strapi.service('admin::permission');\r\n\r\n    const toSubject = (entity?: Entity) => {\r\n      return entity ? permissionsManager.toSubject(entity, model) : model;\r\n    };\r\n\r\n    // @ts-expect-error preserve the parameter order\r\n    // eslint-disable-next-line @typescript-eslint/default-param-last\r\n    const can = (action: string, entity?: Entity, field: string) => {\r\n      const subject = toSubject(entity);\r\n      const aliases = actionProvider.unstable_aliases(action, model) as string[];\r\n\r\n      return (\r\n        // Test the original action to see if it passes\r\n        userAbility.can(action, subject, field) ||\r\n        // Else try every known alias if at least one of them succeed, then the user \"can\"\r\n        aliases.some((alias) => userAbility.can(alias, subject, field))\r\n      );\r\n    };\r\n\r\n    // @ts-expect-error preserve the parameter order\r\n    // eslint-disable-next-line @typescript-eslint/default-param-last\r\n    const cannot = (action: string, entity?: Entity, field: string) => {\r\n      const subject = toSubject(entity);\r\n      const aliases = actionProvider.unstable_aliases(action, model) as string[];\r\n\r\n      return (\r\n        // Test both the original action\r\n        userAbility.cannot(action, subject, field) &&\r\n        // and every known alias, if all of them fail (cannot), then the user truly \"cannot\"\r\n        aliases.every((alias) => userAbility.cannot(alias, subject, field))\r\n      );\r\n    };\r\n\r\n    const sanitizeOutput = (data: Entity, { action = ACTIONS.read }: { action?: string } = {}) => {\r\n      return permissionsManager.sanitizeOutput(data, { subject: toSubject(data), action });\r\n    };\r\n\r\n    const sanitizeQuery = (query: Query, { action = ACTIONS.read }: { action?: string } = {}) => {\r\n      return permissionsManager.sanitizeQuery(query, { subject: model, action });\r\n    };\r\n\r\n    const sanitizeInput = (action: string, data: any, entity?: Entity) => {\r\n      return permissionsManager.sanitizeInput(data, {\r\n        subject: entity ? toSubject(entity) : model,\r\n        action,\r\n      });\r\n    };\r\n\r\n    const validateQuery = (query: Query, { action = ACTIONS.read }: { action?: string } = {}) => {\r\n      return permissionsManager.validateQuery(query, { subject: model, action });\r\n    };\r\n\r\n    const validateInput = (action: string, data: any, entity?: Entity) => {\r\n      return permissionsManager.validateInput(data, {\r\n        subject: entity ? toSubject(entity) : model,\r\n        action,\r\n      });\r\n    };\r\n\r\n    const sanitizeCreateInput = (data: any) => sanitizeInput(ACTIONS.create, data);\r\n    const sanitizeUpdateInput = (entity: Entity) => (data: any) =>\r\n      sanitizeInput(ACTIONS.update, data, entity);\r\n\r\n    const buildPermissionQuery = (query: Query, action: { action?: string } = {}) => {\r\n      return permissionsManager.addPermissionsQueryTo(query, action);\r\n    };\r\n\r\n    const sanitizedQuery = (query: Query, action: { action?: string } = {}) => {\r\n      return async.pipe(\r\n        (q: Query) => sanitizeQuery(q, action),\r\n        (q: Query) => buildPermissionQuery(q, action)\r\n      )(query);\r\n    };\r\n\r\n    // Sanitized queries shortcuts\r\n    Object.keys(ACTIONS).forEach((action) => {\r\n      // @ts-expect-error TODO\r\n      sanitizedQuery[action] = (query: Query) => sanitizedQuery(query, ACTIONS[action]);\r\n    });\r\n\r\n    // Permission utils shortcuts\r\n    Object.keys(ACTIONS).forEach((action) => {\r\n      // @ts-expect-error TODO\r\n      can[action] = (...args: any) => can(ACTIONS[action], ...args);\r\n      // @ts-expect-error TODO\r\n      cannot[action] = (...args: any) => cannot(ACTIONS[action], ...args);\r\n    });\r\n\r\n    return {\r\n      // Permission utils\r\n      can, // check if you have the permission\r\n      cannot, // check if you don't have the permission\r\n      // Sanitizers\r\n      sanitizeOutput,\r\n      sanitizeQuery,\r\n      sanitizeCreateInput,\r\n      sanitizeUpdateInput,\r\n      // Validators\r\n      validateQuery,\r\n      validateInput,\r\n      // Queries Builder\r\n      sanitizedQuery,\r\n    };\r\n  };\r\n\r\nexport default ({ strapi }: { strapi: Core.Strapi }) => ({\r\n  create: createPermissionChecker(strapi),\r\n});\r\n","import { prop } from 'lodash/fp';\r\nimport { contentTypes as contentTypesUtils } from '@strapi/utils';\r\n\r\nimport type { Core, Struct } from '@strapi/types';\r\nimport { getService } from '../utils';\r\n\r\nexport default ({ strapi }: { strapi: Core.Strapi }) => ({\r\n  canConfigureContentType({\r\n    userAbility,\r\n    contentType,\r\n  }: {\r\n    userAbility: any;\r\n    contentType: Struct.ContentTypeSchema;\r\n  }) {\r\n    const action = contentTypesUtils.isSingleType(contentType)\r\n      ? 'plugin::content-manager.single-types.configure-view'\r\n      : 'plugin::content-manager.collection-types.configure-view';\r\n\r\n    return userAbility.can(action);\r\n  },\r\n\r\n  async registerPermissions() {\r\n    const displayedContentTypes = getService('content-types').findDisplayedContentTypes();\r\n    const contentTypesUids = displayedContentTypes.map(prop('uid'));\r\n\r\n    const actions = [\r\n      {\r\n        section: 'contentTypes',\r\n        displayName: 'Create',\r\n        uid: 'explorer.create',\r\n        pluginName: 'content-manager',\r\n        subjects: contentTypesUids,\r\n        options: {\r\n          applyToProperties: ['fields'],\r\n        },\r\n      },\r\n      {\r\n        section: 'contentTypes',\r\n        displayName: 'Read',\r\n        uid: 'explorer.read',\r\n        pluginName: 'content-manager',\r\n        subjects: contentTypesUids,\r\n        options: {\r\n          applyToProperties: ['fields'],\r\n        },\r\n      },\r\n      {\r\n        section: 'contentTypes',\r\n        displayName: 'Update',\r\n        uid: 'explorer.update',\r\n        pluginName: 'content-manager',\r\n        subjects: contentTypesUids,\r\n        options: {\r\n          applyToProperties: ['fields'],\r\n        },\r\n      },\r\n      {\r\n        section: 'contentTypes',\r\n        displayName: 'Delete',\r\n        uid: 'explorer.delete',\r\n        pluginName: 'content-manager',\r\n        subjects: contentTypesUids,\r\n      },\r\n      {\r\n        section: 'contentTypes',\r\n        displayName: 'Publish',\r\n        uid: 'explorer.publish',\r\n        pluginName: 'content-manager',\r\n        subjects: contentTypesUids,\r\n      },\r\n      {\r\n        section: 'plugins',\r\n        displayName: 'Configure view',\r\n        uid: 'single-types.configure-view',\r\n        subCategory: 'single types',\r\n        pluginName: 'content-manager',\r\n      },\r\n      {\r\n        section: 'plugins',\r\n        displayName: 'Configure view',\r\n        uid: 'collection-types.configure-view',\r\n        subCategory: 'collection types',\r\n        pluginName: 'content-manager',\r\n      },\r\n      {\r\n        section: 'plugins',\r\n        displayName: 'Configure Layout',\r\n        uid: 'components.configure-layout',\r\n        subCategory: 'components',\r\n        pluginName: 'content-manager',\r\n      },\r\n    ];\r\n\r\n    await strapi.service('admin::permission').actionProvider.registerMany(actions);\r\n  },\r\n});\r\n","import { merge, isEmpty, set, propEq } from 'lodash/fp';\r\nimport strapiUtils from '@strapi/utils';\r\nimport { UID, Schema, Modules } from '@strapi/types';\r\nimport { getService } from '../../utils';\r\n\r\nconst { isVisibleAttribute, isScalarAttribute, getDoesAttributeRequireValidation } =\r\n  strapiUtils.contentTypes;\r\nconst { isAnyToMany } = strapiUtils.relations;\r\nconst { PUBLISHED_AT_ATTRIBUTE } = strapiUtils.contentTypes.constants;\r\n\r\nconst isMorphToRelation = (attribute: any) =>\r\n  isRelation(attribute) && attribute.relation.includes('morphTo');\r\nconst isMedia = propEq('type', 'media');\r\nconst isRelation = propEq('type', 'relation');\r\nconst isComponent = propEq('type', 'component');\r\nconst isDynamicZone = propEq('type', 'dynamiczone');\r\n\r\n// TODO: Import from @strapi/types when it's available there\r\ntype Model = Parameters<typeof isVisibleAttribute>[0];\r\nexport type Populate = Modules.EntityService.Params.Populate.Any<UID.Schema>;\r\n\r\ntype PopulateOptions = {\r\n  initialPopulate?: Populate;\r\n  countMany?: boolean;\r\n  countOne?: boolean;\r\n  maxLevel?: number;\r\n};\r\n\r\n/**\r\n * Populate the model for relation\r\n * @param attribute - Attribute containing a relation\r\n * @param attribute.relation - type of relation\r\n * @param model - Model of the populated entity\r\n * @param attributeName\r\n * @param options - Options to apply while populating\r\n */\r\nfunction getPopulateForRelation(\r\n  attribute: Schema.Attribute.AnyAttribute,\r\n  model: Model,\r\n  attributeName: string,\r\n  { countMany, countOne, initialPopulate }: PopulateOptions\r\n) {\r\n  const isManyRelation = isAnyToMany(attribute);\r\n\r\n  if (initialPopulate) {\r\n    return initialPopulate;\r\n  }\r\n\r\n  // always populate createdBy, updatedBy, localizations etc.\r\n  if (!isVisibleAttribute(model, attributeName)) {\r\n    return true;\r\n  }\r\n\r\n  if ((isManyRelation && countMany) || (!isManyRelation && countOne)) {\r\n    return { count: true };\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Populate the model for Dynamic Zone components\r\n * @param attribute - Attribute containing the components\r\n * @param attribute.components - IDs of components\r\n * @param options - Options to apply while populating\r\n */\r\nfunction getPopulateForDZ(\r\n  attribute: Schema.Attribute.DynamicZone,\r\n  options: PopulateOptions,\r\n  level: number\r\n) {\r\n  // Use fragments to populate the dynamic zone components\r\n  const populatedComponents = (attribute.components || []).reduce(\r\n    (acc: any, componentUID: UID.Component) => ({\r\n      ...acc,\r\n      [componentUID]: {\r\n        populate: getDeepPopulate(componentUID, options, level + 1),\r\n      },\r\n    }),\r\n    {}\r\n  );\r\n\r\n  return { on: populatedComponents };\r\n}\r\n\r\n/**\r\n * Get the populated value based on the type of the attribute\r\n * @param attributeName - Name of the attribute\r\n * @param model - Model of the populated entity\r\n * @param model.attributes\r\n * @param options - Options to apply while populating\r\n * @param options.countMany\r\n * @param options.countOne\r\n * @param options.maxLevel\r\n * @param level\r\n */\r\nfunction getPopulateFor(\r\n  attributeName: string,\r\n  model: any,\r\n  options: PopulateOptions,\r\n  level: number\r\n): { [key: string]: boolean | object } {\r\n  const attribute = model.attributes[attributeName];\r\n\r\n  switch (attribute.type) {\r\n    case 'relation':\r\n      // @ts-expect-error - TODO: support populate count typing\r\n      return {\r\n        [attributeName]: getPopulateForRelation(attribute, model, attributeName, options),\r\n      };\r\n    case 'component':\r\n      return {\r\n        [attributeName]: {\r\n          populate: getDeepPopulate(attribute.component, options, level + 1),\r\n        },\r\n      };\r\n    case 'media':\r\n      return {\r\n        [attributeName]: {\r\n          populate: {\r\n            folder: true,\r\n          },\r\n        },\r\n      };\r\n    case 'dynamiczone':\r\n      return {\r\n        [attributeName]: getPopulateForDZ(attribute, options, level),\r\n      };\r\n    default:\r\n      return {};\r\n  }\r\n}\r\n\r\n/**\r\n * Deeply populate a model based on UID\r\n * @param uid - Unique identifier of the model\r\n * @param options - Options to apply while populating\r\n * @param level - Current level of nested call\r\n */\r\nconst getDeepPopulate = (\r\n  uid: UID.Schema,\r\n  {\r\n    initialPopulate = {} as any,\r\n    countMany = false,\r\n    countOne = false,\r\n    maxLevel = Infinity,\r\n  }: PopulateOptions = {},\r\n  level = 1\r\n) => {\r\n  if (level > maxLevel) {\r\n    return {};\r\n  }\r\n\r\n  const model = strapi.getModel(uid);\r\n\r\n  return Object.keys(model.attributes).reduce(\r\n    (populateAcc, attributeName: string) =>\r\n      merge(\r\n        populateAcc,\r\n        getPopulateFor(\r\n          attributeName,\r\n          model,\r\n          {\r\n            // @ts-expect-error - improve types\r\n            initialPopulate: initialPopulate?.[attributeName],\r\n            countMany,\r\n            countOne,\r\n            maxLevel,\r\n          },\r\n          level\r\n        )\r\n      ),\r\n    {}\r\n  );\r\n};\r\n\r\n/**\r\n * Deeply populate a model based on UID. Only populating fields that require validation.\r\n * @param uid - Unique identifier of the model\r\n * @param options - Options to apply while populating\r\n * @param level - Current level of nested call\r\n */\r\nconst getValidatableFieldsPopulate = (\r\n  uid: UID.Schema,\r\n  {\r\n    initialPopulate = {} as any,\r\n    countMany = false,\r\n    countOne = false,\r\n    maxLevel = Infinity,\r\n  }: PopulateOptions = {},\r\n  level = 1\r\n) => {\r\n  if (level > maxLevel) {\r\n    return {};\r\n  }\r\n\r\n  const model = strapi.getModel(uid);\r\n\r\n  return Object.entries(model.attributes).reduce((populateAcc, [attributeName, attribute]) => {\r\n    if (!getDoesAttributeRequireValidation(attribute)) {\r\n      // If the attribute does not require validation, skip it\r\n      return populateAcc;\r\n    }\r\n\r\n    if (isScalarAttribute(attribute)) {\r\n      return merge(populateAcc, {\r\n        [attributeName]: true,\r\n      });\r\n    }\r\n\r\n    return merge(\r\n      populateAcc,\r\n      getPopulateFor(\r\n        attributeName,\r\n        model,\r\n        {\r\n          // @ts-expect-error - improve types\r\n          initialPopulate: initialPopulate?.[attributeName],\r\n          countMany,\r\n          countOne,\r\n          maxLevel,\r\n        },\r\n        level\r\n      )\r\n    );\r\n  }, {});\r\n};\r\n\r\n/**\r\n * getDeepPopulateDraftCount works recursively on the attributes of a model\r\n * creating a populated object to count all the unpublished relations within the model\r\n * These relations can be direct to this content type or contained within components/dynamic zones\r\n * @param  uid of the model\r\n * @returns result\r\n * @returns result.populate\r\n * @returns result.hasRelations\r\n */\r\nconst getDeepPopulateDraftCount = (uid: UID.Schema) => {\r\n  const model = strapi.getModel(uid);\r\n  let hasRelations = false;\r\n\r\n  const populate = Object.keys(model.attributes).reduce((populateAcc: any, attributeName) => {\r\n    const attribute: Schema.Attribute.AnyAttribute = model.attributes[attributeName];\r\n\r\n    switch (attribute.type) {\r\n      case 'relation': {\r\n        // TODO: Support polymorphic relations\r\n        const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');\r\n        if (isMorphRelation) {\r\n          break;\r\n        }\r\n\r\n        if (isVisibleAttribute(model, attributeName)) {\r\n          populateAcc[attributeName] = {\r\n            count: true,\r\n            filters: { [PUBLISHED_AT_ATTRIBUTE]: { $null: true } },\r\n          };\r\n          hasRelations = true;\r\n        }\r\n        break;\r\n      }\r\n      case 'component': {\r\n        const { populate, hasRelations: childHasRelations } = getDeepPopulateDraftCount(\r\n          attribute.component\r\n        );\r\n        if (childHasRelations) {\r\n          populateAcc[attributeName] = {\r\n            populate,\r\n          };\r\n          hasRelations = true;\r\n        }\r\n        break;\r\n      }\r\n      case 'dynamiczone': {\r\n        const dzPopulateFragment = attribute.components?.reduce((acc, componentUID) => {\r\n          const { populate: componentPopulate, hasRelations: componentHasRelations } =\r\n            getDeepPopulateDraftCount(componentUID);\r\n\r\n          if (componentHasRelations) {\r\n            hasRelations = true;\r\n\r\n            return { ...acc, [componentUID]: { populate: componentPopulate } };\r\n          }\r\n\r\n          return acc;\r\n        }, {});\r\n\r\n        if (!isEmpty(dzPopulateFragment)) {\r\n          populateAcc[attributeName] = { on: dzPopulateFragment };\r\n        }\r\n        break;\r\n      }\r\n      default:\r\n    }\r\n\r\n    return populateAcc;\r\n  }, {});\r\n\r\n  return { populate, hasRelations };\r\n};\r\n\r\n/**\r\n *  Create a Strapi populate object which populates all attribute fields of a Strapi query.\r\n */\r\nconst getQueryPopulate = async (uid: UID.Schema, query: object): Promise<Populate> => {\r\n  let populateQuery: Populate = {};\r\n\r\n  await strapiUtils.traverse.traverseQueryFilters(\r\n    /**\r\n     *\r\n     * @param {Object} param0\r\n     * @param {string} param0.key - Attribute name\r\n     * @param {Object} param0.attribute - Attribute definition\r\n     * @param {string} param0.path - Content Type path to the attribute\r\n     * @returns\r\n     */\r\n    ({ attribute, path }: any) => {\r\n      // TODO: handle dynamic zones and morph relations\r\n      if (!attribute || isDynamicZone(attribute) || isMorphToRelation(attribute)) {\r\n        return;\r\n      }\r\n\r\n      // Populate all relations, components and media\r\n      if (isRelation(attribute) || isMedia(attribute) || isComponent(attribute)) {\r\n        const populatePath = path.attribute.replace(/\\./g, '.populate.');\r\n        // @ts-expect-error - lodash doesn't resolve the Populate type correctly\r\n        populateQuery = set(populatePath, {}, populateQuery);\r\n      }\r\n    },\r\n    { schema: strapi.getModel(uid), getModel: strapi.getModel.bind(strapi) },\r\n    query\r\n  );\r\n\r\n  return populateQuery;\r\n};\r\n\r\nconst buildDeepPopulate = (uid: UID.CollectionType) => {\r\n  return getService('populate-builder')(uid).populateDeep(Infinity).countRelations().build();\r\n};\r\n\r\nexport {\r\n  getDeepPopulate,\r\n  getDeepPopulateDraftCount,\r\n  getQueryPopulate,\r\n  buildDeepPopulate,\r\n  getValidatableFieldsPopulate,\r\n};\r\n","import { isNil } from 'lodash/fp';\r\nimport type { UID } from '@strapi/types';\r\nimport { type Populate, getDeepPopulate, getQueryPopulate } from './utils/populate';\r\n\r\n/**\r\n * Builder to create a Strapi populate object.\r\n *\r\n * @param uid - Content type UID\r\n *\r\n * @example\r\n * const populate = await populateBuilder('api::article.article').countRelations().build();\r\n * // populate = { article: { populate: { count: true } } }\r\n *\r\n */\r\nconst populateBuilder = (uid: UID.Schema) => {\r\n  let getInitialPopulate = async (): Promise<undefined | Populate> => {\r\n    return undefined;\r\n  };\r\n  const deepPopulateOptions = {\r\n    countMany: false,\r\n    countOne: false,\r\n    maxLevel: -1,\r\n  };\r\n\r\n  const builder = {\r\n    /**\r\n     * Populates all attribute fields present in a query.\r\n     * @param query - Strapi query object\r\n     */\r\n    populateFromQuery(query: object) {\r\n      getInitialPopulate = async () => getQueryPopulate(uid, query);\r\n      return builder;\r\n    },\r\n\r\n    /**\r\n     * Populate relations as count.\r\n     * @param [options]\r\n     * @param [options.toMany] - Populate XtoMany relations as count if true.\r\n     * @param [options.toOne] - Populate XtoOne relations as count if true.\r\n     */\r\n    countRelations({ toMany, toOne } = { toMany: true, toOne: true }) {\r\n      if (!isNil(toMany)) {\r\n        deepPopulateOptions.countMany = toMany;\r\n      }\r\n      if (!isNil(toOne)) {\r\n        deepPopulateOptions.countOne = toOne;\r\n      }\r\n      return builder;\r\n    },\r\n\r\n    /**\r\n     * Populate relations deeply, up to a certain level.\r\n     * @param [level=Infinity] - Max level of nested populate.\r\n     */\r\n    populateDeep(level = Infinity) {\r\n      deepPopulateOptions.maxLevel = level;\r\n      return builder;\r\n    },\r\n\r\n    /**\r\n     * Construct the populate object based on the builder options.\r\n     * @returns Populate object\r\n     */\r\n    async build() {\r\n      const initialPopulate = await getInitialPopulate();\r\n\r\n      if (deepPopulateOptions.maxLevel === -1) {\r\n        return initialPopulate;\r\n      }\r\n\r\n      return getDeepPopulate(uid, { ...deepPopulateOptions, initialPopulate });\r\n    },\r\n  };\r\n\r\n  return builder;\r\n};\r\n\r\nexport default () => populateBuilder;\r\n","import _ from 'lodash';\r\nimport slugify from '@sindresorhus/slugify';\r\n\r\nimport type { Core, Schema, UID } from '@strapi/types';\r\n\r\nexport default ({ strapi }: { strapi: Core.Strapi }) => ({\r\n  async generateUIDField({\r\n    contentTypeUID,\r\n    field,\r\n    data,\r\n    locale,\r\n  }: {\r\n    contentTypeUID: UID.ContentType;\r\n    field: string;\r\n    data: Record<string, any>;\r\n    locale?: string;\r\n  }) {\r\n    const contentType = strapi.contentTypes[contentTypeUID];\r\n    const { attributes } = contentType;\r\n\r\n    const {\r\n      targetField,\r\n      default: defaultValue,\r\n      options,\r\n    } = attributes[field] as Schema.Attribute.UID;\r\n\r\n    // @ts-expect-error targetField can be undefined\r\n    const targetValue = _.get(data, targetField);\r\n\r\n    if (!_.isEmpty(targetValue)) {\r\n      return this.findUniqueUID({\r\n        contentTypeUID,\r\n        field,\r\n        value: slugify(targetValue, options),\r\n        locale,\r\n      });\r\n    }\r\n\r\n    return this.findUniqueUID({\r\n      contentTypeUID,\r\n      field,\r\n      value: slugify(\r\n        _.isFunction(defaultValue) ? defaultValue() : defaultValue || contentType.modelName,\r\n        options\r\n      ),\r\n      locale,\r\n    });\r\n  },\r\n\r\n  async findUniqueUID({\r\n    contentTypeUID,\r\n    field,\r\n    value,\r\n    locale,\r\n  }: {\r\n    contentTypeUID: UID.ContentType;\r\n    field: string;\r\n    value: string;\r\n    locale?: string;\r\n  }) {\r\n    const foundDocuments = await strapi.documents(contentTypeUID).findMany({\r\n      filters: {\r\n        [field]: { $startsWith: value },\r\n      },\r\n      locale,\r\n      // TODO: Check UX. When modifying an entry, it only makes sense to check for collisions with other drafts\r\n      // However, when publishing this \"available\" UID might collide with another published entry\r\n      status: 'draft',\r\n    });\r\n\r\n    if (!foundDocuments || foundDocuments.length === 0) {\r\n      // If there are no documents found we can return the value as is\r\n      return value;\r\n    }\r\n\r\n    let possibleCollisions: string[];\r\n    if (!Array.isArray(foundDocuments)) {\r\n      possibleCollisions = [foundDocuments[field]];\r\n    } else {\r\n      possibleCollisions = foundDocuments.map((doc: any) => doc[field]);\r\n    }\r\n\r\n    // If there are no documents sharing the proposed UID, we can return the value as is\r\n    if (!possibleCollisions.includes(value)) {\r\n      return value;\r\n    }\r\n\r\n    let i = 1;\r\n    let tmpUId = `${value}-${i}`;\r\n    while (possibleCollisions.includes(tmpUId)) {\r\n      // While there are documents sharing the proposed UID, we need to find a new one\r\n      // by incrementing the suffix until we find a unique one\r\n      i += 1;\r\n      tmpUId = `${value}-${i}`;\r\n    }\r\n\r\n    return tmpUId;\r\n  },\r\n\r\n  async checkUIDAvailability({\r\n    contentTypeUID,\r\n    field,\r\n    value,\r\n    locale,\r\n  }: {\r\n    contentTypeUID: UID.ContentType;\r\n    field: string;\r\n    value: string;\r\n    locale?: string;\r\n  }) {\r\n    const documentCount = await strapi.documents(contentTypeUID).count({\r\n      filters: {\r\n        [field]: value,\r\n      },\r\n      locale,\r\n      // TODO: Check UX. When modifying an entry, it only makes sense to check for collisions with other drafts\r\n      // However, when publishing this \"available\" UID might collide with another published entry\r\n      status: 'draft',\r\n    });\r\n\r\n    if (documentCount && documentCount > 0) {\r\n      // If there are documents sharing the proposed UID, we can return false\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  },\r\n});\r\n","import { groupBy, pick } from 'lodash/fp';\r\n\r\nimport { async, contentTypes, traverseEntity } from '@strapi/utils';\r\nimport type { Core, UID, Modules } from '@strapi/types';\r\n\r\nimport type { DocumentMetadata } from '../../../shared/contracts/collection-types';\r\nimport { getValidatableFieldsPopulate } from './utils/populate';\r\n\r\nexport interface DocumentVersion {\r\n  id: string | number;\r\n  documentId: Modules.Documents.ID;\r\n  locale?: string;\r\n  updatedAt?: string | null | Date;\r\n  publishedAt?: string | null | Date;\r\n}\r\n\r\nconst AVAILABLE_STATUS_FIELDS = [\r\n  'id',\r\n  'locale',\r\n  'updatedAt',\r\n  'createdAt',\r\n  'publishedAt',\r\n  'createdBy',\r\n  'updatedBy',\r\n  'status',\r\n];\r\nconst AVAILABLE_LOCALES_FIELDS = [\r\n  'id',\r\n  'locale',\r\n  'updatedAt',\r\n  'createdAt',\r\n  'status',\r\n  'publishedAt',\r\n  'documentId',\r\n];\r\n\r\nconst CONTENT_MANAGER_STATUS = {\r\n  PUBLISHED: 'published',\r\n  DRAFT: 'draft',\r\n  MODIFIED: 'modified',\r\n};\r\n\r\n/**\r\n * Controls the metadata properties to be returned\r\n *\r\n * If `availableLocales` is set to `true` (default), the returned metadata will include\r\n * the available locales of the document for its current status.\r\n *\r\n * If `availableStatus` is set to `true` (default), the returned metadata will include\r\n * the available status of the document for its current locale.\r\n */\r\nexport interface GetMetadataOptions {\r\n  availableLocales?: boolean;\r\n  availableStatus?: boolean;\r\n}\r\n\r\n/**\r\n * Checks if the provided document version has been modified after all other versions.\r\n */\r\nconst getIsVersionLatestModification = (\r\n  version?: DocumentVersion,\r\n  otherVersion?: DocumentVersion\r\n): boolean => {\r\n  if (!version || !version.updatedAt) {\r\n    return false;\r\n  }\r\n\r\n  const versionUpdatedAt = version?.updatedAt ? new Date(version.updatedAt).getTime() : 0;\r\n\r\n  const otherUpdatedAt = otherVersion?.updatedAt ? new Date(otherVersion.updatedAt).getTime() : 0;\r\n\r\n  return versionUpdatedAt > otherUpdatedAt;\r\n};\r\n\r\nexport default ({ strapi }: { strapi: Core.Strapi }) => ({\r\n  /**\r\n   * Returns available locales of a document for the current status\r\n   */\r\n  async getAvailableLocales(\r\n    uid: UID.ContentType,\r\n    version: DocumentVersion,\r\n    allVersions: DocumentVersion[],\r\n    validatableFields: string[] = []\r\n  ) {\r\n    // Group all versions by locale\r\n    const versionsByLocale = groupBy('locale', allVersions);\r\n\r\n    // Delete the current locale\r\n    if (version.locale) {\r\n      delete versionsByLocale[version.locale];\r\n    }\r\n\r\n    // For each locale, get the ones with the same status\r\n    // There will not be a draft and a version counterpart if the content\r\n    // type does not have draft and publish\r\n    const model = strapi.getModel(uid);\r\n    const keysToKeep = [...AVAILABLE_LOCALES_FIELDS, ...validatableFields];\r\n\r\n    const traversalFunction = async (localeVersion: DocumentVersion) =>\r\n      traverseEntity(\r\n        ({ key }, { remove }) => {\r\n          if (keysToKeep.includes(key)) {\r\n            // Keep the value if it is a field to pick\r\n            return;\r\n          }\r\n\r\n          // Otherwise remove this key from the data\r\n          remove(key);\r\n        },\r\n        { schema: model, getModel: strapi.getModel.bind(strapi) },\r\n        // @ts-expect-error fix types DocumentVersion incompatible with Data\r\n        localeVersion\r\n      );\r\n\r\n    const mappingResult = await async.map(\r\n      Object.values(versionsByLocale),\r\n      async (localeVersions: DocumentVersion[]) => {\r\n        const mappedLocaleVersions: DocumentVersion[] = await async.map(\r\n          localeVersions,\r\n          traversalFunction\r\n        );\r\n\r\n        if (!contentTypes.hasDraftAndPublish(model)) {\r\n          return mappedLocaleVersions[0];\r\n        }\r\n\r\n        const draftVersion = mappedLocaleVersions.find((v) => v.publishedAt === null);\r\n        const otherVersions = mappedLocaleVersions.filter((v) => v.id !== draftVersion?.id);\r\n\r\n        if (!draftVersion) {\r\n          return;\r\n        }\r\n\r\n        return {\r\n          ...draftVersion,\r\n          status: this.getStatus(draftVersion, otherVersions as any),\r\n        };\r\n      }\r\n    );\r\n\r\n    return (\r\n      mappingResult\r\n        // Filter just in case there is a document with no drafts\r\n        .filter(Boolean) as unknown as DocumentMetadata['availableLocales']\r\n    );\r\n  },\r\n\r\n  /**\r\n   * Returns available status of a document for the current locale\r\n   */\r\n  getAvailableStatus(version: DocumentVersion, allVersions: DocumentVersion[]) {\r\n    // Find the other status of the document\r\n    const status =\r\n      version.publishedAt !== null\r\n        ? CONTENT_MANAGER_STATUS.DRAFT\r\n        : CONTENT_MANAGER_STATUS.PUBLISHED;\r\n\r\n    // Get version that match the current locale and not match the current status\r\n    const availableStatus = allVersions.find((v) => {\r\n      const matchLocale = v.locale === version.locale;\r\n      const matchStatus = status === 'published' ? v.publishedAt !== null : v.publishedAt === null;\r\n      return matchLocale && matchStatus;\r\n    });\r\n\r\n    if (!availableStatus) return availableStatus;\r\n\r\n    // Pick status fields (at fields, status, by fields), use lodash fp\r\n    return pick(AVAILABLE_STATUS_FIELDS, availableStatus);\r\n  },\r\n  /**\r\n   * Get the available status of many documents, useful for batch operations\r\n   * @param uid\r\n   * @param documents\r\n   * @returns\r\n   */\r\n  async getManyAvailableStatus(uid: UID.ContentType, documents: DocumentVersion[]) {\r\n    if (!documents.length) return [];\r\n\r\n    // The status and locale of all documents should be the same\r\n    const status = documents[0].publishedAt !== null ? 'published' : 'draft';\r\n    const locale = documents[0]?.locale;\r\n    const otherStatus = status === 'published' ? 'draft' : 'published';\r\n\r\n    return strapi.documents(uid).findMany({\r\n      filters: {\r\n        documentId: { $in: documents.map((d) => d.documentId).filter(Boolean) },\r\n      },\r\n      status: otherStatus,\r\n      locale,\r\n      fields: ['documentId', 'locale', 'updatedAt', 'createdAt', 'publishedAt'],\r\n    }) as unknown as DocumentMetadata['availableStatus'];\r\n  },\r\n\r\n  getStatus(version: DocumentVersion, otherDocumentStatuses?: DocumentMetadata['availableStatus']) {\r\n    let draftVersion: DocumentVersion | undefined;\r\n    let publishedVersion: DocumentVersion | undefined;\r\n\r\n    if (version.publishedAt) {\r\n      publishedVersion = version;\r\n    } else {\r\n      draftVersion = version;\r\n    }\r\n\r\n    const otherVersion = otherDocumentStatuses?.at(0);\r\n    if (otherVersion?.publishedAt) {\r\n      publishedVersion = otherVersion;\r\n    } else if (otherVersion) {\r\n      draftVersion = otherVersion;\r\n    }\r\n\r\n    if (!draftVersion) return CONTENT_MANAGER_STATUS.PUBLISHED;\r\n    if (!publishedVersion) return CONTENT_MANAGER_STATUS.DRAFT;\r\n\r\n    /*\r\n     * The document is modified if the draft version has been updated more\r\n     * recently than the published version.\r\n     */\r\n    const isDraftModified = getIsVersionLatestModification(draftVersion, publishedVersion);\r\n    return isDraftModified ? CONTENT_MANAGER_STATUS.MODIFIED : CONTENT_MANAGER_STATUS.PUBLISHED;\r\n  },\r\n\r\n  // TODO is it necessary to return metadata on every page of the CM\r\n  // We could refactor this so the locales are only loaded when they're\r\n  // needed. e.g. in the bulk locale action modal.\r\n  async getMetadata(\r\n    uid: UID.ContentType,\r\n    version: DocumentVersion,\r\n    { availableLocales = true, availableStatus = true }: GetMetadataOptions = {}\r\n  ) {\r\n    // TODO: Ignore publishedAt if availableStatus=false, and ignore locale if\r\n    // i18n is disabled\r\n    const populate = getValidatableFieldsPopulate(uid);\r\n    const versions = await strapi.db.query(uid).findMany({\r\n      where: { documentId: version.documentId },\r\n      populate: {\r\n        // Populate only fields that require validation for bulk locale actions\r\n        ...populate,\r\n        // NOTE: creator fields are selected in this way to avoid exposing sensitive data\r\n        createdBy: {\r\n          select: ['id', 'firstname', 'lastname', 'email'],\r\n        },\r\n        updatedBy: {\r\n          select: ['id', 'firstname', 'lastname', 'email'],\r\n        },\r\n      },\r\n    });\r\n\r\n    const availableLocalesResult = availableLocales\r\n      ? await this.getAvailableLocales(uid, version, versions, Object.keys(populate))\r\n      : [];\r\n\r\n    const availableStatusResult = availableStatus\r\n      ? this.getAvailableStatus(version, versions)\r\n      : null;\r\n\r\n    return {\r\n      availableLocales: availableLocalesResult,\r\n      availableStatus: availableStatusResult ? [availableStatusResult] : [],\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Returns associated metadata of a document:\r\n   * - Available locales of the document for the current status\r\n   * - Available status of the document for the current locale\r\n   */\r\n  async formatDocumentWithMetadata(\r\n    uid: UID.ContentType,\r\n    document: DocumentVersion,\r\n    opts: GetMetadataOptions = {}\r\n  ) {\r\n    if (!document) {\r\n      return {\r\n        data: document,\r\n        meta: {\r\n          availableLocales: [],\r\n          availableStatus: [],\r\n        },\r\n      };\r\n    }\r\n\r\n    const hasDraftAndPublish = contentTypes.hasDraftAndPublish(strapi.getModel(uid));\r\n\r\n    // Ignore available status if the content type does not have draft and publish\r\n    if (!hasDraftAndPublish) {\r\n      opts.availableStatus = false;\r\n    }\r\n\r\n    const meta = await this.getMetadata(uid, document, opts);\r\n\r\n    return {\r\n      data: {\r\n        ...document,\r\n        // Add status to the document only if draft and publish is enabled\r\n        status: hasDraftAndPublish\r\n          ? this.getStatus(document, meta.availableStatus as any)\r\n          : undefined,\r\n      },\r\n      meta,\r\n    };\r\n  },\r\n});\r\n","import { castArray } from 'lodash/fp';\r\nimport strapiUtils from '@strapi/utils';\r\n\r\nconst { isVisibleAttribute } = strapiUtils.contentTypes;\r\n/**\r\n * sumDraftCounts works recursively on the attributes of a model counting the\r\n * number of draft relations\r\n * These relations can be direct to this content type or contained within components/dynamic zones\r\n * @param {Object} entity containing the draft relation counts\r\n * @param {String} uid of the content type\r\n * @returns {Number} of draft relations\r\n */\r\nconst sumDraftCounts = (entity: any, uid: any): number => {\r\n  const model = strapi.getModel(uid);\r\n\r\n  return Object.keys(model.attributes).reduce((sum, attributeName) => {\r\n    const attribute: any = model.attributes[attributeName];\r\n    const value = entity[attributeName];\r\n    if (!value) {\r\n      return sum;\r\n    }\r\n\r\n    switch (attribute.type) {\r\n      case 'relation': {\r\n        if (isVisibleAttribute(model, attributeName)) {\r\n          return sum + value.count;\r\n        }\r\n        return sum;\r\n      }\r\n      case 'component': {\r\n        const compoSum = castArray(value).reduce((acc, componentValue) => {\r\n          return acc + sumDraftCounts(componentValue, attribute.component);\r\n        }, 0);\r\n        return sum + compoSum;\r\n      }\r\n      case 'dynamiczone': {\r\n        const dzSum = value.reduce((acc: any, componentValue: any) => {\r\n          return acc + sumDraftCounts(componentValue, componentValue.__component);\r\n        }, 0);\r\n        return sum + dzSum;\r\n      }\r\n      default:\r\n        return sum;\r\n    }\r\n  }, 0);\r\n};\r\n\r\nexport { sumDraftCounts };\r\n","import { omit, pipe } from 'lodash/fp';\r\n\r\nimport { contentTypes, errors, pagination } from '@strapi/utils';\r\nimport type { Core, Modules, UID } from '@strapi/types';\r\n\r\nimport { buildDeepPopulate, getDeepPopulate, getDeepPopulateDraftCount } from './utils/populate';\r\nimport { sumDraftCounts } from './utils/draft';\r\n\r\ntype DocService = Modules.Documents.ServiceInstance;\r\ntype DocServiceParams<TAction extends keyof DocService> = Parameters<DocService[TAction]>[0];\r\nexport type Document = Modules.Documents.Result<UID.ContentType>;\r\n\r\nconst { ApplicationError } = errors;\r\nconst { PUBLISHED_AT_ATTRIBUTE } = contentTypes.constants;\r\n\r\nconst omitPublishedAtField = omit(PUBLISHED_AT_ATTRIBUTE);\r\nconst omitIdField = omit('id');\r\n\r\nconst documentManager = ({ strapi }: { strapi: Core.Strapi }) => {\r\n  return {\r\n    async findOne(\r\n      id: string,\r\n      uid: UID.CollectionType,\r\n      opts: Omit<DocServiceParams<'findOne'>, 'documentId'> = {}\r\n    ) {\r\n      return strapi.documents(uid).findOne({ ...opts, documentId: id });\r\n    },\r\n\r\n    /**\r\n     * Find multiple (or all) locales for a document\r\n     */\r\n    async findLocales(\r\n      id: string | string[] | undefined,\r\n      uid: UID.CollectionType,\r\n      opts: {\r\n        populate?: Modules.Documents.Params.Pick<any, 'populate'>;\r\n        locale?: string | string[] | '*';\r\n        isPublished?: boolean;\r\n      }\r\n    ) {\r\n      // Will look for a specific locale by default\r\n      const where: any = {};\r\n\r\n      // Might not have an id if querying a single type\r\n      if (id) {\r\n        where.documentId = id;\r\n      }\r\n\r\n      // Search in array of locales\r\n      if (Array.isArray(opts.locale)) {\r\n        where.locale = { $in: opts.locale };\r\n      } else if (opts.locale && opts.locale !== '*') {\r\n        // Look for a specific locale, ignore if looking for all locales\r\n        where.locale = opts.locale;\r\n      }\r\n\r\n      // Published is passed, so we filter on it, otherwise we don't filter\r\n      if (typeof opts.isPublished === 'boolean') {\r\n        where.publishedAt = { $notNull: opts.isPublished };\r\n      }\r\n\r\n      return strapi.db.query(uid).findMany({ populate: opts.populate, where });\r\n    },\r\n\r\n    async findMany(opts: DocServiceParams<'findMany'>, uid: UID.CollectionType) {\r\n      const params = { ...opts, populate: getDeepPopulate(uid) } as typeof opts;\r\n      return strapi.documents(uid).findMany(params);\r\n    },\r\n\r\n    async findPage(opts: DocServiceParams<'findMany'>, uid: UID.CollectionType) {\r\n      const params = pagination.withDefaultPagination(opts || {}, {\r\n        maxLimit: 1000,\r\n      });\r\n\r\n      const [documents, total = 0] = await Promise.all([\r\n        strapi.documents(uid).findMany(params),\r\n        strapi.documents(uid).count(params),\r\n      ]);\r\n\r\n      return {\r\n        results: documents,\r\n        pagination: pagination.transformPagedPaginationInfo(params, total),\r\n      };\r\n    },\r\n\r\n    async create(uid: UID.CollectionType, opts: DocServiceParams<'create'> = {} as any) {\r\n      const populate = opts.populate ?? (await buildDeepPopulate(uid));\r\n      const params = { ...opts, status: 'draft' as const, populate };\r\n\r\n      return strapi.documents(uid).create(params);\r\n    },\r\n\r\n    async update(\r\n      id: Modules.Documents.ID,\r\n      uid: UID.CollectionType,\r\n      opts: Omit<DocServiceParams<'update'>, 'documentId'> = {} as any\r\n    ) {\r\n      const publishData = pipe(omitPublishedAtField, omitIdField)(opts.data || {});\r\n      const populate = opts.populate ?? (await buildDeepPopulate(uid));\r\n      const params = { ...opts, data: publishData, populate, status: 'draft' };\r\n\r\n      return strapi.documents(uid).update({ ...params, documentId: id });\r\n    },\r\n\r\n    async clone(\r\n      id: Modules.Documents.ID,\r\n      body: Partial<Modules.Documents.Params.Data.Input<UID.CollectionType>>,\r\n      uid: UID.CollectionType\r\n    ) {\r\n      const populate = await buildDeepPopulate(uid);\r\n      const params = {\r\n        data: omitIdField(body),\r\n        populate,\r\n      };\r\n\r\n      return strapi\r\n        .documents(uid)\r\n        .clone({ ...params, documentId: id })\r\n        .then((result) => result?.entries.at(0));\r\n    },\r\n\r\n    /**\r\n     *  Check if a document exists\r\n     */\r\n    async exists(uid: UID.CollectionType, id?: string) {\r\n      // Collection type\r\n      if (id) {\r\n        const count = await strapi.db.query(uid).count({ where: { documentId: id } });\r\n        return count > 0;\r\n      }\r\n\r\n      // Single type\r\n      const count = await strapi.db.query(uid).count();\r\n      return count > 0;\r\n    },\r\n\r\n    async delete(\r\n      id: Modules.Documents.ID,\r\n      uid: UID.CollectionType,\r\n      opts: Omit<DocServiceParams<'delete'>, 'documentId'> = {} as any\r\n    ) {\r\n      const populate = await buildDeepPopulate(uid);\r\n\r\n      await strapi.documents(uid).delete({\r\n        ...opts,\r\n        documentId: id,\r\n        populate,\r\n      });\r\n      return {};\r\n    },\r\n\r\n    // FIXME: handle relations\r\n    async deleteMany(\r\n      documentIds: Modules.Documents.ID[],\r\n      uid: UID.CollectionType,\r\n      opts: DocServiceParams<'findMany'> & { locale?: string } = {}\r\n    ) {\r\n      const deletedEntries = await strapi.db.transaction(async () => {\r\n        return Promise.all(documentIds.map(async (id) => this.delete(id, uid, opts)));\r\n      });\r\n\r\n      return { count: deletedEntries.length };\r\n    },\r\n\r\n    async publish(\r\n      id: Modules.Documents.ID,\r\n      uid: UID.CollectionType,\r\n      opts: Omit<DocServiceParams<'publish'>, 'documentId'> = {} as any\r\n    ) {\r\n      const populate = await buildDeepPopulate(uid);\r\n      const params = { ...opts, populate };\r\n\r\n      return strapi\r\n        .documents(uid)\r\n        .publish({ ...params, documentId: id })\r\n        .then((result) => result?.entries);\r\n    },\r\n\r\n    async publishMany(uid: UID.ContentType, documentIds: string[], locale?: string | string[]) {\r\n      return strapi.db.transaction(async () => {\r\n        const results = await Promise.all(\r\n          documentIds.map((documentId) => this.publish(documentId, uid, { locale }))\r\n        );\r\n\r\n        const publishedEntitiesCount = results.flat().filter(Boolean).length;\r\n        return publishedEntitiesCount;\r\n      });\r\n    },\r\n\r\n    async unpublishMany(\r\n      documentIds: Modules.Documents.ID[],\r\n      uid: UID.CollectionType,\r\n      opts: Omit<DocServiceParams<'unpublish'>, 'documentId'> = {} as any\r\n    ) {\r\n      const unpublishedEntries = await strapi.db.transaction(async () => {\r\n        return Promise.all(\r\n          documentIds.map((id) =>\r\n            strapi\r\n              .documents(uid)\r\n              .unpublish({ ...opts, documentId: id })\r\n              .then((result) => result?.entries)\r\n          )\r\n        );\r\n      });\r\n\r\n      const unpublishedEntitiesCount = unpublishedEntries.flat().filter(Boolean).length;\r\n\r\n      // Return the number of unpublished entities\r\n      return { count: unpublishedEntitiesCount };\r\n    },\r\n\r\n    async unpublish(\r\n      id: Modules.Documents.ID,\r\n      uid: UID.CollectionType,\r\n      opts: Omit<DocServiceParams<'unpublish'>, 'documentId'> = {} as any\r\n    ) {\r\n      const populate = await buildDeepPopulate(uid);\r\n      const params = { ...opts, populate };\r\n\r\n      return strapi\r\n        .documents(uid)\r\n        .unpublish({ ...params, documentId: id })\r\n        .then((result) => result?.entries.at(0));\r\n    },\r\n\r\n    async discardDraft(\r\n      id: Modules.Documents.ID,\r\n      uid: UID.CollectionType,\r\n      opts: Omit<DocServiceParams<'discardDraft'>, 'documentId'> = {} as any\r\n    ) {\r\n      const populate = await buildDeepPopulate(uid);\r\n      const params = { ...opts, populate };\r\n\r\n      return strapi\r\n        .documents(uid)\r\n        .discardDraft({ ...params, documentId: id })\r\n        .then((result) => result?.entries.at(0));\r\n    },\r\n\r\n    async countDraftRelations(id: string, uid: UID.ContentType, locale: string) {\r\n      const { populate, hasRelations } = getDeepPopulateDraftCount(uid);\r\n\r\n      if (!hasRelations) {\r\n        return 0;\r\n      }\r\n\r\n      const document = await strapi.documents(uid).findOne({ documentId: id, populate, locale });\r\n      if (!document) {\r\n        throw new ApplicationError(\r\n          `Unable to count draft relations, document with id ${id} and locale ${locale} not found`\r\n        );\r\n      }\r\n\r\n      return sumDraftCounts(document, uid);\r\n    },\r\n\r\n    async countManyEntriesDraftRelations(\r\n      documentIds: Modules.Documents.ID[],\r\n      uid: UID.CollectionType,\r\n      locale: string | string[]\r\n    ) {\r\n      const { populate, hasRelations } = getDeepPopulateDraftCount(uid);\r\n\r\n      if (!hasRelations) {\r\n        return 0;\r\n      }\r\n\r\n      let localeFilter = {};\r\n      if (locale) {\r\n        localeFilter = Array.isArray(locale) ? { locale: { $in: locale } } : { locale };\r\n      }\r\n\r\n      const entities = await strapi.db.query(uid).findMany({\r\n        populate,\r\n        where: {\r\n          documentId: { $in: documentIds },\r\n          ...localeFilter,\r\n        },\r\n      });\r\n\r\n      const totalNumberDraftRelations: number = entities!.reduce(\r\n        (count: number, entity: Document) => sumDraftCounts(entity, uid) + count,\r\n        0\r\n      );\r\n\r\n      return totalNumberDraftRelations;\r\n    },\r\n  };\r\n};\r\n\r\nexport type DocumentManagerService = typeof documentManager;\r\n\r\nexport default documentManager;\r\n","import components from './components';\r\nimport contentTypes from './content-types';\r\nimport dataMapper from './data-mapper';\r\nimport fieldSizes from './field-sizes';\r\nimport metrics from './metrics';\r\nimport permissionChecker from './permission-checker';\r\nimport permission from './permission';\r\nimport populateBuilder from './populate-builder';\r\nimport uid from './uid';\r\nimport history from '../history';\r\nimport preview from '../preview';\r\nimport documentMetadata from './document-metadata';\r\nimport documentManager from './document-manager';\r\n\r\nexport default {\r\n  components,\r\n  'content-types': contentTypes,\r\n  'data-mapper': dataMapper,\r\n  'document-metadata': documentMetadata,\r\n  'document-manager': documentManager,\r\n  'field-sizes': fieldSizes,\r\n  metrics,\r\n  'permission-checker': permissionChecker,\r\n  permission,\r\n  'populate-builder': populateBuilder,\r\n  uid,\r\n  ...(history.services ? history.services : {}),\r\n  ...(preview.services ? preview.services : {}),\r\n};\r\n","import register from './register';\r\nimport bootstrap from './bootstrap';\r\nimport destroy from './destroy';\r\nimport routes from './routes';\r\nimport policies from './policies';\r\nimport controllers from './controllers';\r\nimport services from './services';\r\n\r\nexport default () => {\r\n  return {\r\n    register,\r\n    bootstrap,\r\n    destroy,\r\n    controllers,\r\n    routes,\r\n    policies,\r\n    services,\r\n  };\r\n};\r\n"],"names":["getService","strapi","permissionChecker","getContentManagerService","pagination","controllers","getDeepPopulate","uid","isVisible","contentTypes","acc","data","services","info","routes","getFeature","action","yup","contentTypesUtils","PUBLISHED_AT_ATTRIBUTE","isHidden","isRelation","schema","key","isVisibleAttribute","path","body","documentMetadata","documentManager","isNil","document","components","relations","isComponent","mainField","res","keys","storeUtils","conf","intersection","difference","configurationService","ApplicationError","populate","count","fieldSizes","populateBuilder"],"mappings":"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"}