{"version":3,"file":"relations-CBc5HYHC.mjs","sources":["../../admin/src/services/relations.ts","../../admin/src/utils/relations.ts"],"sourcesContent":["import { generateNKeysBetween } from 'fractional-indexing';\r\n\r\nimport {\r\n  RelationResult as RelResult,\r\n  FindAvailable,\r\n  FindExisting,\r\n} from '../../../shared/contracts/relations';\r\n\r\nimport { contentManagerApi } from './api';\r\n\r\nimport type { Modules } from '@strapi/types';\r\nimport type { errors } from '@strapi/utils';\r\n\r\ninterface RelationResult extends RelResult {\r\n  __temp_key__: string;\r\n}\r\n\r\ntype GetRelationsResponse =\r\n  | {\r\n      results: Array<RelationResult>;\r\n      pagination: {\r\n        page: NonNullable<Modules.EntityService.Params.Pagination.PageNotation['page']>;\r\n        pageSize: NonNullable<Modules.EntityService.Params.Pagination.PageNotation['pageSize']>;\r\n        pageCount: number;\r\n        total: number;\r\n      } | null;\r\n      error?: never;\r\n    }\r\n  | {\r\n      results?: never;\r\n      pagination?: never;\r\n      error: errors.ApplicationError | errors.YupValidationError;\r\n    };\r\n\r\nconst relationsApi = contentManagerApi.injectEndpoints({\r\n  endpoints: (build) => ({\r\n    getRelations: build.query<\r\n      GetRelationsResponse,\r\n      FindExisting.Params & {\r\n        params?: FindExisting.Request['query'];\r\n      }\r\n    >({\r\n      query: ({ model, id, targetField, params }) => {\r\n        return {\r\n          url: `/content-manager/relations/${model}/${id}/${targetField}`,\r\n          method: 'GET',\r\n          config: {\r\n            params,\r\n          },\r\n        };\r\n      },\r\n      serializeQueryArgs: (args) => {\r\n        const { endpointName, queryArgs } = args;\r\n        return {\r\n          endpointName,\r\n          model: queryArgs.model,\r\n          id: queryArgs.id,\r\n          targetField: queryArgs.targetField,\r\n          locale: queryArgs.params?.locale,\r\n          status: queryArgs.params?.status,\r\n        };\r\n      },\r\n      merge: (currentCache, newItems) => {\r\n        if (currentCache.pagination && newItems.pagination) {\r\n          if (currentCache.pagination.page < newItems.pagination.page) {\r\n            /**\r\n             * Relations will always have unique IDs, so we can therefore assume\r\n             * that we only need to push the new items to the cache.\r\n             *\r\n             * Push new items at the beginning as latest items are shown first\r\n             */\r\n            currentCache.results = [\r\n              ...prepareTempKeys(newItems.results, currentCache.results),\r\n              ...currentCache.results,\r\n            ];\r\n            currentCache.pagination = newItems.pagination;\r\n          } else if (newItems.pagination.page === 1) {\r\n            /**\r\n             * We're resetting the relations\r\n             */\r\n            currentCache.results = prepareTempKeys(newItems.results);\r\n            currentCache.pagination = newItems.pagination;\r\n          }\r\n        }\r\n      },\r\n      forceRefetch({ currentArg, previousArg }) {\r\n        if (!currentArg?.params && !previousArg?.params) {\r\n          return false;\r\n        }\r\n\r\n        return (\r\n          currentArg?.params?.page !== previousArg?.params?.page ||\r\n          currentArg?.params?.pageSize !== previousArg?.params?.pageSize\r\n        );\r\n      },\r\n      transformResponse: (response: FindExisting.Response) => {\r\n        if ('results' in response && response.results) {\r\n          return {\r\n            ...response,\r\n            results: prepareTempKeys(response.results.toReversed()),\r\n          };\r\n        } else {\r\n          return response;\r\n        }\r\n      },\r\n      providesTags: ['Relations'],\r\n    }),\r\n    searchRelations: build.query<\r\n      FindAvailable.Response,\r\n      FindAvailable.Params & {\r\n        params?: FindAvailable.Request['query'];\r\n      }\r\n    >({\r\n      query: ({ model, targetField, params }) => {\r\n        return {\r\n          url: `/content-manager/relations/${model}/${targetField}`,\r\n          method: 'GET',\r\n          config: {\r\n            params,\r\n          },\r\n        };\r\n      },\r\n      serializeQueryArgs: (args) => {\r\n        const { endpointName, queryArgs } = args;\r\n        return {\r\n          endpointName,\r\n          model: queryArgs.model,\r\n          targetField: queryArgs.targetField,\r\n          _q: queryArgs.params?._q,\r\n          idsToOmit: queryArgs.params?.idsToOmit,\r\n          idsToInclude: queryArgs.params?.idsToInclude,\r\n        };\r\n      },\r\n      merge: (currentCache, newItems) => {\r\n        if (currentCache.pagination && newItems.pagination) {\r\n          if (currentCache.pagination.page < newItems.pagination.page) {\r\n            /**\r\n             * Relations will always have unique IDs, so we can therefore assume\r\n             * that we only need to push the new items to the cache.\r\n             */\r\n            const existingIds = currentCache.results.map((item) => item.documentId);\r\n            const uniqueNewItems = newItems.results.filter(\r\n              (item) => !existingIds.includes(item.documentId)\r\n            );\r\n            currentCache.results.push(...uniqueNewItems);\r\n            currentCache.pagination = newItems.pagination;\r\n          } else if (newItems.pagination.page === 1) {\r\n            /**\r\n             * We're resetting the relations\r\n             */\r\n            currentCache.results = newItems.results;\r\n            currentCache.pagination = newItems.pagination;\r\n          }\r\n        }\r\n      },\r\n      forceRefetch({ currentArg, previousArg }) {\r\n        if (!currentArg?.params && !previousArg?.params) {\r\n          return false;\r\n        }\r\n\r\n        return (\r\n          currentArg?.params?.page !== previousArg?.params?.page ||\r\n          currentArg?.params?.pageSize !== previousArg?.params?.pageSize\r\n        );\r\n      },\r\n      transformResponse: (response: FindAvailable.Response) => {\r\n        if (response.results) {\r\n          return {\r\n            ...response,\r\n            results: response.results,\r\n          };\r\n        } else {\r\n          return response;\r\n        }\r\n      },\r\n    }),\r\n  }),\r\n});\r\n\r\n/**\r\n * @internal\r\n * @description Adds a `__temp_key__` to each relation item. This gives us\r\n * a stable identifier regardless of it's ids etc. that we can then use for drag and drop.\r\n */\r\nconst prepareTempKeys = (relations: RelResult[], existingRelations: RelationResult[] = []) => {\r\n  const [firstItem] = existingRelations.slice(0);\r\n  const keys = generateNKeysBetween(null, firstItem?.__temp_key__ ?? null, relations.length);\r\n\r\n  return relations.map((datum, index) => ({\r\n    ...datum,\r\n    __temp_key__: keys[index],\r\n  }));\r\n};\r\n\r\nconst { useGetRelationsQuery, useLazySearchRelationsQuery } = relationsApi;\r\n\r\nexport { useGetRelationsQuery, useLazySearchRelationsQuery };\r\nexport type { RelationResult };\r\n","import type { MainField } from './attributes';\r\nimport type { RelationResult } from '../../../shared/contracts/relations';\r\n\r\n/**\r\n * @internal\r\n * @description Get the label of a relation, the contract has [key: string]: unknown,\r\n * so we need to check if the mainFieldKey is defined and if the relation has a value\r\n * under that property. If it does, we then verify it's type of string and return it.\r\n *\r\n * We fallback to the documentId.\r\n */\r\nconst getRelationLabel = (relation: RelationResult, mainField?: MainField): string => {\r\n  const label = mainField && relation[mainField.name] ? relation[mainField.name] : null;\r\n\r\n  if (typeof label === 'string') {\r\n    return label;\r\n  }\r\n\r\n  return relation.documentId;\r\n};\r\n\r\nexport { getRelationLabel };\r\n"],"names":[],"mappings":"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"}