{"version":3,"file":"dependencies.mjs","sources":["../../../src/node/core/dependencies.ts"],"sourcesContent":["import os from 'node:os';\r\nimport fs from 'node:fs/promises';\r\nimport path from 'node:path';\r\nimport semver, { SemVer } from 'semver';\r\nimport resolveFrom from 'resolve-from';\r\nimport execa, { CommonOptions, ExecaReturnValue } from 'execa';\r\nimport readPkgUp, { PackageJson } from 'read-pkg-up';\r\nimport type { BuildOptions } from '../build';\r\nimport { getPackageManager } from './managers';\r\n\r\n/**\r\n * From V5 this will be imported from the package.json of `@strapi/strapi`.\r\n */\r\nconst PEER_DEPS = {\r\n  react: '^18.0.0',\r\n  'react-dom': '^18.0.0',\r\n  'react-router-dom': '^6.0.0',\r\n  'styled-components': '^6.0.0',\r\n};\r\n\r\ninterface CheckRequiredDependenciesResult {\r\n  didInstall: boolean;\r\n}\r\n\r\ninterface DepToInstall {\r\n  name: string;\r\n  wantedVersion: string;\r\n  declaredVersion?: never;\r\n}\r\n\r\n/**\r\n * Checks the user's project that it has declared and installed the required dependencies\r\n * needed by the Strapi admin project. Whilst generally speaking most modules will be\r\n * declared by the actual packages there are some packages where you only really want one of\r\n * and thus they are declared as peer dependencies â€“ react / styled-components / etc.\r\n *\r\n * If these deps are not installed or declared, then we prompt the user to correct this. In\r\n * V4 this is not a hard requirement, but in V5 it will be. Might as well get people started now.\r\n */\r\nconst checkRequiredDependencies = async ({\r\n  cwd,\r\n  logger,\r\n}: Pick<BuildOptions, 'cwd' | 'logger'>): Promise<CheckRequiredDependenciesResult> => {\r\n  /**\r\n   * This enables us to use experimental deps for libraries like\r\n   * react or styled-components. This is useful for testing against.\r\n   */\r\n  if (process.env.USE_EXPERIMENTAL_DEPENDENCIES === 'true') {\r\n    logger.warn('You are using experimental dependencies that may not be compatible with Strapi.');\r\n    return { didInstall: false };\r\n  }\r\n\r\n  const pkg = await readPkgUp({ cwd });\r\n\r\n  if (!pkg) {\r\n    throw new Error(`Could not find package.json at path: ${cwd}`);\r\n  }\r\n\r\n  logger.debug('Loaded package.json:', os.EOL, pkg.packageJson);\r\n\r\n  interface DepToReview {\r\n    name: string;\r\n    wantedVersion: string;\r\n    declaredVersion: string;\r\n  }\r\n\r\n  /**\r\n   * Run through each of the peer deps and figure out if they need to be\r\n   * installed or they need their version checked against.\r\n   */\r\n  const { install, review } = Object.entries(PEER_DEPS).reduce<{\r\n    install: DepToInstall[];\r\n    review: DepToReview[];\r\n  }>(\r\n    (acc, [name, version]) => {\r\n      if (!pkg.packageJson.dependencies) {\r\n        throw new Error(`Could not find dependencies in package.json at path: ${cwd}`);\r\n      }\r\n\r\n      const declaredVersion = pkg.packageJson.dependencies[name];\r\n\r\n      if (!declaredVersion) {\r\n        acc.install.push({\r\n          name,\r\n          wantedVersion: version,\r\n        });\r\n      } else {\r\n        acc.review.push({\r\n          name,\r\n          wantedVersion: version,\r\n          declaredVersion,\r\n        });\r\n      }\r\n\r\n      return acc;\r\n    },\r\n    {\r\n      install: [],\r\n      review: [],\r\n    }\r\n  );\r\n\r\n  if (install.length > 0) {\r\n    logger.info(\r\n      'The Strapi admin needs to install the following dependencies:',\r\n      os.EOL,\r\n      install.map(({ name, wantedVersion }) => `  - ${name}@${wantedVersion}`).join(os.EOL)\r\n    );\r\n\r\n    await installDependencies(install, {\r\n      cwd,\r\n      logger,\r\n    });\r\n\r\n    const [file, ...args] = process.argv;\r\n\r\n    /**\r\n     * Re-run the same command after installation e.g. strapi build because the yarn.lock might\r\n     * not be the same and could break installations. It's not the best solution, but it works.\r\n     */\r\n    await execa(file, args, { cwd, stdio: 'inherit' });\r\n    return { didInstall: true };\r\n  }\r\n\r\n  if (review.length) {\r\n    const errors: string[] = [];\r\n\r\n    for (const dep of review) {\r\n      // The version specified in package.json could be incorrect, eg `foo`\r\n      let minDeclaredVersion: SemVer | null = null;\r\n      try {\r\n        minDeclaredVersion = semver.minVersion(dep.declaredVersion);\r\n      } catch (err) {\r\n        // Intentional fall-through (variable will be left as null, throwing below)\r\n      }\r\n\r\n      if (!minDeclaredVersion) {\r\n        errors.push(\r\n          `The declared dependency, ${dep.name} has an invalid version in package.json: ${dep.declaredVersion}`\r\n        );\r\n      } else if (!semver.satisfies(minDeclaredVersion, dep.wantedVersion)) {\r\n        /**\r\n         * The delcared version should be semver compatible with our required version\r\n         * of the dependency. If it's not, we should advise the user to change it.\r\n         */\r\n        logger.warn(\r\n          [\r\n            `Declared version of ${dep.name} (${minDeclaredVersion}) is not compatible with the version required by Strapi (${dep.wantedVersion}).`,\r\n            'You may experience issues, we recommend you change this.',\r\n          ].join(os.EOL)\r\n        );\r\n      }\r\n\r\n      const installedVersion = await getModuleVersion(dep.name, cwd);\r\n\r\n      if (!installedVersion) {\r\n        /**\r\n         * TODO: when we know the packageManager we can advise the actual install command.\r\n         */\r\n        errors.push(\r\n          `The declared dependency, ${dep.name} is not installed. You should install before re-running this command`\r\n        );\r\n      } else if (!semver.satisfies(installedVersion, dep.wantedVersion)) {\r\n        logger.warn(\r\n          [\r\n            `Declared version of ${dep.name} (${installedVersion}) is not compatible with the version required by Strapi (${dep.wantedVersion}).`,\r\n            'You may experience issues, we recommend you change this.',\r\n          ].join(os.EOL)\r\n        );\r\n      }\r\n    }\r\n\r\n    if (errors.length > 0 && process.env.NODE_ENV === 'development') {\r\n      throw new Error(`${os.EOL}- ${errors.join(`${os.EOL}- `)}`);\r\n    }\r\n  }\r\n\r\n  return { didInstall: false };\r\n};\r\n\r\nconst getModule = async (name: string, cwd: string): Promise<PackageJson | null> => {\r\n  const modulePackagePath = resolveFrom.silent(cwd, path.join(name, 'package.json'));\r\n  if (!modulePackagePath) {\r\n    return null;\r\n  }\r\n  const file = await fs.readFile(modulePackagePath, 'utf8').then((res) => JSON.parse(res));\r\n\r\n  return file;\r\n};\r\n\r\nconst getModuleVersion = async (name: string, cwd: string): Promise<string | null> => {\r\n  const pkg = await getModule(name, cwd);\r\n\r\n  return pkg?.version || null;\r\n};\r\n\r\nconst installDependencies = async (\r\n  install: DepToInstall[],\r\n  { cwd, logger }: Pick<BuildOptions, 'cwd' | 'logger'>\r\n) => {\r\n  const packageManager = getPackageManager();\r\n\r\n  if (!packageManager) {\r\n    logger.error(\r\n      'Could not find a supported package manager, please install the dependencies manually.'\r\n    );\r\n    process.exit(1);\r\n  }\r\n\r\n  const execOptions: CommonOptions<'utf8'> = {\r\n    encoding: 'utf8',\r\n    cwd,\r\n    stdio: 'inherit',\r\n  };\r\n\r\n  const packages = install.map(({ name, wantedVersion }) => `${name}@${wantedVersion}`);\r\n\r\n  let result: ExecaReturnValue<string> | undefined;\r\n\r\n  if (packageManager === 'npm') {\r\n    const npmArgs = ['install', '--legacy-peer-deps', '--save', ...packages];\r\n    logger.info(`Running 'npm ${npmArgs.join(' ')}'`);\r\n    result = await execa('npm', npmArgs, execOptions);\r\n  } else if (packageManager === 'yarn') {\r\n    const yarnArgs = ['add', ...packages];\r\n    logger.info(`Running 'yarn ${yarnArgs.join(' ')}'`);\r\n    result = await execa('yarn', yarnArgs, execOptions);\r\n  } else if (packageManager === 'pnpm') {\r\n    const pnpmArgs = ['add', '--save-prod', ...packages];\r\n    logger.info(`Running 'pnpm ${pnpmArgs.join(' ')}'`);\r\n    result = await execa('pnpm', pnpmArgs, execOptions);\r\n  }\r\n\r\n  if (result?.exitCode || result?.failed) {\r\n    throw new Error('Package installation failed');\r\n  }\r\n};\r\n\r\nexport { checkRequiredDependencies, getModule };\r\nexport type { CheckRequiredDependenciesResult, PackageJson };\r\n"],"names":[],"mappings":"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"}