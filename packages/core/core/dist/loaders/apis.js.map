{"version":3,"file":"apis.js","sources":["../../src/loaders/apis.ts"],"sourcesContent":["import { join, extname, basename } from 'path';\r\nimport fse, { existsSync } from 'fs-extra';\r\nimport _ from 'lodash';\r\nimport { strings, importDefault } from '@strapi/utils';\r\nimport { isEmpty } from 'lodash/fp';\r\nimport type { Core, Struct } from '@strapi/types';\r\nimport { getGlobalId, type ContentTypeDefinition } from '../domain/content-type';\r\n\r\ninterface API {\r\n  bootstrap: () => void | Promise<void>;\r\n  destroy: () => void | Promise<void>;\r\n  register: () => void | Promise<void>;\r\n  config: Record<string, unknown>;\r\n  routes: Record<string, Core.Router>;\r\n  controllers: Record<string, Core.Controller>;\r\n  services: Record<string, Core.Service>;\r\n  policies: Record<string, Core.Policy>;\r\n  middlewares: Record<string, Core.Middleware>;\r\n  contentTypes: Record<string, { schema: Struct.ContentTypeSchema }>;\r\n}\r\n\r\ninterface APIs {\r\n  [key: string]: API;\r\n}\r\n\r\nconst DEFAULT_CONTENT_TYPE = {\r\n  schema: {},\r\n  actions: {},\r\n  lifecycles: {},\r\n};\r\n\r\n// to handle names with numbers in it we first check if it is already in kebabCase\r\nconst normalizeName = (name: string) => (strings.isKebabCase(name) ? name : _.kebabCase(name));\r\n\r\nconst isDirectory = (fd: fse.Dirent) => fd.isDirectory();\r\nconst isDotFile = (fd: fse.Dirent) => fd.name.startsWith('.');\r\n\r\nexport default async function loadAPIs(strapi: Core.Strapi) {\r\n  if (!existsSync(strapi.dirs.dist.api)) {\r\n    return;\r\n  }\r\n\r\n  const apisFDs = await (await fse.readdir(strapi.dirs.dist.api, { withFileTypes: true }))\r\n    .filter(isDirectory)\r\n    .filter(_.negate(isDotFile));\r\n\r\n  const apis: APIs = {};\r\n\r\n  // only load folders\r\n  for (const apiFD of apisFDs) {\r\n    const apiName = normalizeName(apiFD.name);\r\n    const api = await loadAPI(apiName, join(strapi.dirs.dist.api, apiFD.name));\r\n\r\n    // @ts-expect-error TODO verify that it's a valid api, not missing bootstrap, register, and destroy\r\n    apis[apiName] = api;\r\n  }\r\n\r\n  validateContentTypesUnicity(apis);\r\n\r\n  for (const apiName of Object.keys(apis)) {\r\n    strapi.get('apis').add(apiName, apis[apiName]);\r\n  }\r\n}\r\n\r\nconst validateContentTypesUnicity = (apis: APIs) => {\r\n  const allApisSchemas = Object.values(apis).flatMap((api) => Object.values(api.contentTypes));\r\n\r\n  const names: string[] = [];\r\n  allApisSchemas.forEach(({ schema }) => {\r\n    if (schema.info.singularName) {\r\n      const singularName = _.kebabCase(schema.info.singularName);\r\n      if (names.includes(singularName)) {\r\n        throw new Error(`The singular name \"${schema.info.singularName}\" should be unique`);\r\n      }\r\n      names.push(singularName);\r\n    }\r\n\r\n    if (schema.info.pluralName) {\r\n      const pluralName = _.kebabCase(schema.info.pluralName);\r\n      if (names.includes(pluralName)) {\r\n        throw new Error(`The plural name \"${schema.info.pluralName}\" should be unique`);\r\n      }\r\n      names.push(pluralName);\r\n    }\r\n  });\r\n};\r\n\r\nconst loadAPI = async (apiName: string, dir: string) => {\r\n  const [index, config, routes, controllers, services, policies, middlewares, contentTypes] = (\r\n    await Promise.all([\r\n      loadIndex(dir),\r\n      loadDir(join(dir, 'config')),\r\n      loadDir(join(dir, 'routes')),\r\n      loadDir(join(dir, 'controllers')),\r\n      loadDir(join(dir, 'services')),\r\n      loadDir(join(dir, 'policies')),\r\n      loadDir(join(dir, 'middlewares')),\r\n      loadContentTypes(apiName, join(dir, 'content-types')),\r\n    ])\r\n  ).map((result) => result?.result);\r\n\r\n  return {\r\n    ...(index || {}),\r\n    config: config || {},\r\n    routes: routes || [],\r\n    controllers: controllers || {},\r\n    services: services || {},\r\n    policies: policies || {},\r\n    middlewares: middlewares || {},\r\n    contentTypes: contentTypes || {},\r\n  };\r\n};\r\n\r\nconst loadIndex = async (dir: string) => {\r\n  if (await fse.pathExists(join(dir, 'index.js'))) {\r\n    return loadFile(join(dir, 'index.js'));\r\n  }\r\n};\r\n\r\n// because this is async and its contents are dynamic, we must return it within an object to avoid a property called `then` being interpreted as a Promise\r\nconst loadContentTypes = async (apiName: string, dir: string) => {\r\n  if (!(await fse.pathExists(dir))) {\r\n    return;\r\n  }\r\n\r\n  const fds = await fse.readdir(dir, { withFileTypes: true });\r\n  const contentTypes: API['contentTypes'] = {};\r\n\r\n  // only load folders\r\n  for (const fd of fds) {\r\n    if (fd.isFile()) {\r\n      continue;\r\n    }\r\n\r\n    const contentTypeName = normalizeName(fd.name);\r\n    const loadedContentType = (await loadDir(join(dir, fd.name)))?.result;\r\n\r\n    if (isEmpty(loadedContentType) || isEmpty(loadedContentType.schema)) {\r\n      throw new Error(`Could not load content type found at ${dir}`);\r\n    }\r\n\r\n    const contentType = {\r\n      ...DEFAULT_CONTENT_TYPE,\r\n      ...loadedContentType,\r\n    } as ContentTypeDefinition;\r\n\r\n    Object.assign(contentType.schema, {\r\n      apiName,\r\n      collectionName: contentType.schema.collectionName || contentType.schema.info.singularName,\r\n      globalId: getGlobalId(contentType.schema),\r\n    });\r\n\r\n    contentTypes[normalizeName(contentTypeName)] = contentType;\r\n  }\r\n\r\n  return { result: contentTypes };\r\n};\r\n\r\n// because this is async and its contents are dynamic, we must return it within an object to avoid a property called `then` being interpreted as a Promise\r\nconst loadDir = async (dir: string) => {\r\n  if (!(await fse.pathExists(dir))) {\r\n    return;\r\n  }\r\n\r\n  const fds = await fse.readdir(dir, { withFileTypes: true });\r\n\r\n  const root: Record<string, unknown> = {};\r\n  for (const fd of fds) {\r\n    if (!fd.isFile() || extname(fd.name) === '.map') {\r\n      continue;\r\n    }\r\n\r\n    const key = basename(fd.name, extname(fd.name));\r\n\r\n    root[normalizeName(key)] = (await loadFile(join(dir, fd.name))).result;\r\n  }\r\n\r\n  return { result: root };\r\n};\r\n\r\n// because this is async and its contents are dynamic, we must return it as an array to avoid a property called `then` being interpreted as a Promise\r\nconst loadFile = async (file: string): Promise<{ result: unknown }> => {\r\n  const ext = extname(file);\r\n\r\n  switch (ext) {\r\n    case '.js':\r\n      return { result: importDefault(file) };\r\n    case '.json':\r\n      return { result: await fse.readJSON(file) };\r\n    default:\r\n      return { result: {} };\r\n  }\r\n};\r\n"],"names":["strings","_","existsSync","fse","join","index","isEmpty","getGlobalId","extname","basename","importDefault"],"mappings":"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"}