{"version":3,"file":"transform-content-types-to-models.js","sources":["../../src/utils/transform-content-types-to-models.ts"],"sourcesContent":["import { type Model, type Identifiers } from '@strapi/database';\r\nimport type { Struct, Schema } from '@strapi/types';\r\nimport { createId } from '@paralleldrive/cuid2';\r\nimport assert from 'node:assert';\r\nimport _ from 'lodash/fp';\r\n\r\n/**\r\n * Because strapi/database models don't know about things like components or dynamic zones, we use this file to convert them\r\n * to a relations format that it recognizes\r\n *\r\n * Therefore we have to keep an additional set of helpers/extensions to the database naming methods\r\n *\r\n * IMPORTANT!\r\n * If we use short versions of anything, we MUST call getNameFromTokens directly; attempting to shorten them ourselves\r\n * prevents the unshortened name map from being filled properly, so for example it will think that the short name\r\n * 'collection4f3a_cmps' maps to the unshortened 'collectionname_cmps' rather than 'collectionname_components'\r\n * Therefore, we only use the identifiers helpers in cases where we do not do any of our own shortening\r\n */\r\n\r\nexport const getComponentJoinTableName = (collectionName: string, identifiers: Identifiers) => {\r\n  return identifiers.getNameFromTokens([\r\n    { name: collectionName, compressible: true },\r\n    { name: 'components', shortName: 'cmps', compressible: false },\r\n  ]);\r\n};\r\n\r\nexport const getDzJoinTableName = (collectionName: string, identifiers: Identifiers) => {\r\n  return identifiers.getNameFromTokens([\r\n    { name: collectionName, compressible: true },\r\n    { name: 'components', shortName: 'cmps', compressible: false },\r\n  ]);\r\n};\r\n\r\nexport const getComponentJoinColumnEntityName = (identifiers: Identifiers) => {\r\n  return identifiers.getNameFromTokens([\r\n    { name: 'entity', compressible: false },\r\n    { name: 'id', compressible: false },\r\n  ]);\r\n};\r\n\r\nexport const getComponentJoinColumnInverseName = (identifiers: Identifiers) => {\r\n  return identifiers.getNameFromTokens([\r\n    { name: 'component', shortName: 'cmp', compressible: false },\r\n    { name: 'id', compressible: false },\r\n  ]);\r\n};\r\n\r\nexport const getComponentTypeColumn = (identifiers: Identifiers) => {\r\n  return identifiers.getNameFromTokens([{ name: 'component_type', compressible: false }]);\r\n};\r\n\r\nexport const getComponentFkIndexName = (contentType: string, identifiers: Identifiers) => {\r\n  return identifiers.getNameFromTokens([\r\n    { name: contentType, compressible: true },\r\n    { name: 'entity', compressible: false },\r\n    { name: 'fk', compressible: false },\r\n  ]);\r\n};\r\n\r\n// const { ID_COLUMN: id, FIELD_COLUMN: field, ORDER_COLUMN: order } = identifiers;\r\n\r\nexport type LoadedContentTypeModel = Struct.ContentTypeSchema &\r\n  Required<Pick<Struct.ContentTypeSchema, 'collectionName' | 'uid' | 'modelName'>> &\r\n  Pick<Model, 'lifecycles'>;\r\n\r\n// Transforms an attribute (particularly for relation types) into the format that strapi/database accepts\r\nexport const transformAttribute = (\r\n  name: string,\r\n  attribute: Schema.Attribute.AnyAttribute,\r\n  contentType: LoadedContentTypeModel,\r\n  identifiers: Identifiers\r\n) => {\r\n  switch (attribute.type) {\r\n    case 'media': {\r\n      return {\r\n        type: 'relation',\r\n        relation: attribute.multiple === true ? 'morphMany' : 'morphOne',\r\n        target: 'plugin::upload.file',\r\n        morphBy: 'related',\r\n      };\r\n    }\r\n    case 'component': {\r\n      const joinTableName = getComponentJoinTableName(contentType.collectionName, identifiers);\r\n      const joinColumnEntityName = getComponentJoinColumnEntityName(identifiers);\r\n      const joinColumnInverseName = getComponentJoinColumnInverseName(identifiers);\r\n      const compTypeColumn = getComponentTypeColumn(identifiers);\r\n      return {\r\n        type: 'relation',\r\n        relation: attribute.repeatable === true ? 'oneToMany' : 'oneToOne',\r\n        target: attribute.component,\r\n\r\n        // We need the join table name to be deterministic,\r\n        // We need to allow passing the join table name as an option\r\n        joinTable: {\r\n          name: joinTableName,\r\n          joinColumn: {\r\n            name: joinColumnEntityName,\r\n            referencedColumn: identifiers.ID_COLUMN,\r\n          },\r\n          inverseJoinColumn: {\r\n            name: joinColumnInverseName,\r\n            referencedColumn: identifiers.ID_COLUMN,\r\n          },\r\n          on: {\r\n            field: name,\r\n          },\r\n          orderColumnName: identifiers.ORDER_COLUMN,\r\n          orderBy: {\r\n            order: 'asc',\r\n          },\r\n          pivotColumns: [\r\n            joinColumnEntityName,\r\n            joinColumnInverseName,\r\n            identifiers.FIELD_COLUMN,\r\n            compTypeColumn,\r\n          ],\r\n        },\r\n      };\r\n    }\r\n    case 'dynamiczone': {\r\n      const joinTableName = getDzJoinTableName(contentType.collectionName, identifiers);\r\n      const joinColumnEntityName = getComponentJoinColumnEntityName(identifiers);\r\n      const joinColumnInverseName = getComponentJoinColumnInverseName(identifiers);\r\n      const compTypeColumn = getComponentTypeColumn(identifiers);\r\n\r\n      return {\r\n        type: 'relation',\r\n        relation: 'morphToMany',\r\n        // TODO: handle restrictions at some point\r\n        // target: attribute.components,\r\n        joinTable: {\r\n          name: joinTableName,\r\n          joinColumn: {\r\n            name: joinColumnEntityName,\r\n            referencedColumn: identifiers.ID_COLUMN,\r\n          },\r\n          morphColumn: {\r\n            idColumn: {\r\n              name: joinColumnInverseName,\r\n              referencedColumn: identifiers.ID_COLUMN,\r\n            },\r\n            typeColumn: {\r\n              name: compTypeColumn,\r\n            },\r\n            typeField: '__component',\r\n          },\r\n          on: {\r\n            field: name,\r\n          },\r\n          orderBy: {\r\n            order: 'asc',\r\n          },\r\n          pivotColumns: [\r\n            joinColumnEntityName,\r\n            joinColumnInverseName,\r\n            identifiers.FIELD_COLUMN,\r\n            compTypeColumn,\r\n          ],\r\n        },\r\n      };\r\n    }\r\n    default: {\r\n      return attribute;\r\n    }\r\n  }\r\n};\r\n\r\nexport const transformAttributes = (\r\n  contentType: LoadedContentTypeModel,\r\n  identifiers: Identifiers\r\n) => {\r\n  return Object.keys(contentType.attributes! || {}).reduce((attrs, attrName) => {\r\n    return {\r\n      ...attrs,\r\n      [attrName]: transformAttribute(\r\n        attrName,\r\n        contentType.attributes[attrName]!,\r\n        contentType,\r\n        identifiers\r\n      ),\r\n    };\r\n  }, {});\r\n};\r\n\r\nexport const hasComponentsOrDz = (\r\n  contentType: LoadedContentTypeModel\r\n): contentType is LoadedContentTypeModel & { type: 'dynamiczone' | 'component' } => {\r\n  return Object.values(contentType.attributes || {}).some(\r\n    (({ type }: { type: string }) => type === 'dynamiczone' || type === 'component') as any\r\n  );\r\n};\r\n\r\nexport const createDocumentId = createId;\r\n\r\nconst createCompoLinkModel = (\r\n  contentType: LoadedContentTypeModel,\r\n  identifiers: Identifiers\r\n): Model => {\r\n  const name = getComponentJoinTableName(contentType.collectionName, identifiers);\r\n\r\n  const entityId = getComponentJoinColumnEntityName(identifiers);\r\n  const componentId = getComponentJoinColumnInverseName(identifiers);\r\n  const compTypeColumn = getComponentTypeColumn(identifiers);\r\n  const fkIndex = getComponentFkIndexName(contentType.collectionName, identifiers);\r\n\r\n  return {\r\n    // TODO: make sure there can't be any conflicts with a prefix\r\n    singularName: name,\r\n    uid: name,\r\n    tableName: name,\r\n    attributes: {\r\n      [identifiers.ID_COLUMN]: {\r\n        type: 'increments',\r\n      },\r\n      [entityId]: {\r\n        type: 'integer',\r\n        column: {\r\n          unsigned: true,\r\n        },\r\n      },\r\n      [componentId]: {\r\n        type: 'integer',\r\n        column: {\r\n          unsigned: true,\r\n        },\r\n      },\r\n      [compTypeColumn]: {\r\n        type: 'string',\r\n      },\r\n      [identifiers.FIELD_COLUMN]: {\r\n        type: 'string',\r\n      },\r\n      [identifiers.ORDER_COLUMN]: {\r\n        type: 'float',\r\n        column: {\r\n          unsigned: true,\r\n          defaultTo: null,\r\n        },\r\n      },\r\n    },\r\n    indexes: [\r\n      {\r\n        name: identifiers.getIndexName([contentType.collectionName, identifiers.FIELD_COLUMN]),\r\n        columns: [identifiers.FIELD_COLUMN],\r\n      },\r\n      {\r\n        name: identifiers.getIndexName([contentType.collectionName, compTypeColumn]),\r\n        columns: [compTypeColumn],\r\n      },\r\n      {\r\n        name: fkIndex,\r\n        columns: [entityId],\r\n      },\r\n      {\r\n        // NOTE: since we don't include attribute names, we need to be careful not to create another unique index\r\n        name: identifiers.getUniqueIndexName([contentType.collectionName]),\r\n        columns: [entityId, componentId, identifiers.FIELD_COLUMN, compTypeColumn],\r\n        type: 'unique',\r\n      },\r\n    ],\r\n    foreignKeys: [\r\n      {\r\n        name: fkIndex,\r\n        columns: [entityId],\r\n        referencedColumns: [identifiers.ID_COLUMN],\r\n        referencedTable: identifiers.getTableName(contentType.collectionName),\r\n        onDelete: 'CASCADE',\r\n      },\r\n    ],\r\n  };\r\n};\r\n\r\nexport const transformContentTypesToModels = (\r\n  contentTypes: LoadedContentTypeModel[],\r\n  identifiers: Identifiers\r\n): Model[] => {\r\n  const models: Model[] = [];\r\n\r\n  contentTypes.forEach((contentType) => {\r\n    assert(contentType.collectionName, 'Content type \"collectionName\" is required');\r\n    assert(contentType.modelName, 'Content type \"modelName\" is required');\r\n    assert(contentType.uid, 'Content type \"uid\" is required');\r\n\r\n    // Add document id to content types\r\n    // as it is not documented\r\n    const documentIdAttribute: Record<string, Schema.Attribute.AnyAttribute> =\r\n      contentType.modelType === 'contentType'\r\n        ? { documentId: { type: 'string', default: createDocumentId } }\r\n        : {};\r\n\r\n    // TODO: this needs to be combined with getReservedNames, we should not be maintaining two lists\r\n    // Prevent user from creating a documentId attribute\r\n    const reservedAttributeNames = ['document_id', identifiers.ID_COLUMN];\r\n    Object.keys(contentType.attributes || {}).forEach((attributeName) => {\r\n      const snakeCasedAttributeName = _.snakeCase(attributeName);\r\n      if (reservedAttributeNames.includes(snakeCasedAttributeName)) {\r\n        throw new Error(\r\n          `The attribute \"${attributeName}\" is reserved and cannot be used in a model. Please rename \"${contentType.modelName}\" attribute \"${attributeName}\" to something else.`\r\n        );\r\n      }\r\n    });\r\n\r\n    if (hasComponentsOrDz(contentType)) {\r\n      const compoLinkModel = createCompoLinkModel(contentType, identifiers);\r\n      models.push(compoLinkModel);\r\n    }\r\n\r\n    const model: Model = {\r\n      uid: contentType.uid,\r\n      singularName: contentType.modelName,\r\n      tableName: contentType.collectionName, // This gets shortened in metadata.loadModels(), so we don't shorten here or it will happen twice\r\n      attributes: {\r\n        [identifiers.ID_COLUMN]: {\r\n          type: 'increments',\r\n        },\r\n        ...documentIdAttribute,\r\n        ...transformAttributes(contentType, identifiers),\r\n      },\r\n      indexes: contentType.indexes as Model['indexes'],\r\n      foreignKeys: contentType.foreignKeys as Model['foreignKeys'],\r\n      lifecycles: contentType?.lifecycles ?? {},\r\n    };\r\n\r\n    // Add indexes to model\r\n    if (contentType.modelType === 'contentType') {\r\n      model.indexes = [\r\n        ...(model.indexes || []),\r\n        {\r\n          name: identifiers.getIndexName([contentType.collectionName, 'documents']),\r\n          // Filter attributes that are not in the schema\r\n          columns: ['documentId', 'locale', 'publishedAt']\r\n            .filter((n) => model.attributes[n])\r\n            .map((name) => identifiers.getColumnName(_.snakeCase(name))),\r\n        },\r\n      ];\r\n    }\r\n\r\n    models.push(model);\r\n  });\r\n\r\n  return models;\r\n};\r\n"],"names":["createId","assert","_"],"mappings":"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"}