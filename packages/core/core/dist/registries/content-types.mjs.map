{"version":3,"file":"content-types.mjs","sources":["../../src/registries/content-types.ts"],"sourcesContent":["import { pickBy, has } from 'lodash/fp';\r\nimport type { UID, Struct } from '@strapi/types';\r\nimport { createContentType, ContentTypeDefinition } from '../domain/content-type';\r\nimport { addNamespace, hasNamespace } from './namespace';\r\n\r\ntype ContentTypesInput = Record<string, ContentTypeDefinition>;\r\ntype ContentTypeExtendFn = (contentType: Struct.ContentTypeSchema) => Struct.ContentTypeSchema;\r\n\r\nconst validateKeySameToSingularName = (contentTypes: ContentTypesInput) => {\r\n  for (const ctName of Object.keys(contentTypes)) {\r\n    const contentType = contentTypes[ctName];\r\n\r\n    if (ctName !== contentType.schema.info.singularName) {\r\n      throw new Error(\r\n        `The key of the content-type should be the same as its singularName. Found ${ctName} and ${contentType.schema.info.singularName}.`\r\n      );\r\n    }\r\n  }\r\n};\r\n\r\nconst contentTypesRegistry = () => {\r\n  const contentTypes: Record<string, Struct.ContentTypeSchema> = {};\r\n\r\n  return {\r\n    /**\r\n     * Returns this list of registered contentTypes uids\r\n     */\r\n    keys() {\r\n      return Object.keys(contentTypes);\r\n    },\r\n\r\n    /**\r\n     * Returns the instance of a contentType. Instantiate the contentType if not already done\r\n     */\r\n    get(uid: UID.ContentType) {\r\n      return contentTypes[uid];\r\n    },\r\n\r\n    /**\r\n     * Returns a map with all the contentTypes in a namespace\r\n     */\r\n    getAll(namespace: string) {\r\n      return pickBy((_, uid) => hasNamespace(uid, namespace))(contentTypes);\r\n    },\r\n\r\n    /**\r\n     * Registers a contentType\r\n     */\r\n    set(uid: UID.ContentType, contentType: Struct.ContentTypeSchema) {\r\n      contentTypes[uid] = contentType;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Registers a map of contentTypes for a specific namespace\r\n     */\r\n    add(namespace: string, newContentTypes: ContentTypesInput) {\r\n      validateKeySameToSingularName(newContentTypes);\r\n\r\n      for (const rawCtName of Object.keys(newContentTypes)) {\r\n        const uid = addNamespace(rawCtName, namespace);\r\n\r\n        if (has(uid, contentTypes)) {\r\n          throw new Error(`Content-type ${uid} has already been registered.`);\r\n        }\r\n\r\n        contentTypes[uid] = createContentType(uid, newContentTypes[rawCtName]);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Wraps a contentType to extend it\r\n     */\r\n    extend(ctUID: UID.ContentType, extendFn: ContentTypeExtendFn) {\r\n      const currentContentType = this.get(ctUID);\r\n\r\n      if (!currentContentType) {\r\n        throw new Error(`Content-Type ${ctUID} doesn't exist`);\r\n      }\r\n\r\n      extendFn(currentContentType);\r\n\r\n      return this;\r\n    },\r\n  };\r\n};\r\n\r\nexport default contentTypesRegistry;\r\n"],"names":[],"mappings":";;;AAQA,MAAM,gCAAgC,CAAC,iBAAoC;AACzE,aAAW,UAAU,OAAO,KAAK,YAAY,GAAG;AACxC,UAAA,cAAc,aAAa,MAAM;AAEvC,QAAI,WAAW,YAAY,OAAO,KAAK,cAAc;AACnD,YAAM,IAAI;AAAA,QACR,6EAA6E,MAAM,QAAQ,YAAY,OAAO,KAAK,YAAY;AAAA,MACjI;AAAA,IAAA;AAAA,EACF;AAEJ;AAEA,MAAM,uBAAuB,MAAM;AACjC,QAAM,eAAyD,CAAC;AAEzD,SAAA;AAAA;AAAA;AAAA;AAAA,IAIL,OAAO;AACE,aAAA,OAAO,KAAK,YAAY;AAAA,IACjC;AAAA;AAAA;AAAA;AAAA,IAKA,IAAI,KAAsB;AACxB,aAAO,aAAa,GAAG;AAAA,IACzB;AAAA;AAAA;AAAA;AAAA,IAKA,OAAO,WAAmB;AACjB,aAAA,OAAO,CAAC,GAAG,QAAQ,aAAa,KAAK,SAAS,CAAC,EAAE,YAAY;AAAA,IACtE;AAAA;AAAA;AAAA;AAAA,IAKA,IAAI,KAAsB,aAAuC;AAC/D,mBAAa,GAAG,IAAI;AACb,aAAA;AAAA,IACT;AAAA;AAAA;AAAA;AAAA,IAKA,IAAI,WAAmB,iBAAoC;AACzD,oCAA8B,eAAe;AAE7C,iBAAW,aAAa,OAAO,KAAK,eAAe,GAAG;AAC9C,cAAA,MAAM,aAAa,WAAW,SAAS;AAEzC,YAAA,IAAI,KAAK,YAAY,GAAG;AAC1B,gBAAM,IAAI,MAAM,gBAAgB,GAAG,+BAA+B;AAAA,QAAA;AAGpE,qBAAa,GAAG,IAAI,kBAAkB,KAAK,gBAAgB,SAAS,CAAC;AAAA,MAAA;AAAA,IAEzE;AAAA;AAAA;AAAA;AAAA,IAKA,OAAO,OAAwB,UAA+B;AACtD,YAAA,qBAAqB,KAAK,IAAI,KAAK;AAEzC,UAAI,CAAC,oBAAoB;AACvB,cAAM,IAAI,MAAM,gBAAgB,KAAK,gBAAgB;AAAA,MAAA;AAGvD,eAAS,kBAAkB;AAEpB,aAAA;AAAA,IAAA;AAAA,EAEX;AACF;"}