{"version":3,"file":"unidirectional-relations.js","sources":["../../../../src/services/document-service/utils/unidirectional-relations.ts"],"sourcesContent":["/* eslint-disable no-continue */\r\nimport { keyBy, omit } from 'lodash/fp';\r\n\r\nimport { UID, Schema } from '@strapi/types';\r\n\r\ninterface LoadContext {\r\n  oldVersions: { id: string; locale: string }[];\r\n  newVersions: { id: string; locale: string }[];\r\n}\r\n\r\n/**\r\n * Loads lingering relations that need to be updated when overriding a published or draft entry.\r\n * This is necessary because the relations are uni-directional and the target entry is not aware of the source entry.\r\n * This is not the case for bi-directional relations, where the target entry is also linked to the source entry.\r\n */\r\nconst load = async (uid: UID.ContentType, { oldVersions, newVersions }: LoadContext) => {\r\n  const updates = [] as any;\r\n\r\n  // Iterate all components and content types to find relations that need to be updated\r\n  await strapi.db.transaction(async ({ trx }) => {\r\n    const contentTypes = Object.values(strapi.contentTypes) as Schema.ContentType[];\r\n    const components = Object.values(strapi.components) as Schema.Component[];\r\n\r\n    for (const model of [...contentTypes, ...components]) {\r\n      const dbModel = strapi.db.metadata.get(model.uid);\r\n\r\n      for (const attribute of Object.values(dbModel.attributes) as any) {\r\n        /**\r\n         * Only consider unidirectional relations\r\n         */\r\n        if (\r\n          attribute.type !== 'relation' ||\r\n          attribute.target !== uid ||\r\n          attribute.inversedBy ||\r\n          attribute.mappedBy\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        // TODO: joinColumn relations\r\n        const joinTable = attribute.joinTable;\r\n        if (!joinTable) {\r\n          continue;\r\n        }\r\n\r\n        const { name: sourceColumnName } = joinTable.joinColumn;\r\n        const { name: targetColumnName } = joinTable.inverseJoinColumn;\r\n\r\n        /**\r\n         * Load all relations that need to be updated\r\n         */\r\n        // NOTE: when the model has draft and publish, we can assume relation are only draft to draft & published to published\r\n        const ids = oldVersions.map((entry) => entry.id);\r\n\r\n        const oldVersionsRelations = await strapi.db\r\n          .getConnection()\r\n          .select('*')\r\n          .from(joinTable.name)\r\n          .whereIn(targetColumnName, ids)\r\n          .transacting(trx);\r\n\r\n        if (oldVersionsRelations.length > 0) {\r\n          updates.push({ joinTable, relations: oldVersionsRelations });\r\n        }\r\n\r\n        /**\r\n         * if publishing\r\n         *  if published version exists\r\n         *    updated published versions links\r\n         *  else\r\n         *    create link to newly published version\r\n         *\r\n         * if discarding\r\n         *    if published version link exists & not draft version link\r\n         *       create link to new draft version\r\n         */\r\n\r\n        if (!model.options?.draftAndPublish) {\r\n          const ids = newVersions.map((entry) => entry.id);\r\n\r\n          const newVersionsRelations = await strapi.db\r\n            .getConnection()\r\n            .select('*')\r\n            .from(joinTable.name)\r\n            .whereIn(targetColumnName, ids)\r\n            .transacting(trx);\r\n\r\n          if (newVersionsRelations.length > 0) {\r\n            // when publishing a draft that doesn't have a published version yet,\r\n            // copy the links to the draft over to the published version\r\n            // when discarding a published version, if no drafts exists\r\n            const discardToAdd = newVersionsRelations\r\n              .filter((relation) => {\r\n                const matchingOldVerion = oldVersionsRelations.find((oldRelation) => {\r\n                  return oldRelation[sourceColumnName] === relation[sourceColumnName];\r\n                });\r\n\r\n                return !matchingOldVerion;\r\n              })\r\n              .map(omit('id'));\r\n\r\n            updates.push({ joinTable, relations: discardToAdd });\r\n          }\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n  return updates;\r\n};\r\n\r\n/**\r\n * Updates uni directional relations to target the right entries when overriding published or draft entries.\r\n *\r\n * @param oldEntries The old entries that are being overridden\r\n * @param newEntries The new entries that are overriding the old ones\r\n * @param oldRelations The relations that were previously loaded with `load` @see load\r\n */\r\nconst sync = async (\r\n  oldEntries: { id: string; locale: string }[],\r\n  newEntries: { id: string; locale: string }[],\r\n  oldRelations: { joinTable: any; relations: any[] }[]\r\n) => {\r\n  /**\r\n   * Create a map of old entry ids to new entry ids\r\n   *\r\n   * Will be used to update the relation target ids\r\n   */\r\n  const newEntryByLocale = keyBy('locale', newEntries);\r\n  const oldEntriesMap = oldEntries.reduce(\r\n    (acc, entry) => {\r\n      const newEntry = newEntryByLocale[entry.locale];\r\n      if (!newEntry) return acc;\r\n      acc[entry.id] = newEntry.id;\r\n      return acc;\r\n    },\r\n    {} as Record<string, string>\r\n  );\r\n\r\n  await strapi.db.transaction(async ({ trx }) => {\r\n    // Iterate old relations that are deleted and insert the new ones\r\n    for (const { joinTable, relations } of oldRelations) {\r\n      // Update old ids with the new ones\r\n      const column = joinTable.inverseJoinColumn.name;\r\n\r\n      const newRelations = relations.map((relation) => {\r\n        const newId = oldEntriesMap[relation[column]];\r\n        return { ...relation, [column]: newId };\r\n      });\r\n\r\n      // Insert those relations into the join table\r\n      await trx.batchInsert(joinTable.name, newRelations, 1000);\r\n    }\r\n  });\r\n};\r\n\r\nexport { load, sync };\r\n"],"names":["ids","omit","keyBy"],"mappings":";;;AAeA,MAAM,OAAO,OAAO,KAAsB,EAAE,aAAa,kBAA+B;AACtF,QAAM,UAAU,CAAC;AAGjB,QAAM,OAAO,GAAG,YAAY,OAAO,EAAE,UAAU;AAC7C,UAAM,eAAe,OAAO,OAAO,OAAO,YAAY;AACtD,UAAM,aAAa,OAAO,OAAO,OAAO,UAAU;AAElD,eAAW,SAAS,CAAC,GAAG,cAAc,GAAG,UAAU,GAAG;AACpD,YAAM,UAAU,OAAO,GAAG,SAAS,IAAI,MAAM,GAAG;AAEhD,iBAAW,aAAa,OAAO,OAAO,QAAQ,UAAU,GAAU;AAK9D,YAAA,UAAU,SAAS,cACnB,UAAU,WAAW,OACrB,UAAU,cACV,UAAU,UACV;AACA;AAAA,QAAA;AAIF,cAAM,YAAY,UAAU;AAC5B,YAAI,CAAC,WAAW;AACd;AAAA,QAAA;AAGF,cAAM,EAAE,MAAM,iBAAiB,IAAI,UAAU;AAC7C,cAAM,EAAE,MAAM,iBAAiB,IAAI,UAAU;AAM7C,cAAM,MAAM,YAAY,IAAI,CAAC,UAAU,MAAM,EAAE;AAE/C,cAAM,uBAAuB,MAAM,OAAO,GACvC,cAAc,EACd,OAAO,GAAG,EACV,KAAK,UAAU,IAAI,EACnB,QAAQ,kBAAkB,GAAG,EAC7B,YAAY,GAAG;AAEd,YAAA,qBAAqB,SAAS,GAAG;AACnC,kBAAQ,KAAK,EAAE,WAAW,WAAW,sBAAsB;AAAA,QAAA;AAezD,YAAA,CAAC,MAAM,SAAS,iBAAiB;AACnC,gBAAMA,OAAM,YAAY,IAAI,CAAC,UAAU,MAAM,EAAE;AAE/C,gBAAM,uBAAuB,MAAM,OAAO,GACvC,cAAc,EACd,OAAO,GAAG,EACV,KAAK,UAAU,IAAI,EACnB,QAAQ,kBAAkBA,IAAG,EAC7B,YAAY,GAAG;AAEd,cAAA,qBAAqB,SAAS,GAAG;AAInC,kBAAM,eAAe,qBAClB,OAAO,CAAC,aAAa;AACpB,oBAAM,oBAAoB,qBAAqB,KAAK,CAAC,gBAAgB;AACnE,uBAAO,YAAY,gBAAgB,MAAM,SAAS,gBAAgB;AAAA,cAAA,CACnE;AAED,qBAAO,CAAC;AAAA,YACT,CAAA,EACA,IAAIC,QAAK,IAAI,CAAC;AAEjB,oBAAQ,KAAK,EAAE,WAAW,WAAW,cAAc;AAAA,UAAA;AAAA,QACrD;AAAA,MACF;AAAA,IACF;AAAA,EACF,CACD;AAEM,SAAA;AACT;AASA,MAAM,OAAO,OACX,YACA,YACA,iBACG;AAMG,QAAA,mBAAmBC,GAAAA,MAAM,UAAU,UAAU;AACnD,QAAM,gBAAgB,WAAW;AAAA,IAC/B,CAAC,KAAK,UAAU;AACR,YAAA,WAAW,iBAAiB,MAAM,MAAM;AAC1C,UAAA,CAAC,SAAiB,QAAA;AAClB,UAAA,MAAM,EAAE,IAAI,SAAS;AAClB,aAAA;AAAA,IACT;AAAA,IACA,CAAA;AAAA,EACF;AAEA,QAAM,OAAO,GAAG,YAAY,OAAO,EAAE,UAAU;AAE7C,eAAW,EAAE,WAAW,UAAU,KAAK,cAAc;AAE7C,YAAA,SAAS,UAAU,kBAAkB;AAE3C,YAAM,eAAe,UAAU,IAAI,CAAC,aAAa;AAC/C,cAAM,QAAQ,cAAc,SAAS,MAAM,CAAC;AAC5C,eAAO,EAAE,GAAG,UAAU,CAAC,MAAM,GAAG,MAAM;AAAA,MAAA,CACvC;AAGD,YAAM,IAAI,YAAY,UAAU,MAAM,cAAc,GAAI;AAAA,IAAA;AAAA,EAC1D,CACD;AACH;;;"}