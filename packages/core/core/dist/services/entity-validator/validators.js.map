{"version":3,"file":"validators.js","sources":["../../../src/services/entity-validator/validators.ts"],"sourcesContent":["/**\r\n * Validators check if the entry data meets specific criteria before saving or publishing.\r\n * (e.g., length, range, format).\r\n *\r\n * Drafts have limited validations (mainly max constraints),\r\n * while published content undergoes full validation.\r\n *\r\n * The system also takes locales into account when validating data.\r\n * E.g, unique fields must be unique within the same locale.\r\n */\r\nimport _ from 'lodash';\r\nimport { yup } from '@strapi/utils';\r\nimport type { Schema, Struct, Modules } from '@strapi/types';\r\nimport { blocksValidator } from './blocks-validator';\r\n\r\nimport type { ComponentContext } from '.';\r\n\r\nexport interface ValidatorMetas<\r\n  TAttribute extends Schema.Attribute.AnyAttribute = Schema.Attribute.AnyAttribute,\r\n  TValue extends Schema.Attribute.Value<TAttribute> = Schema.Attribute.Value<TAttribute>,\r\n> {\r\n  attr: TAttribute;\r\n  model: Struct.Schema;\r\n  updatedAttribute: {\r\n    name: string;\r\n    value: TValue;\r\n  };\r\n  componentContext?: ComponentContext;\r\n  entity?: Modules.EntityValidator.Entity;\r\n}\r\n\r\ninterface ValidatorOptions {\r\n  isDraft: boolean;\r\n  locale?: string;\r\n}\r\n\r\n/* Validator utils */\r\n\r\n/**\r\n * Adds minLength validator\r\n */\r\nconst addMinLengthValidator = (\r\n  validator: yup.StringSchema,\r\n  {\r\n    attr,\r\n  }: {\r\n    attr:\r\n      | Schema.Attribute.String\r\n      | Schema.Attribute.Text\r\n      | Schema.Attribute.RichText\r\n      | Schema.Attribute.Password\r\n      | Schema.Attribute.Email\r\n      | Schema.Attribute.UID;\r\n  },\r\n  { isDraft }: ValidatorOptions\r\n) => {\r\n  return attr.minLength && _.isInteger(attr.minLength) && !isDraft\r\n    ? validator.min(attr.minLength)\r\n    : validator;\r\n};\r\n\r\n/**\r\n * Adds maxLength validator\r\n * @returns {StringSchema}\r\n */\r\nconst addMaxLengthValidator = (\r\n  validator: yup.StringSchema,\r\n  {\r\n    attr,\r\n  }: {\r\n    attr:\r\n      | Schema.Attribute.String\r\n      | Schema.Attribute.Text\r\n      | Schema.Attribute.RichText\r\n      | Schema.Attribute.Password\r\n      | Schema.Attribute.Email\r\n      | Schema.Attribute.UID;\r\n  }\r\n) => {\r\n  return attr.maxLength && _.isInteger(attr.maxLength) ? validator.max(attr.maxLength) : validator;\r\n};\r\n\r\n/**\r\n * Adds min integer validator\r\n * @returns {NumberSchema}\r\n */\r\nconst addMinIntegerValidator = (\r\n  validator: yup.NumberSchema,\r\n  {\r\n    attr,\r\n  }: {\r\n    attr: Schema.Attribute.Integer | Schema.Attribute.BigInteger;\r\n  },\r\n  { isDraft }: ValidatorOptions\r\n) => (_.isNumber(attr.min) && !isDraft ? validator.min(_.toInteger(attr.min)) : validator);\r\n\r\n/**\r\n * Adds max integer validator\r\n */\r\nconst addMaxIntegerValidator = (\r\n  validator: yup.NumberSchema,\r\n  {\r\n    attr,\r\n  }: {\r\n    attr: Schema.Attribute.Integer | Schema.Attribute.BigInteger;\r\n  }\r\n) => (_.isNumber(attr.max) ? validator.max(_.toInteger(attr.max)) : validator);\r\n\r\n/**\r\n * Adds min float/decimal validator\r\n */\r\nconst addMinFloatValidator = (\r\n  validator: yup.NumberSchema,\r\n  {\r\n    attr,\r\n  }: {\r\n    attr: Schema.Attribute.Decimal | Schema.Attribute.Float;\r\n  },\r\n  { isDraft }: ValidatorOptions\r\n) => (_.isNumber(attr.min) && !isDraft ? validator.min(attr.min) : validator);\r\n\r\n/**\r\n * Adds max float/decimal validator\r\n */\r\nconst addMaxFloatValidator = (\r\n  validator: yup.NumberSchema,\r\n  {\r\n    attr,\r\n  }: {\r\n    attr: Schema.Attribute.Decimal | Schema.Attribute.Float;\r\n  }\r\n) => (_.isNumber(attr.max) ? validator.max(attr.max) : validator);\r\n\r\n/**\r\n * Adds regex validator\r\n */\r\nconst addStringRegexValidator = (\r\n  validator: yup.StringSchema,\r\n  {\r\n    attr,\r\n  }: {\r\n    attr:\r\n      | Schema.Attribute.String\r\n      | Schema.Attribute.Text\r\n      | Schema.Attribute.RichText\r\n      | Schema.Attribute.Password\r\n      | Schema.Attribute.Email\r\n      | Schema.Attribute.UID;\r\n  },\r\n  { isDraft }: ValidatorOptions\r\n) => {\r\n  return 'regex' in attr && !_.isUndefined(attr.regex) && !isDraft\r\n    ? validator.matches(new RegExp(attr.regex), { excludeEmptyString: !attr.required })\r\n    : validator;\r\n};\r\n\r\nconst addUniqueValidator = <T extends yup.AnySchema>(\r\n  validator: T,\r\n  {\r\n    attr,\r\n    model,\r\n    updatedAttribute,\r\n    entity,\r\n    componentContext,\r\n  }: ValidatorMetas<Schema.Attribute.AnyAttribute & Schema.Attribute.UniqueOption>,\r\n  options: ValidatorOptions\r\n): T => {\r\n  if (attr.type !== 'uid' && !attr.unique) {\r\n    return validator;\r\n  }\r\n\r\n  const validateUniqueFieldWithinComponent = async (value: any): Promise<boolean> => {\r\n    if (!componentContext) {\r\n      return false;\r\n    }\r\n\r\n    // If we are validating a unique field within a repeatable component,\r\n    // we first need to ensure that the repeatable in the current entity is\r\n    // valid against itself.\r\n    const hasRepeatableData = componentContext.repeatableData.length > 0;\r\n    if (hasRepeatableData) {\r\n      const { name: updatedName, value: updatedValue } = updatedAttribute;\r\n      // Construct the full path to the unique field within the component.\r\n      const pathToCheck = [...componentContext.pathToComponent.slice(1), updatedName].join('.');\r\n\r\n      // Extract the values from the repeatable data using the constructed path\r\n      const values = componentContext.repeatableData.map((item) => {\r\n        return pathToCheck.split('.').reduce((acc, key) => acc[key], item as any);\r\n      });\r\n\r\n      // Check if the value is repeated in the current entity\r\n      const isUpdatedAttributeRepeatedInThisEntity =\r\n        values.filter((value) => value === updatedValue).length > 1;\r\n\r\n      if (isUpdatedAttributeRepeatedInThisEntity) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * When `componentContext` is present it means we are dealing with a unique\r\n     * field within a component.\r\n     *\r\n     * The unique validation must consider the specific context of the\r\n     * component, which will always be contained within a parent content type\r\n     * and may also be nested within another component.\r\n     *\r\n     * We construct a query that takes into account the parent's model UID,\r\n     * dimensions (such as draft and publish state/locale) and excludes the current\r\n     * content type entity by its ID if provided.\r\n     */\r\n    const {\r\n      model: parentModel,\r\n      options: parentOptions,\r\n      id: excludeId,\r\n    } = componentContext.parentContent;\r\n\r\n    const whereConditions: Record<string, any> = {};\r\n    const isParentDraft = parentOptions && parentOptions.isDraft;\r\n\r\n    whereConditions.publishedAt = isParentDraft ? null : { $notNull: true };\r\n\r\n    if (parentOptions?.locale) {\r\n      whereConditions.locale = parentOptions.locale;\r\n    }\r\n\r\n    if (excludeId && !Number.isNaN(excludeId)) {\r\n      whereConditions.id = { $ne: excludeId };\r\n    }\r\n\r\n    const queryUid = parentModel.uid;\r\n    const queryWhere = {\r\n      ...componentContext.pathToComponent.reduceRight((acc, key) => ({ [key]: acc }), {\r\n        [updatedAttribute.name]: value,\r\n      }),\r\n\r\n      ...whereConditions,\r\n    };\r\n\r\n    // The validation should pass if there is no other record found from the query\r\n    return !(await strapi.db.query(queryUid).findOne({ where: queryWhere }));\r\n  };\r\n\r\n  const validateUniqueFieldWithinDynamicZoneComponent = async (\r\n    startOfPath: string\r\n  ): Promise<boolean> => {\r\n    if (!componentContext) {\r\n      return false;\r\n    }\r\n\r\n    const targetComponentUID = model.uid;\r\n    // Ensure that the value is unique within the dynamic zone in this entity.\r\n    const countOfValueInThisEntity = (componentContext?.fullDynamicZoneContent ?? []).reduce(\r\n      (acc, component) => {\r\n        if (component.__component !== targetComponentUID) {\r\n          return acc;\r\n        }\r\n\r\n        const updatedValue = component[updatedAttribute.name];\r\n        return updatedValue === updatedAttribute.value ? acc + 1 : acc;\r\n      },\r\n      0\r\n    );\r\n\r\n    if (countOfValueInThisEntity > 1) {\r\n      // If the value is repeated in the current entity, the validation fails.\r\n      return false;\r\n    }\r\n\r\n    // Build a query for the parent content type to find all entities in the\r\n    // same locale and publication state\r\n    type QueryType = {\r\n      select: string[];\r\n      where: {\r\n        published_at?: { $eq: null } | { $ne: null };\r\n        id?: { $ne: number };\r\n        locale?: string;\r\n      };\r\n      populate: {\r\n        [key: string]: {\r\n          on: {\r\n            [key: string]: {\r\n              select: string[];\r\n              where: { [key: string]: string | number | boolean };\r\n            };\r\n          };\r\n        };\r\n      };\r\n    };\r\n\r\n    // Populate the dynamic zone for any components that share the same value\r\n    // as the updated attribute.\r\n    const query: QueryType = {\r\n      select: ['id'],\r\n      where: {},\r\n      populate: {\r\n        [startOfPath]: {\r\n          on: {\r\n            [targetComponentUID]: {\r\n              select: ['id'],\r\n              where: { [updatedAttribute.name]: updatedAttribute.value },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    };\r\n\r\n    const { options, id } = componentContext.parentContent;\r\n\r\n    if (options?.isDraft !== undefined) {\r\n      query.where.published_at = options.isDraft ? { $eq: null } : { $ne: null };\r\n    }\r\n\r\n    if (id) {\r\n      query.where.id = { $ne: id };\r\n    }\r\n\r\n    if (options?.locale) {\r\n      query.where.locale = options.locale;\r\n    }\r\n\r\n    const parentModelQueryResult = await strapi.db\r\n      .query(componentContext.parentContent.model.uid)\r\n      .findMany(query);\r\n\r\n    // Filter the results to only include results that have components in the\r\n    // dynamic zone that match the target component type.\r\n    const filteredResults = parentModelQueryResult\r\n      .filter((result) => Array.isArray(result[startOfPath]) && result[startOfPath].length)\r\n      .flatMap((result) => result[startOfPath])\r\n      .filter((dynamicZoneComponent) => dynamicZoneComponent.__component === targetComponentUID);\r\n\r\n    if (filteredResults.length >= 1) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  return validator.test('unique', 'This attribute must be unique', async (value) => {\r\n    /**\r\n     * If the attribute value is `null` or an empty string we want to skip the unique validation.\r\n     * Otherwise it'll only accept a single entry with that value in the database.\r\n     */\r\n    if (_.isNil(value) || value === '') {\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * We don't validate any unique constraint for draft entries.\r\n     */\r\n    if (options.isDraft) {\r\n      return true;\r\n    }\r\n\r\n    const hasPathToComponent = componentContext && componentContext.pathToComponent.length > 0;\r\n    if (hasPathToComponent) {\r\n      // Detect if we are validating within a dynamiczone by checking if the first\r\n      // path is a dynamiczone attribute in the parent content type.\r\n      const startOfPath = componentContext.pathToComponent[0];\r\n      const testingDZ =\r\n        componentContext.parentContent.model.attributes[startOfPath].type === 'dynamiczone';\r\n\r\n      if (testingDZ) {\r\n        return validateUniqueFieldWithinDynamicZoneComponent(startOfPath);\r\n      }\r\n\r\n      return validateUniqueFieldWithinComponent(value);\r\n    }\r\n\r\n    /**\r\n     * Here we are validating a scalar unique field from the content type's schema.\r\n     * We construct a query to check if the value is unique\r\n     * considering dimensions (e.g. locale, publication state) and excluding the current entity by its ID if available.\r\n     */\r\n    const scalarAttributeWhere: Record<string, any> = {\r\n      [updatedAttribute.name]: value,\r\n      publishedAt: { $notNull: true },\r\n    };\r\n\r\n    if (options?.locale) {\r\n      scalarAttributeWhere.locale = options.locale;\r\n    }\r\n\r\n    if (entity?.id) {\r\n      scalarAttributeWhere.id = { $ne: entity.id };\r\n    }\r\n\r\n    // The validation should pass if there is no other record found from the query\r\n    return !(await strapi.db\r\n      .query(model.uid)\r\n      .findOne({ where: scalarAttributeWhere, select: ['id'] }));\r\n  });\r\n};\r\n\r\n/* Type validators */\r\n\r\nconst stringValidator = (\r\n  metas: ValidatorMetas<\r\n    | Schema.Attribute.String\r\n    | Schema.Attribute.Text\r\n    | Schema.Attribute.RichText\r\n    | Schema.Attribute.Password\r\n    | Schema.Attribute.Email\r\n    | Schema.Attribute.UID\r\n  >,\r\n  options: ValidatorOptions\r\n) => {\r\n  let schema = yup.string().transform((val, originalVal) => originalVal);\r\n\r\n  schema = addMinLengthValidator(schema, metas, options);\r\n  schema = addMaxLengthValidator(schema, metas);\r\n  schema = addStringRegexValidator(schema, metas, options);\r\n  schema = addUniqueValidator(schema, metas, options);\r\n\r\n  return schema;\r\n};\r\n\r\nexport const emailValidator = (\r\n  metas: ValidatorMetas<Schema.Attribute.Email>,\r\n  options: ValidatorOptions\r\n) => {\r\n  const schema = stringValidator(metas, options);\r\n\r\n  if (options.isDraft) {\r\n    return schema;\r\n  }\r\n\r\n  return schema.email().min(\r\n    1,\r\n    // eslint-disable-next-line no-template-curly-in-string\r\n    '${path} cannot be empty'\r\n  );\r\n};\r\n\r\nexport const uidValidator = (\r\n  metas: ValidatorMetas<Schema.Attribute.UID>,\r\n  options: ValidatorOptions\r\n) => {\r\n  const schema = stringValidator(metas, options);\r\n\r\n  if (options.isDraft) {\r\n    return schema;\r\n  }\r\n\r\n  return schema.matches(/^[A-Za-z0-9-_.~]*$/);\r\n};\r\n\r\nexport const enumerationValidator = ({ attr }: { attr: Schema.Attribute.Enumeration }) => {\r\n  return yup\r\n    .string()\r\n    .oneOf((Array.isArray(attr.enum) ? attr.enum : [attr.enum]).concat(null as any));\r\n};\r\n\r\nexport const integerValidator = (\r\n  metas: ValidatorMetas<Schema.Attribute.Integer | Schema.Attribute.BigInteger>,\r\n  options: ValidatorOptions\r\n) => {\r\n  let schema = yup.number().integer();\r\n\r\n  schema = addMinIntegerValidator(schema, metas, options);\r\n  schema = addMaxIntegerValidator(schema, metas);\r\n  schema = addUniqueValidator(schema, metas, options);\r\n\r\n  return schema;\r\n};\r\n\r\nexport const floatValidator = (\r\n  metas: ValidatorMetas<Schema.Attribute.Decimal | Schema.Attribute.Float>,\r\n  options: ValidatorOptions\r\n) => {\r\n  let schema = yup.number();\r\n\r\n  schema = addMinFloatValidator(schema, metas, options);\r\n  schema = addMaxFloatValidator(schema, metas);\r\n  schema = addUniqueValidator(schema, metas, options);\r\n\r\n  return schema;\r\n};\r\n\r\nexport const bigintegerValidator = (\r\n  metas: ValidatorMetas<Schema.Attribute.BigInteger>,\r\n  options: ValidatorOptions\r\n) => {\r\n  const schema = yup.mixed();\r\n  return addUniqueValidator(schema, metas, options);\r\n};\r\n\r\nexport const datesValidator = (\r\n  metas: ValidatorMetas<\r\n    | Schema.Attribute.Date\r\n    | Schema.Attribute.DateTime\r\n    | Schema.Attribute.Time\r\n    | Schema.Attribute.Timestamp\r\n  >,\r\n  options: ValidatorOptions\r\n) => {\r\n  const schema = yup.mixed();\r\n  return addUniqueValidator(schema, metas, options);\r\n};\r\n\r\nexport const Validators = {\r\n  string: stringValidator,\r\n  text: stringValidator,\r\n  richtext: stringValidator,\r\n  password: stringValidator,\r\n  email: emailValidator,\r\n  enumeration: enumerationValidator,\r\n  boolean: () => yup.boolean(),\r\n  uid: uidValidator,\r\n  json: () => yup.mixed(),\r\n  integer: integerValidator,\r\n  biginteger: bigintegerValidator,\r\n  float: floatValidator,\r\n  decimal: floatValidator,\r\n  date: datesValidator,\r\n  time: datesValidator,\r\n  datetime: datesValidator,\r\n  timestamp: datesValidator,\r\n  blocks: blocksValidator,\r\n};\r\n"],"names":["_","value","options","yup","blocksValidator"],"mappings":"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"}