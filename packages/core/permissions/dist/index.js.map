{"version":3,"file":"index.js","sources":["../src/domain/permission/index.ts","../src/engine/hooks.ts","../src/engine/abilities/casl-ability.ts","../src/engine/index.ts"],"sourcesContent":["import _ from 'lodash/fp';\r\n\r\nconst PERMISSION_FIELDS = ['action', 'subject', 'properties', 'conditions'] as const;\r\n\r\nconst sanitizePermissionFields = _.pick(PERMISSION_FIELDS);\r\n\r\nexport interface Permission {\r\n  action: string;\r\n  actionParameters?: Record<string, unknown>;\r\n  subject?: string | object | null;\r\n  properties?: Record<string, any>;\r\n  conditions?: string[];\r\n}\r\n\r\n/**\r\n * Creates a permission with default values for optional properties\r\n */\r\nconst getDefaultPermission = (): Pick<Permission, 'conditions' | 'properties' | 'subject'> => ({\r\n  conditions: [],\r\n  properties: {},\r\n  subject: null,\r\n});\r\n\r\n/**\r\n * Create a new permission based on given attributes\r\n *\r\n * @param {object} attributes\r\n */\r\nconst create = _.pipe(_.pick(PERMISSION_FIELDS), _.merge(getDefaultPermission()));\r\n\r\n/**\r\n * Add a condition to a permission\r\n */\r\nconst addCondition = _.curry((condition: string, permission: Permission): Permission => {\r\n  const { conditions } = permission;\r\n\r\n  const newConditions = Array.isArray(conditions)\r\n    ? _.uniq(conditions.concat(condition))\r\n    : [condition];\r\n\r\n  return _.set('conditions', newConditions, permission);\r\n});\r\n\r\n/**\r\n * Gets a property or a part of a property from a permission.\r\n */\r\nconst getProperty = _.curry(\r\n  <T extends keyof Permission['properties']>(\r\n    property: T,\r\n    permission: Permission\r\n  ): Permission['properties'][T] => _.get(`properties.${property}`, permission)\r\n);\r\n\r\nexport { create, sanitizePermissionFields, addCondition, getProperty };\r\n","import { cloneDeep, has, isArray } from 'lodash/fp';\r\nimport { hooks } from '@strapi/utils';\r\n\r\nimport * as domain from '../domain';\r\nimport type { Permission } from '../domain/permission';\r\nimport type { PermissionRule } from '../types';\r\n\r\nexport interface PermissionEngineHooks {\r\n  'before-format::validate.permission': ReturnType<typeof hooks.createAsyncBailHook>;\r\n  'format.permission': ReturnType<typeof hooks.createAsyncSeriesWaterfallHook>;\r\n  'after-format::validate.permission': ReturnType<typeof hooks.createAsyncBailHook>;\r\n  'before-evaluate.permission': ReturnType<typeof hooks.createAsyncSeriesHook>;\r\n  'before-register.permission': ReturnType<typeof hooks.createAsyncSeriesHook>;\r\n}\r\n\r\nexport type HookName = keyof PermissionEngineHooks;\r\n\r\n/**\r\n * Create a hook map used by the permission Engine\r\n */\r\nconst createEngineHooks = (): PermissionEngineHooks => ({\r\n  'before-format::validate.permission': hooks.createAsyncBailHook(),\r\n  'format.permission': hooks.createAsyncSeriesWaterfallHook(),\r\n  'after-format::validate.permission': hooks.createAsyncBailHook(),\r\n  'before-evaluate.permission': hooks.createAsyncSeriesHook(),\r\n  'before-register.permission': hooks.createAsyncSeriesHook(),\r\n});\r\n\r\n/**\r\n * Create a context from a domain {@link Permission} used by the validate hooks\r\n */\r\nconst createValidateContext = (permission: Permission) => ({\r\n  get permission(): Readonly<Permission> {\r\n    return cloneDeep(permission);\r\n  },\r\n});\r\n\r\n/**\r\n * Create a context from a domain {@link Permission} used by the before valuate hook\r\n */\r\nconst createBeforeEvaluateContext = (permission: Permission) => ({\r\n  get permission(): Readonly<Permission> {\r\n    return cloneDeep(permission);\r\n  },\r\n\r\n  addCondition(condition: string) {\r\n    Object.assign(permission, domain.permission.addCondition(condition, permission));\r\n\r\n    return this;\r\n  },\r\n});\r\n\r\ninterface WillRegisterContextParams {\r\n  permission: PermissionRule;\r\n  options: Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * Create a context from a casl Permission & some options\r\n * @param caslPermission\r\n */\r\nconst createWillRegisterContext = ({ permission, options }: WillRegisterContextParams) => ({\r\n  ...options,\r\n\r\n  get permission() {\r\n    return cloneDeep(permission);\r\n  },\r\n\r\n  condition: {\r\n    and(rawConditionObject: unknown) {\r\n      if (!permission.condition) {\r\n        permission.condition = { $and: [] };\r\n      }\r\n\r\n      if (isArray(permission.condition.$and)) {\r\n        permission.condition.$and.push(rawConditionObject);\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    or(rawConditionObject: unknown) {\r\n      if (!permission.condition) {\r\n        permission.condition = { $and: [] };\r\n      }\r\n\r\n      if (isArray(permission.condition.$and)) {\r\n        const orClause = permission.condition.$and.find(has('$or'));\r\n\r\n        if (orClause) {\r\n          orClause.$or.push(rawConditionObject);\r\n        } else {\r\n          permission.condition.$and.push({ $or: [rawConditionObject] });\r\n        }\r\n      }\r\n\r\n      return this;\r\n    },\r\n  },\r\n});\r\n\r\nexport {\r\n  createEngineHooks,\r\n  createValidateContext,\r\n  createBeforeEvaluateContext,\r\n  createWillRegisterContext,\r\n};\r\n","import * as sift from 'sift';\r\nimport qs from 'qs';\r\nimport { AbilityBuilder, Ability } from '@casl/ability';\r\nimport { pick, isNil, isObject } from 'lodash/fp';\r\nimport type { ParametrizedAction, PermissionRule } from '../../types';\r\n\r\nexport interface CustomAbilityBuilder {\r\n  can(permission: PermissionRule): ReturnType<AbilityBuilder<Ability>['can']>;\r\n  buildParametrizedAction: (parametrizedAction: ParametrizedAction) => string;\r\n  build(): Ability;\r\n}\r\n\r\nconst allowedOperations = [\r\n  '$or',\r\n  '$and',\r\n  '$eq',\r\n  '$ne',\r\n  '$in',\r\n  '$nin',\r\n  '$lt',\r\n  '$lte',\r\n  '$gt',\r\n  '$gte',\r\n  '$exists',\r\n  '$elemMatch',\r\n] as const;\r\n\r\nconst operations = pick(allowedOperations, sift);\r\n\r\nconst conditionsMatcher = (conditions: unknown) => {\r\n  return sift.createQueryTester(conditions, { operations });\r\n};\r\n\r\nconst buildParametrizedAction = ({ name, params }: ParametrizedAction) => {\r\n  return `${name}?${qs.stringify(params)}`;\r\n};\r\n\r\n/**\r\n * Casl Ability Builder.\r\n */\r\nexport const caslAbilityBuilder = (): CustomAbilityBuilder => {\r\n  const { can, build, ...rest } = new AbilityBuilder(Ability);\r\n\r\n  return {\r\n    can(permission: PermissionRule) {\r\n      const { action, subject, properties = {}, condition } = permission;\r\n      const { fields } = properties;\r\n\r\n      const caslAction = typeof action === 'string' ? action : buildParametrizedAction(action);\r\n\r\n      return can(\r\n        caslAction,\r\n        isNil(subject) ? 'all' : subject,\r\n        fields,\r\n        isObject(condition) ? condition : undefined\r\n      );\r\n    },\r\n\r\n    buildParametrizedAction({ name, params }: ParametrizedAction) {\r\n      return `${name}?${qs.stringify(params)}`;\r\n    },\r\n\r\n    build() {\r\n      const ability = build({ conditionsMatcher });\r\n\r\n      function decorateCan(originalCan: Ability['can']) {\r\n        return function (...args: Parameters<Ability['can']>) {\r\n          const [action, ...rest] = args;\r\n          const caslAction = typeof action === 'string' ? action : buildParametrizedAction(action);\r\n\r\n          // Call the original `can` method\r\n          return originalCan.apply(ability, [caslAction, ...rest]);\r\n        };\r\n      }\r\n\r\n      ability.can = decorateCan(ability.can);\r\n      return ability;\r\n    },\r\n\r\n    ...rest,\r\n  };\r\n};\r\n","import _ from 'lodash/fp';\r\nimport qs from 'qs';\r\nimport { Ability } from '@casl/ability';\r\nimport { providerFactory } from '@strapi/utils';\r\n\r\nimport {\r\n  createEngineHooks,\r\n  createWillRegisterContext,\r\n  createBeforeEvaluateContext,\r\n  createValidateContext,\r\n} from './hooks';\r\nimport type { PermissionEngineHooks, HookName } from './hooks';\r\n\r\nimport * as abilities from './abilities';\r\nimport { Permission } from '../domain/permission';\r\nimport type { PermissionRule } from '../types';\r\n\r\nexport { abilities };\r\n\r\ntype Provider = Omit<ReturnType<typeof providerFactory>, 'register'> & {\r\n  register(...args: unknown[]): Promise<Provider> | Provider;\r\n};\r\n\r\ntype ActionProvider = Provider;\r\ntype ConditionProvider = Provider;\r\n\r\nexport interface Engine {\r\n  hooks: PermissionEngineHooks;\r\n  on(hook: HookName, handler: (...args: any[]) => any): Engine;\r\n  generateAbility(permissions: Permission[], options?: object): Promise<Ability>;\r\n  createRegisterFunction(\r\n    can: (permission: PermissionRule) => unknown,\r\n    options: Record<string, unknown>\r\n  ): (permission: PermissionRule) => Promise<unknown>;\r\n}\r\n\r\nexport interface EngineParams {\r\n  providers: { action: ActionProvider; condition: ConditionProvider };\r\n  abilityBuilderFactory?(): abilities.CustomAbilityBuilder;\r\n}\r\n\r\ninterface EvaluateParams {\r\n  options: Record<string, unknown>;\r\n  register: (permission: PermissionRule) => Promise<unknown>;\r\n  permission: Permission;\r\n}\r\n\r\ninterface Condition {\r\n  name: string;\r\n  handler(...params: unknown[]): boolean | object;\r\n}\r\n\r\n/**\r\n * Create a default state object for the engine\r\n */\r\nconst createEngineState = () => {\r\n  const hooks = createEngineHooks();\r\n\r\n  return { hooks };\r\n};\r\n\r\nconst newEngine = (params: EngineParams): Engine => {\r\n  const { providers, abilityBuilderFactory = abilities.caslAbilityBuilder } = params;\r\n\r\n  const state = createEngineState();\r\n\r\n  const runValidationHook = async (hook: HookName, context: unknown) =>\r\n    state.hooks[hook].call(context);\r\n\r\n  /**\r\n   * Evaluate a permission using local and registered behaviors (using hooks).\r\n   * Validate, format (add condition, etc...), evaluate (evaluate conditions) and register a permission\r\n   */\r\n  const evaluate = async (params: EvaluateParams) => {\r\n    const { options, register } = params;\r\n\r\n    const preFormatValidation = await runValidationHook(\r\n      'before-format::validate.permission',\r\n      createBeforeEvaluateContext(params.permission)\r\n    );\r\n\r\n    if (preFormatValidation === false) {\r\n      return;\r\n    }\r\n\r\n    const permission = (await state.hooks['format.permission'].call(\r\n      params.permission\r\n    )) as Permission;\r\n\r\n    const afterFormatValidation = await runValidationHook(\r\n      'after-format::validate.permission',\r\n      createValidateContext(permission)\r\n    );\r\n\r\n    if (afterFormatValidation === false) {\r\n      return;\r\n    }\r\n\r\n    await state.hooks['before-evaluate.permission'].call(createBeforeEvaluateContext(permission));\r\n\r\n    const {\r\n      action: actionName,\r\n      subject,\r\n      properties,\r\n      conditions = [],\r\n      actionParameters = {},\r\n    } = permission;\r\n\r\n    let action = actionName;\r\n\r\n    if (actionParameters && Object.keys(actionParameters).length > 0) {\r\n      action = `${actionName}?${qs.stringify(actionParameters)}`;\r\n    }\r\n\r\n    if (conditions.length === 0) {\r\n      return register({ action, subject, properties });\r\n    }\r\n\r\n    const resolveConditions = _.map(providers.condition.get);\r\n\r\n    const removeInvalidConditions = _.filter((condition: Condition) =>\r\n      _.isFunction(condition.handler)\r\n    );\r\n\r\n    const evaluateConditions = (conditions: Condition[]) => {\r\n      return Promise.all(\r\n        conditions.map(async (condition) => ({\r\n          condition,\r\n          result: await condition.handler(\r\n            _.merge(options, { permission: _.cloneDeep(permission) })\r\n          ),\r\n        }))\r\n      );\r\n    };\r\n\r\n    const removeInvalidResults = _.filter(\r\n      ({ result }) => _.isBoolean(result) || _.isObject(result)\r\n    );\r\n\r\n    const evaluatedConditions = await Promise.resolve(conditions)\r\n      .then(resolveConditions)\r\n      .then(removeInvalidConditions)\r\n      .then(evaluateConditions)\r\n      .then(removeInvalidResults);\r\n\r\n    const resultPropEq = _.propEq('result');\r\n    const pickResults = _.map(_.prop('result'));\r\n\r\n    if (evaluatedConditions.every(resultPropEq(false))) {\r\n      return;\r\n    }\r\n\r\n    if (_.isEmpty(evaluatedConditions) || evaluatedConditions.some(resultPropEq(true))) {\r\n      return register({ action, subject, properties });\r\n    }\r\n\r\n    const results = pickResults(evaluatedConditions).filter(_.isObject);\r\n\r\n    if (_.isEmpty(results)) {\r\n      return register({ action, subject, properties });\r\n    }\r\n\r\n    return register({\r\n      action,\r\n      subject,\r\n      properties,\r\n      condition: { $and: [{ $or: results }] },\r\n    });\r\n  };\r\n\r\n  return {\r\n    get hooks() {\r\n      return state.hooks;\r\n    },\r\n\r\n    /**\r\n     * Create a register function that wraps a `can` function\r\n     * used to register a permission in the ability builder\r\n     */\r\n    createRegisterFunction(can, options: Record<string, unknown>) {\r\n      return async (permission: PermissionRule) => {\r\n        const hookContext = createWillRegisterContext({ options, permission });\r\n\r\n        await state.hooks['before-register.permission'].call(hookContext);\r\n\r\n        return can(permission);\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Register a new handler for a given hook\r\n     */\r\n    on(hook, handler) {\r\n      const validHooks = Object.keys(state.hooks);\r\n      const isValidHook = validHooks.includes(hook);\r\n\r\n      if (!isValidHook) {\r\n        throw new Error(\r\n          `Invalid hook supplied when trying to register an handler to the permission engine. Got \"${hook}\" but expected one of ${validHooks.join(\r\n            ', '\r\n          )}`\r\n        );\r\n      }\r\n\r\n      state.hooks[hook].register(handler);\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Generate an ability based on the instance's\r\n     * ability builder and the given permissions\r\n     */\r\n    async generateAbility(permissions, options: Record<string, unknown> = {}) {\r\n      const { can, build } = abilityBuilderFactory();\r\n\r\n      for (const permission of permissions) {\r\n        const register = this.createRegisterFunction(can, options);\r\n\r\n        await evaluate({ permission, options, register });\r\n      }\r\n\r\n      return build();\r\n    },\r\n  };\r\n};\r\n\r\nexport { newEngine as new };\r\n"],"names":["_","hooks","cloneDeep","domain.permission.addCondition","isArray","has","pick","sift","qs","AbilityBuilder","Ability","isNil","isObject","ability","rest","abilities.caslAbilityBuilder","params","conditions"],"mappings":"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"}