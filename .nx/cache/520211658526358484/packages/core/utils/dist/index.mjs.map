{"version":3,"file":"index.mjs","sources":["../src/parse-type.ts","../src/env-helper.ts","../src/content-types.ts","../src/set-creator-fields.ts","../src/hooks.ts","../src/provider-factory.ts","../src/traverse-entity.ts","../src/import-default.ts","../src/machine-id.ts","../src/format-yup-error.ts","../src/errors.ts","../src/validators.ts","../src/operators.ts","../src/convert-query-params.ts","../src/async.ts","../src/sanitize/visitors/remove-password.ts","../src/sanitize/visitors/remove-private.ts","../src/relations.ts","../src/sanitize/visitors/remove-restricted-relations.ts","../src/sanitize/visitors/remove-morph-to-relations.ts","../src/sanitize/visitors/remove-dynamic-zones.ts","../src/sanitize/visitors/remove-disallowed-fields.ts","../src/sanitize/visitors/remove-restricted-fields.ts","../src/sanitize/visitors/expand-wildcard-populate.ts","../src/traverse/factory.ts","../src/traverse/query-filters.ts","../src/traverse/query-sort.ts","../src/traverse/query-populate.ts","../src/traverse/query-fields.ts","../src/sanitize/sanitizers.ts","../src/sanitize/index.ts","../src/validate/utils.ts","../src/validate/visitors/throw-password.ts","../src/validate/visitors/throw-private.ts","../src/validate/visitors/throw-restricted-relations.ts","../src/validate/visitors/throw-morph-to-relations.ts","../src/validate/visitors/throw-dynamic-zones.ts","../src/validate/visitors/throw-disallowed-fields.ts","../src/validate/visitors/throw-restricted-fields.ts","../src/validate/visitors/throw-unrecognized-fields.ts","../src/validate/validators.ts","../src/validate/index.ts","../src/pagination.ts","../src/package-manager.ts","../src/template.ts","../src/file.ts","../src/policy.ts","../src/primitives/strings.ts","../src/primitives/arrays.ts","../src/primitives/objects.ts","../src/primitives/dates.ts","../src/print-value.ts","../src/yup.ts","../src/zod.ts"],"sourcesContent":["import * as _ from 'lodash';\r\nimport * as dates from 'date-fns';\r\n\r\nconst timeRegex = /^(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(.[0-9]{1,3})?$/;\r\n\r\nconst isDate = (v: unknown): v is Date => {\r\n  return dates.isDate(v);\r\n};\r\n\r\nconst parseTime = (value: unknown): string => {\r\n  if (isDate(value)) {\r\n    return dates.format(value, 'HH:mm:ss.SSS');\r\n  }\r\n\r\n  if (typeof value !== 'string') {\r\n    throw new Error(`Expected a string, got a ${typeof value}`);\r\n  }\r\n  const result = value.match(timeRegex);\r\n\r\n  if (result === null) {\r\n    throw new Error('Invalid time format, expected HH:mm:ss.SSS');\r\n  }\r\n\r\n  const [, hours, minutes, seconds, fraction = '.000'] = result;\r\n  const fractionPart = _.padEnd(fraction.slice(1), 3, '0');\r\n\r\n  return `${hours}:${minutes}:${seconds}.${fractionPart}`;\r\n};\r\n\r\nconst parseDate = (value: unknown) => {\r\n  if (isDate(value)) {\r\n    return dates.format(value, 'yyyy-MM-dd');\r\n  }\r\n\r\n  if (typeof value !== 'string') {\r\n    throw new Error(`Expected a string, got a ${typeof value}`);\r\n  }\r\n\r\n  try {\r\n    const date = dates.parseISO(value);\r\n\r\n    if (dates.isValid(date)) return dates.format(date, 'yyyy-MM-dd');\r\n\r\n    throw new Error(`Invalid format, expected an ISO compatible date`);\r\n  } catch (error) {\r\n    throw new Error(`Invalid format, expected an ISO compatible date`);\r\n  }\r\n};\r\n\r\nconst parseDateTimeOrTimestamp = (value: unknown) => {\r\n  if (isDate(value)) {\r\n    return value;\r\n  }\r\n\r\n  if (typeof value !== 'string') {\r\n    throw new Error(`Expected a string, got a ${typeof value}`);\r\n  }\r\n\r\n  try {\r\n    const date = dates.parseISO(value);\r\n    if (dates.isValid(date)) return date;\r\n\r\n    const milliUnixDate = dates.parse(value, 'T', new Date());\r\n    if (dates.isValid(milliUnixDate)) return milliUnixDate;\r\n\r\n    throw new Error(`Invalid format, expected a timestamp or an ISO date`);\r\n  } catch (error) {\r\n    throw new Error(`Invalid format, expected a timestamp or an ISO date`);\r\n  }\r\n};\r\n\r\ntype TypeMap = {\r\n  boolean: boolean;\r\n  integer: number;\r\n  biginteger: number;\r\n  float: number;\r\n  decimal: number;\r\n  time: string;\r\n  date: string;\r\n  timestamp: Date;\r\n  datetime: Date;\r\n};\r\n\r\nexport interface ParseTypeOptions<T extends keyof TypeMap> {\r\n  type: T;\r\n  value: unknown;\r\n  forceCast?: boolean;\r\n}\r\n\r\nconst parseBoolean = (value: unknown, options: { forceCast?: boolean }): boolean => {\r\n  const { forceCast = false } = options;\r\n\r\n  if (typeof value === 'boolean') {\r\n    return value;\r\n  }\r\n\r\n  if (typeof value === 'string' || typeof value === 'number') {\r\n    if (['true', 't', '1', 1].includes(value)) {\r\n      return true;\r\n    }\r\n\r\n    if (['false', 'f', '0', 0].includes(value)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  if (forceCast) {\r\n    return Boolean(value);\r\n  }\r\n\r\n  throw new Error('Invalid boolean input. Expected \"t\",\"1\",\"true\",\"false\",\"0\",\"f\"');\r\n};\r\n\r\n/**\r\n * Cast basic values based on attribute type\r\n */\r\nconst parseType = <Type extends keyof TypeMap>(options: ParseTypeOptions<Type>): TypeMap[Type] => {\r\n  const { type, value, forceCast } = options;\r\n\r\n  switch (type) {\r\n    case 'boolean':\r\n      return parseBoolean(value, { forceCast }) as TypeMap[Type];\r\n    case 'integer':\r\n    case 'biginteger':\r\n    case 'float':\r\n    case 'decimal': {\r\n      return _.toNumber(value) as TypeMap[Type];\r\n    }\r\n    case 'time': {\r\n      return parseTime(value) as TypeMap[Type];\r\n    }\r\n    case 'date': {\r\n      return parseDate(value) as TypeMap[Type];\r\n    }\r\n    case 'timestamp':\r\n    case 'datetime': {\r\n      return parseDateTimeOrTimestamp(value) as TypeMap[Type];\r\n    }\r\n    default:\r\n      return value as TypeMap[Type];\r\n  }\r\n};\r\n\r\nexport default parseType;\r\n","import _ from 'lodash';\r\n\r\nexport type Env = typeof envFn & typeof utils;\r\n\r\nfunction envFn<T>(key: string, defaultValue?: T): string | T | undefined {\r\n  return _.has(process.env, key) ? process.env[key] : defaultValue;\r\n}\r\n\r\nfunction getKey(key: string) {\r\n  return process.env[key] ?? '';\r\n}\r\n\r\nconst utils = {\r\n  int(key: string, defaultValue?: number): number | undefined {\r\n    if (!_.has(process.env, key)) {\r\n      return defaultValue;\r\n    }\r\n\r\n    return parseInt(getKey(key), 10);\r\n  },\r\n\r\n  float(key: string, defaultValue?: number): number | undefined {\r\n    if (!_.has(process.env, key)) {\r\n      return defaultValue;\r\n    }\r\n\r\n    return parseFloat(getKey(key));\r\n  },\r\n\r\n  bool(key: string, defaultValue?: boolean): boolean | undefined {\r\n    if (!_.has(process.env, key)) {\r\n      return defaultValue;\r\n    }\r\n\r\n    return getKey(key) === 'true';\r\n  },\r\n\r\n  json(key: string, defaultValue?: object) {\r\n    if (!_.has(process.env, key)) {\r\n      return defaultValue;\r\n    }\r\n\r\n    try {\r\n      return JSON.parse(getKey(key));\r\n    } catch (error) {\r\n      if (error instanceof Error) {\r\n        throw new Error(`Invalid json environment variable ${key}: ${error.message}`);\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  array(key: string, defaultValue?: string[]): string[] | undefined {\r\n    if (!_.has(process.env, key)) {\r\n      return defaultValue;\r\n    }\r\n\r\n    let value = getKey(key);\r\n\r\n    if (value.startsWith('[') && value.endsWith(']')) {\r\n      value = value.substring(1, value.length - 1);\r\n    }\r\n\r\n    return value.split(',').map((v) => {\r\n      return _.trim(_.trim(v, ' '), '\"');\r\n    });\r\n  },\r\n\r\n  date(key: string, defaultValue?: Date): Date | undefined {\r\n    if (!_.has(process.env, key)) {\r\n      return defaultValue;\r\n    }\r\n\r\n    return new Date(getKey(key));\r\n  },\r\n\r\n  /**\r\n   * Gets a value from env that matches oneOf provided values\r\n   * @param {string} key\r\n   * @param {string[]} expectedValues\r\n   * @param {string|undefined} defaultValue\r\n   * @returns {string|undefined}\r\n   */\r\n  oneOf(key: string, expectedValues?: unknown[], defaultValue?: unknown) {\r\n    if (!expectedValues) {\r\n      throw new Error(`env.oneOf requires expectedValues`);\r\n    }\r\n\r\n    if (defaultValue && !expectedValues.includes(defaultValue)) {\r\n      throw new Error(`env.oneOf requires defaultValue to be included in expectedValues`);\r\n    }\r\n\r\n    const rawValue = env(key, defaultValue);\r\n    return expectedValues.includes(rawValue) ? rawValue : defaultValue;\r\n  },\r\n};\r\n\r\nconst env: Env = Object.assign(envFn, utils);\r\n\r\nexport default env;\r\n","import _ from 'lodash';\r\nimport { has, getOr, union } from 'lodash/fp';\r\nimport type {\r\n  Model,\r\n  Kind,\r\n  Attribute,\r\n  RelationalAttribute,\r\n  ComponentAttribute,\r\n  DynamicZoneAttribute,\r\n  WithRequired,\r\n} from './types';\r\n\r\nconst SINGLE_TYPE = 'singleType';\r\nconst COLLECTION_TYPE = 'collectionType';\r\n\r\nconst ID_ATTRIBUTE = 'id';\r\nconst DOC_ID_ATTRIBUTE = 'documentId';\r\n\r\nconst PUBLISHED_AT_ATTRIBUTE = 'publishedAt';\r\nconst CREATED_BY_ATTRIBUTE = 'createdBy';\r\nconst UPDATED_BY_ATTRIBUTE = 'updatedBy';\r\n\r\nconst CREATED_AT_ATTRIBUTE = 'createdAt';\r\nconst UPDATED_AT_ATTRIBUTE = 'updatedAt';\r\n\r\nconst constants = {\r\n  ID_ATTRIBUTE,\r\n  DOC_ID_ATTRIBUTE,\r\n  PUBLISHED_AT_ATTRIBUTE,\r\n  CREATED_BY_ATTRIBUTE,\r\n  UPDATED_BY_ATTRIBUTE,\r\n  CREATED_AT_ATTRIBUTE,\r\n  UPDATED_AT_ATTRIBUTE,\r\n  SINGLE_TYPE,\r\n  COLLECTION_TYPE,\r\n};\r\n\r\nconst getTimestamps = (model: Model) => {\r\n  const attributes: string[] = [];\r\n\r\n  if (has(CREATED_AT_ATTRIBUTE, model.attributes)) {\r\n    attributes.push(CREATED_AT_ATTRIBUTE);\r\n  }\r\n\r\n  if (has(UPDATED_AT_ATTRIBUTE, model.attributes)) {\r\n    attributes.push(UPDATED_AT_ATTRIBUTE);\r\n  }\r\n\r\n  return attributes;\r\n};\r\n\r\nconst getCreatorFields = (model: Model) => {\r\n  const attributes: string[] = [];\r\n\r\n  if (has(CREATED_BY_ATTRIBUTE, model.attributes)) {\r\n    attributes.push(CREATED_BY_ATTRIBUTE);\r\n  }\r\n\r\n  if (has(UPDATED_BY_ATTRIBUTE, model.attributes)) {\r\n    attributes.push(UPDATED_BY_ATTRIBUTE);\r\n  }\r\n\r\n  return attributes;\r\n};\r\n\r\nconst getNonWritableAttributes = (model: Model) => {\r\n  if (!model) return [];\r\n\r\n  const nonWritableAttributes = _.reduce(\r\n    model.attributes,\r\n    (acc, attr, attrName) => (attr.writable === false ? acc.concat(attrName) : acc),\r\n    [] as string[]\r\n  );\r\n\r\n  return _.uniq([\r\n    ID_ATTRIBUTE,\r\n    DOC_ID_ATTRIBUTE,\r\n    ...getTimestamps(model),\r\n    ...nonWritableAttributes,\r\n  ]);\r\n};\r\n\r\nconst getWritableAttributes = (model: Model) => {\r\n  if (!model) return [];\r\n\r\n  return _.difference(Object.keys(model.attributes), getNonWritableAttributes(model));\r\n};\r\n\r\nconst isWritableAttribute = (model: Model, attributeName: string) => {\r\n  return getWritableAttributes(model).includes(attributeName);\r\n};\r\n\r\nconst getNonVisibleAttributes = (model: Model) => {\r\n  const nonVisibleAttributes = _.reduce(\r\n    model.attributes,\r\n    (acc, attr, attrName) => (attr.visible === false ? acc.concat(attrName) : acc),\r\n    [] as string[]\r\n  );\r\n\r\n  return _.uniq([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE, ...getTimestamps(model), ...nonVisibleAttributes]);\r\n};\r\n\r\nconst getVisibleAttributes = (model: Model) => {\r\n  return _.difference(_.keys(model.attributes), getNonVisibleAttributes(model));\r\n};\r\n\r\nconst isVisibleAttribute = (model: Model, attributeName: string) => {\r\n  return getVisibleAttributes(model).includes(attributeName);\r\n};\r\n\r\nconst getOptions = (model: Model) =>\r\n  _.assign({ draftAndPublish: false }, _.get(model, 'options', {}));\r\n\r\nconst hasDraftAndPublish = (model: Model) =>\r\n  _.get(model, 'options.draftAndPublish', false) === true;\r\n\r\nconst isDraft = <T extends object>(data: T, model: Model) =>\r\n  hasDraftAndPublish(model) && _.get(data, PUBLISHED_AT_ATTRIBUTE) === null;\r\n\r\nconst isSchema = (data: unknown): data is Model => {\r\n  return (\r\n    typeof data === 'object' &&\r\n    data !== null &&\r\n    'modelType' in data &&\r\n    typeof data.modelType === 'string' &&\r\n    ['component', 'contentType'].includes(data.modelType)\r\n  );\r\n};\r\n\r\nconst isComponentSchema = (data: unknown): data is Model & { modelType: 'component' } => {\r\n  return isSchema(data) && data.modelType === 'component';\r\n};\r\n\r\nconst isContentTypeSchema = (data: unknown): data is Model & { modelType: 'contentType' } => {\r\n  return isSchema(data) && data.modelType === 'contentType';\r\n};\r\n\r\nconst isSingleType = ({ kind = COLLECTION_TYPE }) => kind === SINGLE_TYPE;\r\nconst isCollectionType = ({ kind = COLLECTION_TYPE }) => kind === COLLECTION_TYPE;\r\nconst isKind = (kind: Kind) => (model: Model) => model.kind === kind;\r\n\r\nconst getStoredPrivateAttributes = (model: Model) =>\r\n  union(\r\n    (strapi?.config?.get('api.responses.privateAttributes', []) ?? []) as Array<string>,\r\n    getOr([], 'options.privateAttributes', model)\r\n  );\r\n\r\nconst getPrivateAttributes = (model: Model) => {\r\n  return _.union(\r\n    getStoredPrivateAttributes(model),\r\n    _.keys(_.pickBy(model.attributes, (attr) => !!attr.private))\r\n  );\r\n};\r\n\r\nconst isPrivateAttribute = (model: Model, attributeName: string) => {\r\n  if (model?.attributes?.[attributeName]?.private === true) {\r\n    return true;\r\n  }\r\n  return getStoredPrivateAttributes(model).includes(attributeName);\r\n};\r\n\r\nconst isScalarAttribute = (attribute?: Attribute) => {\r\n  return attribute && !['media', 'component', 'relation', 'dynamiczone'].includes(attribute.type);\r\n};\r\n\r\nconst getDoesAttributeRequireValidation = (attribute: Attribute) => {\r\n  return (\r\n    attribute.required ||\r\n    attribute.unique ||\r\n    Object.prototype.hasOwnProperty.call(attribute, 'max') ||\r\n    Object.prototype.hasOwnProperty.call(attribute, 'min') ||\r\n    Object.prototype.hasOwnProperty.call(attribute, 'maxLength') ||\r\n    Object.prototype.hasOwnProperty.call(attribute, 'minLength')\r\n  );\r\n};\r\nconst isMediaAttribute = (attribute?: Attribute) => attribute?.type === 'media';\r\nconst isRelationalAttribute = (attribute?: Attribute): attribute is RelationalAttribute =>\r\n  attribute?.type === 'relation';\r\n\r\nconst HAS_RELATION_REORDERING = ['manyToMany', 'manyToOne', 'oneToMany'];\r\nconst hasRelationReordering = (attribute?: Attribute) =>\r\n  isRelationalAttribute(attribute) && HAS_RELATION_REORDERING.includes(attribute.relation);\r\n\r\nconst isComponentAttribute = (\r\n  attribute: Attribute\r\n): attribute is ComponentAttribute | DynamicZoneAttribute =>\r\n  ['component', 'dynamiczone'].includes(attribute?.type);\r\n\r\nconst isDynamicZoneAttribute = (attribute?: Attribute): attribute is DynamicZoneAttribute =>\r\n  !!attribute && attribute.type === 'dynamiczone';\r\nconst isMorphToRelationalAttribute = (attribute?: Attribute) => {\r\n  return (\r\n    !!attribute && isRelationalAttribute(attribute) && attribute.relation?.startsWith?.('morphTo')\r\n  );\r\n};\r\n\r\nconst getComponentAttributes = (schema: Model) => {\r\n  return _.reduce(\r\n    schema.attributes,\r\n    (acc, attr, attrName) => {\r\n      if (isComponentAttribute(attr)) acc.push(attrName);\r\n      return acc;\r\n    },\r\n    [] as string[]\r\n  );\r\n};\r\n\r\nconst getScalarAttributes = (schema: Model) => {\r\n  return _.reduce(\r\n    schema.attributes,\r\n    (acc, attr, attrName) => {\r\n      if (isScalarAttribute(attr)) acc.push(attrName);\r\n      return acc;\r\n    },\r\n    [] as string[]\r\n  );\r\n};\r\n\r\nconst getRelationalAttributes = (schema: Model) => {\r\n  return _.reduce(\r\n    schema.attributes,\r\n    (acc, attr, attrName) => {\r\n      if (isRelationalAttribute(attr)) acc.push(attrName);\r\n      return acc;\r\n    },\r\n    [] as string[]\r\n  );\r\n};\r\n\r\n/**\r\n * Checks if an attribute is of type `type`\r\n * @param {object} attribute\r\n * @param {string} type\r\n */\r\nconst isTypedAttribute = (attribute: Attribute, type: string) => {\r\n  return _.has(attribute, 'type') && attribute.type === type;\r\n};\r\n\r\n/**\r\n *  Returns a route prefix for a contentType\r\n * @param {object} contentType\r\n * @returns {string}\r\n */\r\nconst getContentTypeRoutePrefix = (contentType: WithRequired<Model, 'info'>) => {\r\n  return isSingleType(contentType)\r\n    ? _.kebabCase(contentType.info.singularName)\r\n    : _.kebabCase(contentType.info.pluralName);\r\n};\r\n\r\nexport {\r\n  isSchema,\r\n  isContentTypeSchema,\r\n  isComponentSchema,\r\n  isScalarAttribute,\r\n  isMediaAttribute,\r\n  isRelationalAttribute,\r\n  hasRelationReordering,\r\n  isComponentAttribute,\r\n  isDynamicZoneAttribute,\r\n  isMorphToRelationalAttribute,\r\n  isTypedAttribute,\r\n  getPrivateAttributes,\r\n  isPrivateAttribute,\r\n  constants,\r\n  getNonWritableAttributes,\r\n  getComponentAttributes,\r\n  getScalarAttributes,\r\n  getRelationalAttributes,\r\n  getWritableAttributes,\r\n  isWritableAttribute,\r\n  getNonVisibleAttributes,\r\n  getVisibleAttributes,\r\n  getTimestamps,\r\n  getCreatorFields,\r\n  isVisibleAttribute,\r\n  getOptions,\r\n  isDraft,\r\n  hasDraftAndPublish,\r\n  isSingleType,\r\n  isCollectionType,\r\n  isKind,\r\n  getContentTypeRoutePrefix,\r\n  getDoesAttributeRequireValidation,\r\n};\r\n","import { assign, assoc } from 'lodash/fp';\r\nimport * as contentTypes from './content-types';\r\n\r\nconst { CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE } = contentTypes.constants;\r\n\r\nexport interface Options {\r\n  user: User;\r\n  isEdition?: boolean;\r\n}\r\n\r\ninterface User {\r\n  id: string | number;\r\n}\r\n\r\nconst setCreatorFields =\r\n  <TData extends object>({ user, isEdition = false }: Options) =>\r\n  <TDataInner extends object = TData>(data: TDataInner) => {\r\n    if (isEdition) {\r\n      return assoc(UPDATED_BY_ATTRIBUTE, user.id, data);\r\n    }\r\n\r\n    return assign(data, {\r\n      [CREATED_BY_ATTRIBUTE]: user.id,\r\n      [UPDATED_BY_ATTRIBUTE]: user.id,\r\n    });\r\n  };\r\n\r\nexport default setCreatorFields;\r\n","import { eq, remove, cloneDeep } from 'lodash/fp';\r\n\r\nexport type Handler = (...args: any[]) => any;\r\n\r\nexport interface Hook<T extends Handler = Handler> {\r\n  getHandlers(): Handler[];\r\n  register(handler: T): Hook<T>;\r\n  delete(handler: T): Hook<T>;\r\n  call(...args: any[]): void;\r\n}\r\n\r\nexport interface AsyncSeriesHook extends Hook {\r\n  call(...args: any[]): Promise<void>;\r\n}\r\nexport interface AsyncSeriesWaterfallHook extends Hook {\r\n  call(...args: any[]): Promise<any>;\r\n}\r\n\r\nexport interface AsyncParallelHook extends Hook {\r\n  call(...args: any[]): Promise<any[]>;\r\n}\r\n\r\nexport interface AsyncBailHook extends Hook {\r\n  call(...args: any[]): Promise<any>;\r\n}\r\n\r\n/**\r\n * Create a default Strapi hook\r\n */\r\nconst createHook = <T extends Handler = Handler>(): Hook<T> => {\r\n  type State = {\r\n    handlers: T[];\r\n  };\r\n\r\n  const state: State = {\r\n    handlers: [],\r\n  };\r\n\r\n  return {\r\n    getHandlers() {\r\n      return state.handlers;\r\n    },\r\n\r\n    register(handler: T) {\r\n      state.handlers.push(handler);\r\n\r\n      return this;\r\n    },\r\n\r\n    delete(handler: T) {\r\n      state.handlers = remove(eq(handler), state.handlers);\r\n\r\n      return this;\r\n    },\r\n\r\n    call() {\r\n      throw new Error('Method not implemented');\r\n    },\r\n  };\r\n};\r\n\r\n/**\r\n * Create an async series hook.\r\n * Upon execution, it will execute every handler in order with the same context\r\n */\r\nconst createAsyncSeriesHook = <T extends Handler = Handler>() => ({\r\n  ...createHook<T>(),\r\n\r\n  async call(context: unknown) {\r\n    for (const handler of this.getHandlers()) {\r\n      await handler(context);\r\n    }\r\n  },\r\n});\r\n\r\n/**\r\n * Create an async series waterfall hook.\r\n * Upon execution, it will execute every handler in order and pass the return value of the last handler to the next one\r\n */\r\nconst createAsyncSeriesWaterfallHook = <T extends Handler = Handler>() => ({\r\n  ...createHook<T>(),\r\n\r\n  async call(param: unknown) {\r\n    let res = param;\r\n\r\n    for (const handler of this.getHandlers()) {\r\n      res = await handler(res);\r\n    }\r\n\r\n    return res;\r\n  },\r\n});\r\n\r\n/**\r\n * Create an async parallel hook.\r\n * Upon execution, it will execute every registered handler in band.\r\n */\r\nconst createAsyncParallelHook = <T extends Handler = Handler>() => ({\r\n  ...createHook<T>(),\r\n\r\n  async call(context: unknown) {\r\n    const promises = this.getHandlers().map((handler) => handler(cloneDeep(context)));\r\n\r\n    return Promise.all(promises);\r\n  },\r\n});\r\n\r\n/**\r\n * Create an async parallel hook.\r\n * Upon execution, it will execute every registered handler in serie and return the first result found.\r\n */\r\nconst createAsyncBailHook = <T extends Handler = Handler>() => ({\r\n  ...createHook<T>(),\r\n\r\n  async call(context: unknown) {\r\n    for (const handler of this.getHandlers()) {\r\n      const result = await handler(context);\r\n\r\n      if (result !== undefined) {\r\n        return result;\r\n      }\r\n    }\r\n  },\r\n});\r\n\r\nexport const internals = {\r\n  // Internal utils\r\n  createHook,\r\n};\r\n\r\nexport {\r\n  createAsyncSeriesHook,\r\n  createAsyncSeriesWaterfallHook,\r\n  createAsyncParallelHook,\r\n  createAsyncBailHook,\r\n};\r\n","import { cloneDeep } from 'lodash/fp';\r\nimport {\r\n  createAsyncSeriesHook,\r\n  createAsyncParallelHook,\r\n  AsyncSeriesHook,\r\n  AsyncParallelHook,\r\n} from './hooks';\r\n\r\nexport interface ProviderHooksMap {\r\n  willRegister: AsyncSeriesHook;\r\n  didRegister: AsyncParallelHook;\r\n  willDelete: AsyncParallelHook;\r\n  didDelete: AsyncParallelHook;\r\n}\r\n\r\n/**\r\n * Creates a new object containing various hooks used by the providers\r\n */\r\nconst createProviderHooksMap = (): ProviderHooksMap => ({\r\n  // Register events\r\n  willRegister: createAsyncSeriesHook(),\r\n  didRegister: createAsyncParallelHook(),\r\n  // Delete events\r\n  willDelete: createAsyncParallelHook(),\r\n  didDelete: createAsyncParallelHook(),\r\n});\r\n\r\nexport interface Options {\r\n  throwOnDuplicates?: boolean;\r\n}\r\n\r\ntype Item = Record<string, unknown>;\r\n\r\nexport interface Provider<T = unknown> {\r\n  hooks: ProviderHooksMap;\r\n  register(key: string, item: T): Promise<Provider>;\r\n  delete(key: string): Promise<Provider>;\r\n  get(key: string): T | undefined;\r\n  values(): T[];\r\n  keys(): string[];\r\n  has(key: string): boolean;\r\n  size(): number;\r\n  clear(): Promise<Provider<T>>;\r\n}\r\n\r\nexport type ProviderFactory<T> = (options?: Options) => Provider<T>;\r\n\r\n/**\r\n * A Provider factory\r\n */\r\nconst providerFactory = <T = Item>(options: Options = {}): Provider<T> => {\r\n  const { throwOnDuplicates = true } = options;\r\n\r\n  const state = {\r\n    hooks: createProviderHooksMap(),\r\n    registry: new Map<string, T>(),\r\n  };\r\n\r\n  return {\r\n    hooks: state.hooks,\r\n\r\n    async register(key: string, item: T) {\r\n      if (throwOnDuplicates && this.has(key)) {\r\n        throw new Error(`Duplicated item key: ${key}`);\r\n      }\r\n\r\n      await state.hooks.willRegister.call({ key, value: item });\r\n\r\n      state.registry.set(key, item);\r\n\r\n      await state.hooks.didRegister.call({ key, value: cloneDeep(item) });\r\n\r\n      return this;\r\n    },\r\n\r\n    async delete(key: string) {\r\n      if (this.has(key)) {\r\n        const item = this.get(key);\r\n\r\n        await state.hooks.willDelete.call({ key, value: cloneDeep(item) });\r\n\r\n        state.registry.delete(key);\r\n\r\n        await state.hooks.didDelete.call({ key, value: cloneDeep(item) });\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    get(key: string) {\r\n      return state.registry.get(key);\r\n    },\r\n\r\n    values() {\r\n      return Array.from(state.registry.values());\r\n    },\r\n\r\n    keys() {\r\n      return Array.from(state.registry.keys());\r\n    },\r\n\r\n    has(key: string) {\r\n      return state.registry.has(key);\r\n    },\r\n\r\n    size() {\r\n      return state.registry.size;\r\n    },\r\n\r\n    async clear() {\r\n      const keys = this.keys();\r\n\r\n      for (const key of keys) {\r\n        await this.delete(key);\r\n      }\r\n\r\n      return this;\r\n    },\r\n  };\r\n};\r\n\r\nexport default providerFactory;\r\n","import { clone, isObject, isArray, isNil, curry } from 'lodash/fp';\r\n\r\nimport type { Attribute, AnyAttribute, Model, Data } from './types';\r\nimport { isRelationalAttribute, isMediaAttribute } from './content-types';\r\n\r\nexport type VisitorUtils = ReturnType<typeof createVisitorUtils>;\r\n\r\nexport interface VisitorOptions {\r\n  data: Record<string, unknown>;\r\n  schema: Model;\r\n  key: string;\r\n  value: Data[keyof Data];\r\n  attribute?: AnyAttribute;\r\n  path: Path;\r\n  getModel(uid: string): Model;\r\n  parent?: Parent;\r\n}\r\n\r\nexport type Visitor = (visitorOptions: VisitorOptions, visitorUtils: VisitorUtils) => void;\r\n\r\nexport interface Path {\r\n  raw: string | null;\r\n  attribute: string | null;\r\n}\r\n\r\nexport interface TraverseOptions {\r\n  schema: Model;\r\n  path?: Path;\r\n  parent?: Parent;\r\n  getModel(uid: string): Model;\r\n}\r\n\r\nexport interface Parent {\r\n  attribute?: Attribute;\r\n  key: string | null;\r\n  path: Path;\r\n  schema: Model;\r\n}\r\n\r\nconst traverseEntity = async (visitor: Visitor, options: TraverseOptions, entity: Data) => {\r\n  const { path = { raw: null, attribute: null }, schema, getModel } = options;\r\n\r\n  let parent = options.parent;\r\n\r\n  const traverseMorphRelationTarget = async (visitor: Visitor, path: Path, entry: Data) => {\r\n    const targetSchema = getModel(entry.__type!);\r\n\r\n    const traverseOptions: TraverseOptions = { schema: targetSchema, path, getModel, parent };\r\n\r\n    return traverseEntity(visitor, traverseOptions, entry);\r\n  };\r\n\r\n  const traverseRelationTarget =\r\n    (schema: Model) => async (visitor: Visitor, path: Path, entry: Data) => {\r\n      const traverseOptions: TraverseOptions = { schema, path, getModel, parent };\r\n\r\n      return traverseEntity(visitor, traverseOptions, entry);\r\n    };\r\n\r\n  const traverseMediaTarget = async (visitor: Visitor, path: Path, entry: Data) => {\r\n    const targetSchemaUID = 'plugin::upload.file';\r\n    const targetSchema = getModel(targetSchemaUID);\r\n\r\n    const traverseOptions: TraverseOptions = { schema: targetSchema, path, getModel, parent };\r\n\r\n    return traverseEntity(visitor, traverseOptions, entry);\r\n  };\r\n\r\n  const traverseComponent = async (visitor: Visitor, path: Path, schema: Model, entry: Data) => {\r\n    const traverseOptions: TraverseOptions = { schema, path, getModel, parent };\r\n\r\n    return traverseEntity(visitor, traverseOptions, entry);\r\n  };\r\n\r\n  const visitDynamicZoneEntry = async (visitor: Visitor, path: Path, entry: Data) => {\r\n    const targetSchema = getModel(entry.__component!);\r\n    const traverseOptions: TraverseOptions = { schema: targetSchema, path, getModel, parent };\r\n\r\n    return traverseEntity(visitor, traverseOptions, entry);\r\n  };\r\n\r\n  // End recursion\r\n  if (!isObject(entity) || isNil(schema)) {\r\n    return entity;\r\n  }\r\n\r\n  // Don't mutate the original entity object\r\n  // only clone at 1st level as the next level will get clone when traversed\r\n  const copy = clone(entity);\r\n  const visitorUtils = createVisitorUtils({ data: copy });\r\n\r\n  const keys = Object.keys(copy);\r\n  for (let i = 0; i < keys.length; i += 1) {\r\n    const key = keys[i];\r\n    // Retrieve the attribute definition associated to the key from the schema\r\n    const attribute = schema.attributes[key] as AnyAttribute | undefined;\r\n\r\n    const newPath = { ...path };\r\n\r\n    newPath.raw = isNil(path.raw) ? key : `${path.raw}.${key}`;\r\n\r\n    if (!isNil(attribute)) {\r\n      newPath.attribute = isNil(path.attribute) ? key : `${path.attribute}.${key}`;\r\n    }\r\n\r\n    // Visit the current attribute\r\n    const visitorOptions: VisitorOptions = {\r\n      data: copy,\r\n      schema,\r\n      key,\r\n      value: copy[key],\r\n      attribute,\r\n      path: newPath,\r\n      getModel,\r\n      parent,\r\n    };\r\n\r\n    await visitor(visitorOptions, visitorUtils);\r\n\r\n    // Extract the value for the current key (after calling the visitor)\r\n    const value = copy[key];\r\n\r\n    // Ignore Nil values or attributes\r\n    if (isNil(value) || isNil(attribute)) {\r\n      continue;\r\n    }\r\n\r\n    // The current attribute becomes the parent once visited\r\n    parent = { schema, key, attribute, path: newPath };\r\n\r\n    if (isRelationalAttribute(attribute)) {\r\n      const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');\r\n\r\n      const method = isMorphRelation\r\n        ? traverseMorphRelationTarget\r\n        : traverseRelationTarget(getModel(attribute.target!));\r\n\r\n      if (isArray(value)) {\r\n        const res = new Array(value.length);\r\n        for (let i = 0; i < value.length; i += 1) {\r\n          res[i] = await method(visitor, newPath, value[i]);\r\n        }\r\n        copy[key] = res;\r\n      } else {\r\n        copy[key] = await method(visitor, newPath, value as Data);\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    if (isMediaAttribute(attribute)) {\r\n      // need to update copy\r\n      if (isArray(value)) {\r\n        const res = new Array(value.length);\r\n        for (let i = 0; i < value.length; i += 1) {\r\n          res[i] = await traverseMediaTarget(visitor, newPath, value[i]);\r\n        }\r\n        copy[key] = res;\r\n      } else {\r\n        copy[key] = await traverseMediaTarget(visitor, newPath, value as Data);\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    if (attribute.type === 'component') {\r\n      const targetSchema = getModel(attribute.component);\r\n\r\n      if (isArray(value)) {\r\n        const res: Data[] = new Array(value.length);\r\n        for (let i = 0; i < value.length; i += 1) {\r\n          res[i] = await traverseComponent(visitor, newPath, targetSchema, value[i]);\r\n        }\r\n        copy[key] = res;\r\n      } else {\r\n        copy[key] = await traverseComponent(visitor, newPath, targetSchema, value as Data);\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    if (attribute.type === 'dynamiczone' && isArray(value)) {\r\n      const res = new Array(value.length);\r\n      for (let i = 0; i < value.length; i += 1) {\r\n        res[i] = await visitDynamicZoneEntry(visitor, newPath, value[i]);\r\n      }\r\n      copy[key] = res;\r\n\r\n      continue;\r\n    }\r\n  }\r\n\r\n  return copy;\r\n};\r\n\r\nconst createVisitorUtils = ({ data }: { data: Data }) => ({\r\n  remove(key: string) {\r\n    delete data[key];\r\n  },\r\n\r\n  set(key: string, value: Data) {\r\n    data[key] = value;\r\n  },\r\n});\r\n\r\nexport default curry(traverseEntity);\r\n","/* eslint-disable @typescript-eslint/no-var-requires */\r\n\r\nexport default function importDefault(modName: string) {\r\n  const mod = require(modName);\r\n  return mod && mod.__esModule ? mod.default : mod;\r\n}\r\n","import { randomUUID } from 'crypto';\r\nimport { machineIdSync } from 'node-machine-id';\r\n\r\nexport default () => {\r\n  try {\r\n    const deviceId = machineIdSync();\r\n    return deviceId;\r\n  } catch (error) {\r\n    const deviceId = randomUUID();\r\n    return deviceId;\r\n  }\r\n};\r\n","import { isEmpty, toPath } from 'lodash/fp';\r\nimport { ValidationError } from 'yup';\r\n\r\nconst formatYupInnerError = (yupError: ValidationError) => ({\r\n  path: toPath(yupError.path),\r\n  message: yupError.message,\r\n  name: yupError.name,\r\n});\r\n\r\nconst formatYupErrors = (yupError: ValidationError) => ({\r\n  errors: isEmpty(yupError.inner)\r\n    ? [formatYupInnerError(yupError)]\r\n    : yupError.inner.map(formatYupInnerError),\r\n  message: yupError.message,\r\n});\r\n\r\nexport { formatYupErrors };\r\n","/* eslint-disable max-classes-per-file */\r\n\r\nimport yup from 'yup';\r\nimport { HttpError } from 'http-errors';\r\nimport { formatYupErrors } from './format-yup-error';\r\n\r\n/* ApplicationError */\r\nclass ApplicationError<\r\n  TName extends string = 'ApplicationError',\r\n  TMessage extends string = string,\r\n  TDetails = unknown,\r\n> extends Error {\r\n  name: TName;\r\n\r\n  details: TDetails;\r\n\r\n  message: TMessage;\r\n\r\n  constructor(\r\n    message = 'An application error occured' as TMessage,\r\n    details: TDetails = {} as TDetails\r\n  ) {\r\n    super();\r\n    this.name = 'ApplicationError' as TName;\r\n    this.message = message;\r\n    this.details = details;\r\n  }\r\n}\r\n\r\nclass ValidationError<\r\n  TMessage extends string = string,\r\n  TDetails = unknown,\r\n> extends ApplicationError<'ValidationError', TMessage, TDetails> {\r\n  constructor(message: TMessage, details?: TDetails) {\r\n    super(message, details);\r\n    this.name = 'ValidationError';\r\n  }\r\n}\r\n\r\ninterface YupFormattedError {\r\n  path: string[];\r\n  message: string;\r\n  name: string;\r\n}\r\n\r\nclass YupValidationError<TMessage extends string = string> extends ValidationError<\r\n  TMessage,\r\n  { errors: YupFormattedError[] }\r\n> {\r\n  constructor(yupError: yup.ValidationError, message?: TMessage) {\r\n    super('Validation' as TMessage);\r\n    const { errors, message: yupMessage } = formatYupErrors(yupError);\r\n    this.message = message || (yupMessage as TMessage);\r\n    this.details = { errors };\r\n  }\r\n}\r\n\r\nclass PaginationError<\r\n  TMessage extends string = string,\r\n  TDetails = unknown,\r\n> extends ApplicationError<'PaginationError', TMessage, TDetails> {\r\n  constructor(message = 'Invalid pagination' as TMessage, details?: TDetails) {\r\n    super(message, details);\r\n    this.name = 'PaginationError';\r\n    this.message = message;\r\n  }\r\n}\r\n\r\nclass NotFoundError<TMessage extends string = string, TDetails = unknown> extends ApplicationError<\r\n  'NotFoundError',\r\n  TMessage,\r\n  TDetails\r\n> {\r\n  constructor(message = 'Entity not found' as TMessage, details?: TDetails) {\r\n    super(message, details);\r\n    this.name = 'NotFoundError';\r\n    this.message = message;\r\n  }\r\n}\r\n\r\nclass ForbiddenError<\r\n  TName extends string = 'ForbiddenError',\r\n  TMessage extends string = string,\r\n  TDetails = unknown,\r\n> extends ApplicationError<TName, TMessage, TDetails> {\r\n  constructor(message = 'Forbidden access' as TMessage, details?: TDetails) {\r\n    super(message, details);\r\n    this.name = 'ForbiddenError' as TName;\r\n    this.message = message;\r\n  }\r\n}\r\n\r\nclass UnauthorizedError<\r\n  TMessage extends string = string,\r\n  TDetails = unknown,\r\n> extends ApplicationError<'UnauthorizedError', TMessage, TDetails> {\r\n  constructor(message = 'Unauthorized' as TMessage, details?: TDetails) {\r\n    super(message, details);\r\n    this.name = 'UnauthorizedError';\r\n    this.message = message;\r\n  }\r\n}\r\n\r\nclass RateLimitError<TMessage extends string = string, TDetails = unknown> extends ApplicationError<\r\n  'RateLimitError',\r\n  TMessage,\r\n  TDetails\r\n> {\r\n  constructor(\r\n    message = 'Too many requests, please try again later.' as TMessage,\r\n    details?: TDetails\r\n  ) {\r\n    super(message, details);\r\n    this.name = 'RateLimitError';\r\n    this.message = message;\r\n    this.details = details || ({} as TDetails);\r\n  }\r\n}\r\n\r\nclass PayloadTooLargeError<\r\n  TMessage extends string = string,\r\n  TDetails = unknown,\r\n> extends ApplicationError<'PayloadTooLargeError', TMessage, TDetails> {\r\n  constructor(message = 'Entity too large' as TMessage, details?: TDetails) {\r\n    super(message, details);\r\n    this.name = 'PayloadTooLargeError';\r\n    this.message = message;\r\n  }\r\n}\r\n\r\nclass PolicyError<TMessage extends string = string, TDetails = unknown> extends ForbiddenError<\r\n  'PolicyError',\r\n  TMessage,\r\n  TDetails\r\n> {\r\n  constructor(message = 'Policy Failed' as TMessage, details?: TDetails) {\r\n    super(message, details);\r\n    this.name = 'PolicyError';\r\n    this.message = message;\r\n    this.details = details || ({} as TDetails);\r\n  }\r\n}\r\n\r\nclass NotImplementedError<\r\n  TMessage extends string = string,\r\n  TDetails = unknown,\r\n> extends ApplicationError<'NotImplementedError', TMessage, TDetails> {\r\n  constructor(message = 'This feature is not implemented yet' as TMessage, details?: TDetails) {\r\n    super(message, details);\r\n    this.name = 'NotImplementedError';\r\n    this.message = message;\r\n  }\r\n}\r\n\r\nexport {\r\n  HttpError,\r\n  ApplicationError,\r\n  ValidationError,\r\n  YupValidationError,\r\n  PaginationError,\r\n  NotFoundError,\r\n  ForbiddenError,\r\n  UnauthorizedError,\r\n  RateLimitError,\r\n  PayloadTooLargeError,\r\n  PolicyError,\r\n  NotImplementedError,\r\n};\r\n","/* eslint-disable @typescript-eslint/ban-ts-comment */\r\n/* eslint-disable no-template-curly-in-string */\r\nimport * as yup from 'yup';\r\nimport { defaults } from 'lodash/fp';\r\nimport { YupValidationError } from './errors';\r\n\r\nconst handleYupError = (error: yup.ValidationError, errorMessage?: string) => {\r\n  throw new YupValidationError(error, errorMessage);\r\n};\r\n\r\nconst defaultValidationParam = { strict: true, abortEarly: false };\r\n\r\nconst validateYupSchema =\r\n  <TSchema extends yup.AnySchema>(schema: TSchema, options = {}) =>\r\n  async (body: unknown, errorMessage?: string): Promise<yup.InferType<TSchema>> => {\r\n    try {\r\n      const optionsWithDefaults = defaults(defaultValidationParam, options);\r\n      const result = await schema.validate(body, optionsWithDefaults);\r\n      return result;\r\n    } catch (e) {\r\n      if (e instanceof yup.ValidationError) {\r\n        handleYupError(e, errorMessage);\r\n      }\r\n\r\n      throw e;\r\n    }\r\n  };\r\n\r\nconst validateYupSchemaSync =\r\n  <TSchema extends yup.AnySchema>(schema: yup.AnySchema, options = {}) =>\r\n  (body: unknown, errorMessage?: string): yup.InferType<TSchema> => {\r\n    try {\r\n      const optionsWithDefaults = defaults(defaultValidationParam, options);\r\n      return schema.validateSync(body, optionsWithDefaults);\r\n    } catch (e) {\r\n      if (e instanceof yup.ValidationError) {\r\n        handleYupError(e, errorMessage);\r\n      }\r\n\r\n      throw e;\r\n    }\r\n  };\r\n\r\nexport { handleYupError, validateYupSchema, validateYupSchemaSync };\r\n","const GROUP_OPERATORS = ['$and', '$or'];\r\n\r\nconst WHERE_OPERATORS = [\r\n  '$not',\r\n  '$in',\r\n  '$notIn',\r\n  '$eq',\r\n  '$eqi',\r\n  '$ne',\r\n  '$nei',\r\n  '$gt',\r\n  '$gte',\r\n  '$lt',\r\n  '$lte',\r\n  '$null',\r\n  '$notNull',\r\n  '$between',\r\n  '$startsWith',\r\n  '$endsWith',\r\n  '$startsWithi',\r\n  '$endsWithi',\r\n  '$contains',\r\n  '$notContains',\r\n  '$containsi',\r\n  '$notContainsi',\r\n  // Experimental, only for internal use\r\n  '$jsonSupersetOf',\r\n];\r\n\r\nconst CAST_OPERATORS = [\r\n  '$not',\r\n  '$in',\r\n  '$notIn',\r\n  '$eq',\r\n  '$ne',\r\n  '$gt',\r\n  '$gte',\r\n  '$lt',\r\n  '$lte',\r\n  '$between',\r\n];\r\n\r\nconst ARRAY_OPERATORS = ['$in', '$notIn', '$between'];\r\n\r\nconst OPERATORS = {\r\n  where: WHERE_OPERATORS,\r\n  cast: CAST_OPERATORS,\r\n  group: GROUP_OPERATORS,\r\n  array: ARRAY_OPERATORS,\r\n};\r\n\r\n// for performance, cache all operators in lowercase\r\nconst OPERATORS_LOWERCASE = Object.fromEntries(\r\n  Object.entries(OPERATORS).map(([key, values]) => [\r\n    key,\r\n    values.map((value) => value.toLowerCase()),\r\n  ])\r\n);\r\n\r\nconst isObjKey = <T extends object>(key: string | symbol | number, obj: T): key is keyof T => {\r\n  return key in obj;\r\n};\r\n\r\nexport const isOperatorOfType = (type: string, key: string, ignoreCase = false) => {\r\n  if (ignoreCase) {\r\n    return OPERATORS_LOWERCASE[type]?.includes(key.toLowerCase()) ?? false;\r\n  }\r\n\r\n  if (isObjKey(type, OPERATORS)) {\r\n    return OPERATORS[type]?.includes(key) ?? false;\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nexport const isOperator = (key: string, ignoreCase = false) => {\r\n  return Object.keys(OPERATORS).some((type) => isOperatorOfType(type, key, ignoreCase));\r\n};\r\n","/* eslint-disable max-classes-per-file */\r\n\r\n/**\r\n * Converts the standard Strapi REST query params to a more usable format for querying\r\n * You can read more here: https://docs.strapi.io/developer-docs/latest/developer-resources/database-apis-reference/rest-api.html#filters\r\n */\r\n\r\nimport _ from 'lodash';\r\nimport {\r\n  cloneDeep,\r\n  get,\r\n  isArray,\r\n  isEmpty,\r\n  isInteger,\r\n  isNil,\r\n  isObject,\r\n  isString,\r\n  toNumber,\r\n} from 'lodash/fp';\r\nimport {\r\n  constants,\r\n  hasDraftAndPublish,\r\n  isDynamicZoneAttribute,\r\n  isMorphToRelationalAttribute,\r\n} from './content-types';\r\nimport { PaginationError } from './errors';\r\nimport { isOperator } from './operators';\r\n\r\nimport parseType from './parse-type';\r\nimport { Model } from './types';\r\n\r\nconst { ID_ATTRIBUTE, DOC_ID_ATTRIBUTE, PUBLISHED_AT_ATTRIBUTE } = constants;\r\n\r\ntype SortOrder = 'asc' | 'desc';\r\n\r\nexport interface SortMap {\r\n  [key: string]: SortOrder | SortMap;\r\n}\r\n\r\nexport interface SortParamsObject {\r\n  [key: string]: SortOrder | SortParamsObject;\r\n}\r\n\r\ntype SortParams = string | string[] | SortParamsObject | SortParamsObject[];\r\ntype FieldsParams = string | string[];\r\n\r\ntype FiltersParams = unknown;\r\n\r\nexport interface PopulateAttributesParams {\r\n  [key: string]: boolean | PopulateObjectParams;\r\n}\r\n\r\nexport interface PopulateObjectParams {\r\n  sort?: SortParams;\r\n  fields?: FieldsParams;\r\n  filters?: FiltersParams;\r\n  populate?: string | string[] | PopulateAttributesParams;\r\n  on?: PopulateAttributesParams;\r\n  count?: boolean;\r\n  ordering?: unknown;\r\n  _q?: string;\r\n  limit?: number | string;\r\n  start?: number | string;\r\n  page?: number | string;\r\n  pageSize?: number | string;\r\n}\r\n\r\ntype PopulateParams = string | string[] | PopulateAttributesParams;\r\n\r\nexport interface Params {\r\n  sort?: SortParams;\r\n  fields?: FieldsParams;\r\n  filters?: FiltersParams;\r\n  populate?: PopulateParams;\r\n  count?: boolean;\r\n  ordering?: unknown;\r\n  _q?: string;\r\n  limit?: number | string;\r\n  start?: number | string;\r\n  page?: number | string;\r\n  pageSize?: number | string;\r\n  status?: 'draft' | 'published';\r\n}\r\n\r\ntype FiltersQuery = (options: { meta: Model }) => WhereQuery | undefined;\r\ntype OrderByQuery = SortMap | SortMap[];\r\ntype SelectQuery = string | string[];\r\n\r\nexport interface WhereQuery {\r\n  [key: string]: any;\r\n}\r\n\r\ntype PopulateQuery =\r\n  | boolean\r\n  | string[]\r\n  | {\r\n      [key: string]: PopulateQuery;\r\n    };\r\n\r\nexport interface Query {\r\n  orderBy?: OrderByQuery;\r\n  select?: SelectQuery;\r\n  where?: WhereQuery;\r\n  // NOTE: those are internal DB filters do not modify\r\n  filters?: FiltersQuery;\r\n  populate?: PopulateQuery;\r\n  count?: boolean;\r\n  ordering?: unknown;\r\n  _q?: string;\r\n  limit?: number;\r\n  offset?: number;\r\n  page?: number;\r\n  pageSize?: number;\r\n}\r\n\r\nclass InvalidOrderError extends Error {\r\n  constructor() {\r\n    super();\r\n    this.message = 'Invalid order. order can only be one of asc|desc|ASC|DESC';\r\n  }\r\n}\r\n\r\nclass InvalidSortError extends Error {\r\n  constructor() {\r\n    super();\r\n    this.message =\r\n      'Invalid sort parameter. Expected a string, an array of strings, a sort object or an array of sort objects';\r\n  }\r\n}\r\n\r\nfunction validateOrder(order: string): asserts order is SortOrder {\r\n  if (!isString(order) || !['asc', 'desc'].includes(order.toLocaleLowerCase())) {\r\n    throw new InvalidOrderError();\r\n  }\r\n}\r\n\r\nconst convertCountQueryParams = (countQuery: unknown): boolean => {\r\n  return parseType({ type: 'boolean', value: countQuery });\r\n};\r\n\r\nconst convertOrderingQueryParams = (ordering: unknown) => {\r\n  return ordering;\r\n};\r\n\r\nconst isPlainObject = (value: unknown): value is Record<string, unknown> => _.isPlainObject(value);\r\nconst isStringArray = (value: unknown): value is string[] =>\r\n  isArray(value) && value.every(isString);\r\n\r\ninterface TransformerOptions {\r\n  getModel: (uid: string) => Model | undefined;\r\n}\r\n\r\nconst createTransformer = ({ getModel }: TransformerOptions) => {\r\n  /**\r\n   * Sort query parser\r\n   */\r\n  const convertSortQueryParams = (sortQuery: SortParams): OrderByQuery => {\r\n    if (typeof sortQuery === 'string') {\r\n      return convertStringSortQueryParam(sortQuery);\r\n    }\r\n\r\n    if (isStringArray(sortQuery)) {\r\n      return sortQuery.flatMap((sortValue: string) => convertStringSortQueryParam(sortValue));\r\n    }\r\n\r\n    if (Array.isArray(sortQuery)) {\r\n      return sortQuery.map((sortValue) => convertNestedSortQueryParam(sortValue));\r\n    }\r\n\r\n    if (isPlainObject(sortQuery)) {\r\n      return convertNestedSortQueryParam(sortQuery);\r\n    }\r\n\r\n    throw new InvalidSortError();\r\n  };\r\n\r\n  const convertStringSortQueryParam = (sortQuery: string): SortMap[] => {\r\n    return sortQuery.split(',').map((value) => convertSingleSortQueryParam(value));\r\n  };\r\n\r\n  const convertSingleSortQueryParam = (sortQuery: string): SortMap => {\r\n    if (!sortQuery) {\r\n      return {};\r\n    }\r\n\r\n    if (!isString(sortQuery)) {\r\n      throw new Error('Invalid sort query');\r\n    }\r\n\r\n    // split field and order param with default order to ascending\r\n    const [field, order = 'asc'] = sortQuery.split(':');\r\n\r\n    if (field.length === 0) {\r\n      throw new Error('Field cannot be empty');\r\n    }\r\n\r\n    validateOrder(order);\r\n\r\n    // TODO: field should be a valid path on an object model\r\n\r\n    return _.set({}, field, order);\r\n  };\r\n\r\n  const convertNestedSortQueryParam = (sortQuery: SortParamsObject): SortMap => {\r\n    const transformedSort: SortMap = {};\r\n    for (const field of Object.keys(sortQuery)) {\r\n      const order = sortQuery[field];\r\n\r\n      // this is a deep sort\r\n      if (isPlainObject(order)) {\r\n        transformedSort[field] = convertNestedSortQueryParam(order);\r\n      } else if (typeof order === 'string') {\r\n        validateOrder(order);\r\n        transformedSort[field] = order;\r\n      } else {\r\n        throw Error(`Invalid sort type expected object or string got ${typeof order}`);\r\n      }\r\n    }\r\n\r\n    return transformedSort;\r\n  };\r\n\r\n  /**\r\n   * Start query parser\r\n   */\r\n  const convertStartQueryParams = (startQuery: unknown): number => {\r\n    const startAsANumber = toNumber(startQuery);\r\n\r\n    if (!_.isInteger(startAsANumber) || startAsANumber < 0) {\r\n      throw new Error(`convertStartQueryParams expected a positive integer got ${startAsANumber}`);\r\n    }\r\n\r\n    return startAsANumber;\r\n  };\r\n\r\n  /**\r\n   * Limit query parser\r\n   */\r\n  const convertLimitQueryParams = (limitQuery: unknown): number | undefined => {\r\n    const limitAsANumber = toNumber(limitQuery);\r\n\r\n    if (!_.isInteger(limitAsANumber) || (limitAsANumber !== -1 && limitAsANumber < 0)) {\r\n      throw new Error(`convertLimitQueryParams expected a positive integer got ${limitAsANumber}`);\r\n    }\r\n\r\n    if (limitAsANumber === -1) {\r\n      return undefined;\r\n    }\r\n\r\n    return limitAsANumber;\r\n  };\r\n\r\n  const convertPageQueryParams = (page: unknown): number => {\r\n    const pageVal = toNumber(page);\r\n\r\n    if (!isInteger(pageVal) || pageVal <= 0) {\r\n      throw new PaginationError(\r\n        `Invalid 'page' parameter. Expected an integer > 0, received: ${page}`\r\n      );\r\n    }\r\n\r\n    return pageVal;\r\n  };\r\n\r\n  const convertPageSizeQueryParams = (pageSize: unknown, page: unknown): number => {\r\n    const pageSizeVal = toNumber(pageSize);\r\n\r\n    if (!isInteger(pageSizeVal) || pageSizeVal <= 0) {\r\n      throw new PaginationError(\r\n        `Invalid 'pageSize' parameter. Expected an integer > 0, received: ${page}`\r\n      );\r\n    }\r\n\r\n    return pageSizeVal;\r\n  };\r\n\r\n  const validatePaginationParams = (\r\n    page: unknown,\r\n    pageSize: unknown,\r\n    start: unknown,\r\n    limit: unknown\r\n  ) => {\r\n    const isPagePagination = !isNil(page) || !isNil(pageSize);\r\n    const isOffsetPagination = !isNil(start) || !isNil(limit);\r\n\r\n    if (isPagePagination && isOffsetPagination) {\r\n      throw new PaginationError(\r\n        'Invalid pagination attributes. You cannot use page and offset pagination in the same query'\r\n      );\r\n    }\r\n  };\r\n\r\n  class InvalidPopulateError extends Error {\r\n    constructor() {\r\n      super();\r\n      this.message =\r\n        'Invalid populate parameter. Expected a string, an array of strings, a populate object';\r\n    }\r\n  }\r\n\r\n  // NOTE: we could support foo.* or foo.bar.* etc later on\r\n  const convertPopulateQueryParams = (\r\n    populate: PopulateParams,\r\n    schema?: Model,\r\n    depth = 0\r\n  ): PopulateQuery => {\r\n    if (depth === 0 && populate === '*') {\r\n      return true;\r\n    }\r\n\r\n    if (typeof populate === 'string') {\r\n      return populate.split(',').map((value) => _.trim(value));\r\n    }\r\n\r\n    if (Array.isArray(populate)) {\r\n      // map convert\r\n      return _.uniq(\r\n        populate.flatMap((value) => {\r\n          if (typeof value !== 'string') {\r\n            throw new InvalidPopulateError();\r\n          }\r\n\r\n          return value.split(',').map((value) => _.trim(value));\r\n        })\r\n      );\r\n    }\r\n\r\n    if (_.isPlainObject(populate)) {\r\n      return convertPopulateObject(populate, schema);\r\n    }\r\n\r\n    throw new InvalidPopulateError();\r\n  };\r\n\r\n  const hasPopulateFragmentDefined = (\r\n    populate: PopulateObjectParams\r\n  ): populate is PopulateObjectParams & Required<Pick<PopulateObjectParams, 'on'>> => {\r\n    return typeof populate === 'object' && 'on' in populate && !isNil(populate.on);\r\n  };\r\n\r\n  const hasCountDefined = (\r\n    populate: PopulateObjectParams\r\n  ): populate is PopulateObjectParams & { count: boolean } => {\r\n    return (\r\n      typeof populate === 'object' && 'count' in populate && typeof populate.count === 'boolean'\r\n    );\r\n  };\r\n\r\n  const convertPopulateObject = (populate: PopulateAttributesParams, schema?: Model) => {\r\n    if (!schema) {\r\n      return {};\r\n    }\r\n\r\n    const { attributes } = schema;\r\n    return Object.entries(populate).reduce((acc, [key, subPopulate]) => {\r\n      // Try converting strings to regular booleans if possible\r\n      if (_.isString(subPopulate)) {\r\n        try {\r\n          const subPopulateAsBoolean = parseType({ type: 'boolean', value: subPopulate });\r\n          // Only true is accepted as a boolean populate value\r\n          return subPopulateAsBoolean ? { ...acc, [key]: true } : acc;\r\n        } catch {\r\n          // ignore\r\n        }\r\n      }\r\n\r\n      if (_.isBoolean(subPopulate)) {\r\n        // Only true is accepted as a boolean populate value\r\n        return subPopulate === true ? { ...acc, [key]: true } : acc;\r\n      }\r\n\r\n      const attribute = attributes[key];\r\n\r\n      if (!attribute) {\r\n        return acc;\r\n      }\r\n\r\n      // Allow adding an 'on' strategy to populate queries for morphTo relations and dynamic zones\r\n      const isMorphLikeRelationalAttribute =\r\n        isDynamicZoneAttribute(attribute) || isMorphToRelationalAttribute(attribute);\r\n\r\n      if (isMorphLikeRelationalAttribute) {\r\n        const hasInvalidProperties = Object.keys(subPopulate).some(\r\n          (key) => !['populate', 'on', 'count'].includes(key)\r\n        );\r\n\r\n        if (hasInvalidProperties) {\r\n          throw new Error(\r\n            `Invalid nested populate for ${schema.info?.singularName}.${key} (${schema.uid}). Expected a fragment (\"on\") or \"count\" but found ${JSON.stringify(subPopulate)}`\r\n          );\r\n        }\r\n\r\n        /**\r\n         * Validate nested population queries in the context of a polymorphic attribute (dynamic zone, morph relation).\r\n         *\r\n         * If 'populate' exists in subPopulate, its value should be constrained to a wildcard ('*').\r\n         */\r\n        if ('populate' in subPopulate && subPopulate.populate !== '*') {\r\n          throw new Error(\r\n            `Invalid nested population query detected. When using 'populate' within polymorphic structures, ` +\r\n              `its value must be '*' to indicate all second level links. Specific field targeting is not supported here. ` +\r\n              `Consider using the fragment API for more granular population control.`\r\n          );\r\n        }\r\n\r\n        // TODO: Remove the possibility to have multiple properties at the same time (on/count/populate)\r\n        const newSubPopulate = {};\r\n\r\n        // case: { populate: '*' }\r\n        if ('populate' in subPopulate) {\r\n          Object.assign(newSubPopulate, { populate: true });\r\n        }\r\n\r\n        // case: { on: { <clauses> } }\r\n        if (hasPopulateFragmentDefined(subPopulate)) {\r\n          // If the fragment API is used, it applies the transformation to every\r\n          // sub-populate, then assign the result to the new sub-populate\r\n          Object.assign(newSubPopulate, {\r\n            on: Object.entries(subPopulate.on).reduce(\r\n              (acc, [type, typeSubPopulate]) => ({\r\n                ...acc,\r\n                [type]: convertNestedPopulate(typeSubPopulate, getModel(type)),\r\n              }),\r\n              {}\r\n            ),\r\n          });\r\n        }\r\n\r\n        // case: { count: true | false }\r\n        if (hasCountDefined(subPopulate)) {\r\n          Object.assign(newSubPopulate, { count: subPopulate.count });\r\n        }\r\n\r\n        return { ...acc, [key]: newSubPopulate };\r\n      }\r\n\r\n      // Edge case when trying to use the fragment ('on') on a non-morph like attribute\r\n      if (!isMorphLikeRelationalAttribute && hasPopulateFragmentDefined(subPopulate)) {\r\n        throw new Error(`Using fragments is not permitted to populate \"${key}\" in \"${schema.uid}\"`);\r\n      }\r\n\r\n      // NOTE: Retrieve the target schema UID.\r\n      // Only handles basic relations, medias and component since it's not possible\r\n      // to populate with options for a dynamic zone or a polymorphic relation\r\n      let targetSchemaUID;\r\n\r\n      if (attribute.type === 'relation') {\r\n        targetSchemaUID = attribute.target;\r\n      } else if (attribute.type === 'component') {\r\n        targetSchemaUID = attribute.component;\r\n      } else if (attribute.type === 'media') {\r\n        targetSchemaUID = 'plugin::upload.file';\r\n      } else {\r\n        return acc;\r\n      }\r\n\r\n      const targetSchema = getModel(targetSchemaUID!);\r\n\r\n      // ignore the sub-populate for the current key if there is no schema associated\r\n      if (!targetSchema) {\r\n        return acc;\r\n      }\r\n\r\n      const populateObject = convertNestedPopulate(subPopulate, targetSchema);\r\n\r\n      if (!populateObject) {\r\n        return acc;\r\n      }\r\n\r\n      return {\r\n        ...acc,\r\n        [key]: populateObject,\r\n      };\r\n    }, {});\r\n  };\r\n\r\n  const convertNestedPopulate = (subPopulate: boolean | PopulateObjectParams, schema?: Model) => {\r\n    if (_.isString(subPopulate)) {\r\n      return parseType({ type: 'boolean', value: subPopulate, forceCast: true });\r\n    }\r\n\r\n    if (_.isBoolean(subPopulate)) {\r\n      return subPopulate;\r\n    }\r\n\r\n    if (!isPlainObject(subPopulate)) {\r\n      throw new Error(`Invalid nested populate. Expected '*' or an object`);\r\n    }\r\n\r\n    const { sort, filters, fields, populate, count, ordering, page, pageSize, start, limit } =\r\n      subPopulate as PopulateObjectParams;\r\n\r\n    const query: Query = {};\r\n\r\n    if (sort) {\r\n      query.orderBy = convertSortQueryParams(sort);\r\n    }\r\n\r\n    if (filters) {\r\n      query.where = convertFiltersQueryParams(filters, schema);\r\n    }\r\n\r\n    if (fields) {\r\n      query.select = convertFieldsQueryParams(fields);\r\n    }\r\n\r\n    if (populate) {\r\n      query.populate = convertPopulateQueryParams(populate, schema);\r\n    }\r\n\r\n    if (count) {\r\n      query.count = convertCountQueryParams(count);\r\n    }\r\n\r\n    if (ordering) {\r\n      query.ordering = convertOrderingQueryParams(ordering);\r\n    }\r\n\r\n    validatePaginationParams(page, pageSize, start, limit);\r\n\r\n    if (!isNil(page)) {\r\n      query.page = convertPageQueryParams(page);\r\n    }\r\n\r\n    if (!isNil(pageSize)) {\r\n      query.pageSize = convertPageSizeQueryParams(pageSize, page);\r\n    }\r\n\r\n    if (!isNil(start)) {\r\n      query.offset = convertStartQueryParams(start);\r\n    }\r\n\r\n    if (!isNil(limit)) {\r\n      query.limit = convertLimitQueryParams(limit);\r\n    }\r\n\r\n    return query;\r\n  };\r\n\r\n  // TODO: ensure field is valid in content types (will probably have to check strapi.contentTypes since it can be a string.path)\r\n  const convertFieldsQueryParams = (fields: FieldsParams, depth = 0): SelectQuery | undefined => {\r\n    if (depth === 0 && fields === '*') {\r\n      return undefined;\r\n    }\r\n\r\n    if (typeof fields === 'string') {\r\n      const fieldsValues = fields.split(',').map((value) => _.trim(value));\r\n      return _.uniq([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE, ...fieldsValues]);\r\n    }\r\n\r\n    if (isStringArray(fields)) {\r\n      // map convert\r\n      const fieldsValues = fields\r\n        .flatMap((value) => convertFieldsQueryParams(value, depth + 1))\r\n        .filter((v) => !isNil(v)) as string[];\r\n\r\n      return _.uniq([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE, ...fieldsValues]);\r\n    }\r\n\r\n    throw new Error('Invalid fields parameter. Expected a string or an array of strings');\r\n  };\r\n\r\n  const isValidSchemaAttribute = (key: string, schema?: Model) => {\r\n    if ([DOC_ID_ATTRIBUTE, ID_ATTRIBUTE].includes(key)) {\r\n      return true;\r\n    }\r\n\r\n    if (!schema) {\r\n      return false;\r\n    }\r\n\r\n    return Object.keys(schema.attributes).includes(key);\r\n  };\r\n\r\n  const convertFiltersQueryParams = (filters: FiltersParams, schema?: Model): WhereQuery => {\r\n    // Filters need to be either an array or an object\r\n    // Here we're only checking for 'object' type since typeof [] => object and typeof {} => object\r\n    if (!isObject(filters)) {\r\n      throw new Error('The filters parameter must be an object or an array');\r\n    }\r\n\r\n    // Don't mutate the original object\r\n    const filtersCopy = cloneDeep(filters);\r\n\r\n    return convertAndSanitizeFilters(filtersCopy, schema);\r\n  };\r\n\r\n  const convertAndSanitizeFilters = (filters: FiltersParams, schema?: Model): WhereQuery => {\r\n    if (Array.isArray(filters)) {\r\n      return (\r\n        filters\r\n          // Sanitize each filter\r\n          .map((filter) => convertAndSanitizeFilters(filter, schema))\r\n          // Filter out empty filters\r\n          .filter((filter) => !isPlainObject(filter) || !isEmpty(filter))\r\n      );\r\n    }\r\n\r\n    if (!isPlainObject(filters)) {\r\n      return filters as WhereQuery;\r\n    }\r\n\r\n    const removeOperator = (operator: string) => delete filters[operator];\r\n\r\n    // Here, `key` can either be an operator or an attribute name\r\n    for (const [key, value] of Object.entries(filters)) {\r\n      const attribute = get(key, schema?.attributes);\r\n      const validKey = isOperator(key) || isValidSchemaAttribute(key, schema);\r\n\r\n      if (!validKey) {\r\n        removeOperator(key);\r\n      }\r\n      // Handle attributes\r\n      else if (attribute) {\r\n        // Relations\r\n        if (attribute.type === 'relation') {\r\n          filters[key] = convertAndSanitizeFilters(value, getModel(attribute.target!));\r\n        }\r\n\r\n        // Components\r\n        else if (attribute.type === 'component') {\r\n          filters[key] = convertAndSanitizeFilters(value, getModel(attribute.component));\r\n        }\r\n\r\n        // Media\r\n        else if (attribute.type === 'media') {\r\n          filters[key] = convertAndSanitizeFilters(value, getModel('plugin::upload.file'));\r\n        }\r\n\r\n        // Dynamic Zones\r\n        else if (attribute.type === 'dynamiczone') {\r\n          removeOperator(key);\r\n        }\r\n\r\n        // Password attributes\r\n        else if (attribute.type === 'password') {\r\n          // Always remove password attributes from filters object\r\n          removeOperator(key);\r\n        }\r\n\r\n        // Scalar attributes\r\n        else {\r\n          filters[key] = convertAndSanitizeFilters(value, schema);\r\n        }\r\n      }\r\n\r\n      // Handle operators\r\n      else if (['$null', '$notNull'].includes(key)) {\r\n        filters[key] = parseType({ type: 'boolean', value: filters[key], forceCast: true });\r\n      } else if (isObject(value)) {\r\n        filters[key] = convertAndSanitizeFilters(value, schema);\r\n      }\r\n\r\n      // Remove empty objects & arrays\r\n      if (isPlainObject(filters[key]) && isEmpty(filters[key])) {\r\n        removeOperator(key);\r\n      }\r\n    }\r\n\r\n    return filters;\r\n  };\r\n\r\n  const convertStatusParams = (status?: 'draft' | 'published', query: Query = {}) => {\r\n    // NOTE: this is the query layer filters not the document/entity service filters\r\n    query.filters = ({ meta }: { meta: Model }) => {\r\n      const contentType = getModel(meta.uid);\r\n\r\n      // Ignore if target model has disabled DP, as it doesn't make sense to filter by its status\r\n      if (!contentType || !hasDraftAndPublish(contentType)) {\r\n        return {};\r\n      }\r\n\r\n      return { [PUBLISHED_AT_ATTRIBUTE]: { $null: status === 'draft' } };\r\n    };\r\n  };\r\n\r\n  const transformQueryParams = (uid: string, params: Params): Query => {\r\n    // NOTE: can be a CT, a Compo or nothing in the case of polymorphism (DZ & morph relations)\r\n    const schema = getModel(uid);\r\n\r\n    const query: Query = {};\r\n\r\n    const { _q, sort, filters, fields, populate, page, pageSize, start, limit, status, ...rest } =\r\n      params;\r\n\r\n    if (!isNil(status)) {\r\n      convertStatusParams(status, query);\r\n    }\r\n\r\n    if (!isNil(_q)) {\r\n      query._q = _q;\r\n    }\r\n\r\n    if (!isNil(sort)) {\r\n      query.orderBy = convertSortQueryParams(sort);\r\n    }\r\n\r\n    if (!isNil(filters)) {\r\n      query.where = convertFiltersQueryParams(filters, schema);\r\n    }\r\n\r\n    if (!isNil(fields)) {\r\n      query.select = convertFieldsQueryParams(fields);\r\n    }\r\n\r\n    if (!isNil(populate)) {\r\n      query.populate = convertPopulateQueryParams(populate, schema);\r\n    }\r\n\r\n    validatePaginationParams(page, pageSize, start, limit);\r\n\r\n    if (!isNil(page)) {\r\n      query.page = convertPageQueryParams(page);\r\n    }\r\n\r\n    if (!isNil(pageSize)) {\r\n      query.pageSize = convertPageSizeQueryParams(pageSize, page);\r\n    }\r\n\r\n    if (!isNil(start)) {\r\n      query.offset = convertStartQueryParams(start);\r\n    }\r\n\r\n    if (!isNil(limit)) {\r\n      query.limit = convertLimitQueryParams(limit);\r\n    }\r\n\r\n    return {\r\n      ...rest,\r\n      ...query,\r\n    };\r\n  };\r\n\r\n  return {\r\n    private_convertSortQueryParams: convertSortQueryParams,\r\n    private_convertStartQueryParams: convertStartQueryParams,\r\n    private_convertLimitQueryParams: convertLimitQueryParams,\r\n    private_convertPopulateQueryParams: convertPopulateQueryParams,\r\n    private_convertFiltersQueryParams: convertFiltersQueryParams,\r\n    private_convertFieldsQueryParams: convertFieldsQueryParams,\r\n    transformQueryParams,\r\n  };\r\n};\r\n\r\nexport { createTransformer };\r\n","import pMap from 'p-map';\r\nimport { curry } from 'lodash/fp';\r\n\r\ntype AnyFunc<TA extends any[] = any[], TR = any> = (...args: TA) => TR;\r\n\r\ntype MakeProm<T> = Promise<T extends PromiseLike<infer I> ? I : T>;\r\n\r\ntype PipedFunc<T extends AnyFunc[]> =\r\n  PipeReturn<T> extends never ? never : (...args: Parameters<T[0]>) => PipeReturn<T>;\r\n\r\ntype PipeReturn<F extends AnyFunc[]> = MakeProm<ReturnType<F[0]>>;\r\n\r\nexport function pipe<T extends AnyFunc[]>(...fns: PipeReturn<T> extends never ? never : T) {\r\n  const [firstFn, ...fnRest] = fns;\r\n\r\n  return (async (...args: any[]) => {\r\n    let res = await firstFn.apply(firstFn, args);\r\n\r\n    for (let i = 0; i < fnRest.length; i += 1) {\r\n      res = await fnRest[i](res);\r\n    }\r\n\r\n    return res;\r\n  }) as PipedFunc<T>;\r\n}\r\n\r\nexport const map = curry(pMap);\r\n\r\nexport const reduce =\r\n  (mixedArray: any[]) =>\r\n  async <T>(iteratee: AnyFunc, initialValue?: T) => {\r\n    let acc = initialValue;\r\n    for (let i = 0; i < mixedArray.length; i += 1) {\r\n      acc = await iteratee(acc, await mixedArray[i], i);\r\n    }\r\n    return acc;\r\n  };\r\n","import type { Visitor } from '../../traverse/factory';\r\n\r\nconst visitor: Visitor = ({ key, attribute }, { remove }) => {\r\n  if (attribute?.type === 'password') {\r\n    remove(key);\r\n  }\r\n};\r\n\r\nexport default visitor;\r\n","import { isPrivateAttribute } from '../../content-types';\r\nimport type { Visitor } from '../../traverse/factory';\r\n\r\nconst visitor: Visitor = ({ schema, key, attribute }, { remove }) => {\r\n  if (!attribute) {\r\n    return;\r\n  }\r\n\r\n  const isPrivate = attribute.private === true || isPrivateAttribute(schema, key);\r\n\r\n  if (isPrivate) {\r\n    remove(key);\r\n  }\r\n};\r\n\r\nexport default visitor;\r\n","import { isBoolean } from 'lodash/fp';\r\nimport type { Attribute, Model } from './types';\r\n\r\nimport { isRelationalAttribute } from './content-types';\r\n\r\nconst MANY_RELATIONS = ['oneToMany', 'manyToMany'];\r\n\r\nexport const getRelationalFields = (contentType: Model) => {\r\n  return Object.keys(contentType.attributes).filter((attributeName) => {\r\n    return contentType.attributes[attributeName].type === 'relation';\r\n  });\r\n};\r\n\r\nexport const isOneToAny = (attribute: Attribute) =>\r\n  isRelationalAttribute(attribute) && ['oneToOne', 'oneToMany'].includes(attribute.relation);\r\n\r\nexport const isManyToAny = (attribute: Attribute) =>\r\n  isRelationalAttribute(attribute) && ['manyToMany', 'manyToOne'].includes(attribute.relation);\r\n\r\nexport const isAnyToOne = (attribute: Attribute) =>\r\n  isRelationalAttribute(attribute) && ['oneToOne', 'manyToOne'].includes(attribute.relation);\r\n\r\nexport const isAnyToMany = (attribute: Attribute) =>\r\n  isRelationalAttribute(attribute) && ['oneToMany', 'manyToMany'].includes(attribute.relation);\r\n\r\nexport const isPolymorphic = (attribute: any): any =>\r\n  ['morphOne', 'morphMany', 'morphToOne', 'morphToMany'].includes(attribute.relation);\r\n\r\nexport const constants = {\r\n  MANY_RELATIONS,\r\n};\r\n\r\n// Valid keys in the `options` property of relations reordering\r\n// The value for each key must be a function that returns true if it is a valid value\r\nexport const VALID_RELATION_ORDERING_KEYS: { [key: string]: (value: any) => boolean } = {\r\n  strict: isBoolean,\r\n};\r\n","import { isArray, isObject } from 'lodash/fp';\r\nimport * as contentTypeUtils from '../../content-types';\r\nimport type { Visitor } from '../../traverse/factory';\r\nimport { RelationOrderingOptions } from '../../types';\r\nimport { VALID_RELATION_ORDERING_KEYS } from '../../relations';\r\n\r\nconst ACTIONS_TO_VERIFY = ['find'];\r\nconst { CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE } = contentTypeUtils.constants;\r\n\r\ntype MorphArray = Array<{ __type: string }>;\r\n\r\nexport default (auth: unknown): Visitor =>\r\n  async ({ data, key, attribute, schema }, { remove, set }) => {\r\n    if (!attribute) {\r\n      return;\r\n    }\r\n\r\n    const isRelation = attribute.type === 'relation';\r\n\r\n    if (!isRelation) {\r\n      return;\r\n    }\r\n\r\n    const handleMorphRelation = async () => {\r\n      const elements: any = (data as Record<string, MorphArray>)[key];\r\n\r\n      if ('connect' in elements || 'set' in elements || 'disconnect' in elements) {\r\n        const newValue: Record<string, unknown> = {};\r\n\r\n        const connect = await handleMorphElements(elements.connect || []);\r\n        const relSet = await handleMorphElements(elements.set || []);\r\n        const disconnect = await handleMorphElements(elements.disconnect || []);\r\n\r\n        if (connect.length > 0) {\r\n          newValue.connect = connect;\r\n        }\r\n\r\n        if (relSet.length > 0) {\r\n          newValue.set = relSet;\r\n        }\r\n\r\n        if (disconnect.length > 0) {\r\n          newValue.disconnect = disconnect;\r\n        }\r\n\r\n        // TODO: this should technically be in its own visitor to check morph options, but for now we'll handle it here\r\n        if (\r\n          'options' in elements &&\r\n          typeof elements.options === 'object' &&\r\n          elements.options !== null\r\n        ) {\r\n          const filteredOptions: RelationOrderingOptions = {};\r\n\r\n          // Iterate through the keys of elements.options\r\n          Object.keys(elements.options).forEach((key) => {\r\n            const validator = VALID_RELATION_ORDERING_KEYS[key as keyof RelationOrderingOptions];\r\n\r\n            // Ensure the key exists in VALID_RELATION_ORDERING_KEYS and the validator is defined before calling it\r\n            if (validator && validator(elements.options[key])) {\r\n              filteredOptions[key as keyof RelationOrderingOptions] = elements.options[key];\r\n            }\r\n          });\r\n\r\n          // Assign the filtered options back to newValue\r\n          newValue.options = filteredOptions;\r\n        } else {\r\n          newValue.options = {};\r\n        }\r\n\r\n        set(key, newValue);\r\n      } else {\r\n        const newMorphValue = await handleMorphElements(elements);\r\n\r\n        if (newMorphValue.length) {\r\n          set(key, newMorphValue);\r\n        }\r\n      }\r\n    };\r\n\r\n    const handleMorphElements = async (elements: any[]) => {\r\n      const allowedElements: Record<string, unknown>[] = [];\r\n\r\n      if (!isArray(elements)) {\r\n        return allowedElements;\r\n      }\r\n\r\n      for (const element of elements) {\r\n        if (!isObject(element) || !('__type' in element)) {\r\n          continue;\r\n        }\r\n\r\n        const scopes = ACTIONS_TO_VERIFY.map((action) => `${element.__type}.${action}`);\r\n        const isAllowed = await hasAccessToSomeScopes(scopes, auth);\r\n\r\n        if (isAllowed) {\r\n          allowedElements.push(element);\r\n        }\r\n      }\r\n\r\n      return allowedElements;\r\n    };\r\n\r\n    const handleRegularRelation = async () => {\r\n      const scopes = ACTIONS_TO_VERIFY.map((action) => `${attribute.target}.${action}`);\r\n\r\n      const isAllowed = await hasAccessToSomeScopes(scopes, auth);\r\n\r\n      // If the authenticated user don't have access to any of the scopes, then remove the field\r\n      if (!isAllowed) {\r\n        remove(key);\r\n      }\r\n    };\r\n\r\n    const isCreatorRelation = [CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE].includes(key);\r\n\r\n    // Polymorphic relations\r\n    if (contentTypeUtils.isMorphToRelationalAttribute(attribute)) {\r\n      await handleMorphRelation();\r\n      return;\r\n    }\r\n\r\n    // Creator relations\r\n    if (isCreatorRelation && schema.options?.populateCreatorFields) {\r\n      // do nothing\r\n      return;\r\n    }\r\n\r\n    // Regular relations\r\n    await handleRegularRelation();\r\n  };\r\n\r\nconst hasAccessToSomeScopes = async (scopes: string[], auth: unknown) => {\r\n  for (const scope of scopes) {\r\n    try {\r\n      await strapi.auth.verify(auth, { scope });\r\n      return true;\r\n    } catch {\r\n      continue;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n","import { isMorphToRelationalAttribute } from '../../content-types';\r\nimport type { Visitor } from '../../traverse/factory';\r\n\r\nconst visitor: Visitor = ({ key, attribute }, { remove }) => {\r\n  if (isMorphToRelationalAttribute(attribute)) {\r\n    remove(key);\r\n  }\r\n};\r\n\r\nexport default visitor;\r\n","import { isDynamicZoneAttribute } from '../../content-types';\r\nimport type { Visitor } from '../../traverse/factory';\r\n\r\nconst visitor: Visitor = ({ key, attribute }, { remove }) => {\r\n  if (isDynamicZoneAttribute(attribute)) {\r\n    remove(key);\r\n  }\r\n};\r\n\r\nexport default visitor;\r\n","import { isArray, isNil, isString, toPath } from 'lodash/fp';\r\nimport type { Visitor } from '../../traverse/factory';\r\n\r\nexport default (allowedFields: string[] | null = null): Visitor =>\r\n  ({ key, path: { attribute: path } }, { remove }) => {\r\n    // All fields are allowed\r\n    if (allowedFields === null) {\r\n      return;\r\n    }\r\n\r\n    // Throw on invalid formats\r\n    if (!(isArray(allowedFields) && allowedFields.every(isString))) {\r\n      throw new TypeError(\r\n        `Expected array of strings for allowedFields but got \"${typeof allowedFields}\"`\r\n      );\r\n    }\r\n\r\n    if (isNil(path)) {\r\n      return;\r\n    }\r\n\r\n    const containedPaths = getContainedPaths(path);\r\n\r\n    /**\r\n     * Tells if the current path should be kept or not based\r\n     * on the success of the check functions for any of the allowed paths.\r\n     *\r\n     * The check functions are defined as follow:\r\n     *\r\n     * `containedPaths.includes(p)`\r\n     * @example\r\n     * ```js\r\n     * const path = 'foo.bar.field';\r\n     * const p = 'foo.bar';\r\n     * // it should match\r\n     *\r\n     * const path = 'foo.bar.field';\r\n     * const p = 'bar.foo';\r\n     * // it shouldn't match\r\n     *\r\n     * const path = 'foo.bar';\r\n     * const p = 'foo.bar.field';\r\n     * // it should match but isn't handled by this check\r\n     * ```\r\n     *\r\n     * `p.startsWith(`${path}.`)`\r\n     * @example\r\n     * ```js\r\n     * const path = 'foo.bar';\r\n     * const p = 'foo.bar.field';\r\n     * // it should match\r\n     *\r\n     * const path = 'foo.bar.field';\r\n     * const p = 'bar.foo';\r\n     * // it shouldn't match\r\n     *\r\n     * const path = 'foo.bar.field';\r\n     * const p = 'foo.bar';\r\n     * // it should match but isn't handled by this check\r\n     * ```\r\n     */\r\n    const isPathAllowed = allowedFields.some(\r\n      (p) => containedPaths.includes(p) || p.startsWith(`${path}.`)\r\n    );\r\n\r\n    if (isPathAllowed) {\r\n      return;\r\n    }\r\n\r\n    // Remove otherwise\r\n    remove(key);\r\n  };\r\n\r\n/**\r\n * Retrieve the list of allowed paths based on the given path\r\n *\r\n * @example\r\n * ```js\r\n * const containedPaths = getContainedPaths('foo');\r\n * // ['foo']\r\n *\r\n *  * const containedPaths = getContainedPaths('foo.bar');\r\n * // ['foo', 'foo.bar']\r\n *\r\n *  * const containedPaths = getContainedPaths('foo.bar.field');\r\n * // ['foo', 'foo.bar', 'foo.bar.field']\r\n * ```\r\n */\r\nconst getContainedPaths = (path: string) => {\r\n  const parts = toPath(path);\r\n\r\n  return parts.reduce((acc, value, index, list) => {\r\n    return [...acc, list.slice(0, index + 1).join('.')];\r\n  }, [] as string[]);\r\n};\r\n","import { isArray, isString } from 'lodash/fp';\r\nimport type { Visitor } from '../../traverse/factory';\r\n\r\nexport default (restrictedFields: string[] | null = null): Visitor =>\r\n  ({ key, path: { attribute: path } }, { remove }) => {\r\n    // Remove all fields\r\n    if (restrictedFields === null) {\r\n      remove(key);\r\n      return;\r\n    }\r\n\r\n    // Throw on invalid formats\r\n    if (!(isArray(restrictedFields) && restrictedFields.every(isString))) {\r\n      throw new TypeError(\r\n        `Expected array of strings for restrictedFields but got \"${typeof restrictedFields}\"`\r\n      );\r\n    }\r\n\r\n    // Remove if an exact match was found\r\n    if (restrictedFields.includes(path as string)) {\r\n      remove(key);\r\n      return;\r\n    }\r\n\r\n    // Remove nested matches\r\n    const isRestrictedNested = restrictedFields.some((allowedPath) =>\r\n      path?.toString().startsWith(`${allowedPath}.`)\r\n    );\r\n    if (isRestrictedNested) {\r\n      remove(key);\r\n    }\r\n  };\r\n","import type { Visitor } from '../../traverse/factory';\r\n\r\nconst visitor: Visitor = ({ schema, key, value }, { set }) => {\r\n  if (key === '' && value === '*') {\r\n    const { attributes } = schema;\r\n\r\n    const newPopulateQuery = Object.entries(attributes)\r\n      .filter(([, attribute]) =>\r\n        ['relation', 'component', 'media', 'dynamiczone'].includes(attribute.type)\r\n      )\r\n      .reduce<Record<string, true>>((acc, [key]) => ({ ...acc, [key]: true }), {});\r\n\r\n    set('', newPopulateQuery);\r\n  }\r\n};\r\n\r\nexport default visitor;\r\n","/* eslint-disable @typescript-eslint/no-loop-func */\r\nimport { isNil, pick } from 'lodash/fp';\r\n\r\nimport {\r\n  AnyAttribute,\r\n  Attribute,\r\n  ComponentAttribute,\r\n  DynamicZoneAttribute,\r\n  Model,\r\n  RelationalAttribute,\r\n} from '../types';\r\n\r\nexport interface Path {\r\n  raw: string | null;\r\n  attribute: string | null;\r\n}\r\n\r\nexport interface Parent {\r\n  attribute?: Attribute;\r\n  key: string | null;\r\n  path: Path;\r\n  schema: Model;\r\n}\r\n\r\nexport interface TraverseOptions {\r\n  schema: Model;\r\n  path?: Path;\r\n  parent?: Parent;\r\n  getModel(uid: string): Model;\r\n}\r\n\r\nexport interface VisitorOptions {\r\n  data: unknown;\r\n  value: unknown;\r\n  schema: Model;\r\n  key: string;\r\n  attribute?: AnyAttribute;\r\n  path: Path;\r\n  parent?: Parent;\r\n  getModel(uid: string): Model;\r\n}\r\n\r\nexport type Traverse = (\r\n  visitor: Visitor,\r\n  options: TraverseOptions,\r\n  data: unknown\r\n) => Promise<unknown>;\r\n\r\nexport interface Visitor {\r\n  (visitorOptions: VisitorOptions, opts: Pick<TransformUtils, 'set' | 'remove'>): void;\r\n}\r\n\r\ninterface Interceptor<T = unknown> {\r\n  predicate(data: unknown): data is T;\r\n  handler(\r\n    visitor: Visitor,\r\n    options: TraverseOptions,\r\n    data: T,\r\n    recurseOptions: { recurse: Traverse }\r\n  ): void;\r\n}\r\n\r\ninterface ParseUtils<T> {\r\n  transform(data: T): unknown;\r\n  remove(key: string, data: T): unknown;\r\n  set(key: string, value: unknown, data: T): unknown;\r\n  keys(data: T): string[];\r\n  get(key: string, data: T): unknown;\r\n}\r\n\r\ninterface Parser<T = unknown> {\r\n  predicate(data: unknown): data is T;\r\n  parser(data: T): ParseUtils<T>;\r\n}\r\n\r\ninterface Ignore {\r\n  (ctx: Context): boolean;\r\n}\r\n\r\ninterface AttributeHandler<AttributeType = Attribute> {\r\n  predicate(ctx: Context<AttributeType>): boolean;\r\n  handler(ctx: Context<AttributeType>, opts: Pick<TransformUtils, 'set' | 'recurse'>): void;\r\n}\r\ninterface CommonHandler<AttributeType = Attribute> {\r\n  predicate(ctx: Context<AttributeType>): boolean;\r\n  handler(ctx: Context<AttributeType>, opts: Pick<TransformUtils, 'set' | 'recurse'>): void;\r\n}\r\n\r\nexport interface TransformUtils {\r\n  remove(key: string): void;\r\n  set(key: string, value: unknown): void;\r\n  recurse: Traverse;\r\n}\r\n\r\ninterface Context<AttributeType = Attribute> {\r\n  key: string;\r\n  value: unknown;\r\n  attribute: AttributeType;\r\n  schema: Model;\r\n  path: Path;\r\n  data: unknown;\r\n  visitor: Visitor;\r\n  parent?: Parent;\r\n  getModel(uid: string): Model;\r\n}\r\n\r\ninterface State {\r\n  parsers: Parser[];\r\n  interceptors: Interceptor[];\r\n  ignore: Ignore[];\r\n  handlers: {\r\n    attributes: AttributeHandler[];\r\n    common: CommonHandler[];\r\n  };\r\n}\r\n\r\nconst DEFAULT_PATH = { raw: null, attribute: null } satisfies Path;\r\n\r\nexport default () => {\r\n  const state: State = {\r\n    parsers: [],\r\n    interceptors: [],\r\n    ignore: [],\r\n    handlers: {\r\n      attributes: [],\r\n      common: [],\r\n    },\r\n  };\r\n\r\n  const traverse: Traverse = async (visitor, options, data) => {\r\n    const { path = DEFAULT_PATH, parent, schema, getModel } = options ?? {};\r\n\r\n    // interceptors\r\n    for (const { predicate, handler } of state.interceptors) {\r\n      if (predicate(data)) {\r\n        return handler(visitor, options, data, { recurse: traverse });\r\n      }\r\n    }\r\n\r\n    // parsers\r\n    const parser = state.parsers.find((parser) => parser.predicate(data))?.parser;\r\n    const utils = parser?.(data);\r\n\r\n    // Return the data untouched if we don't know how to traverse it\r\n    if (!utils) {\r\n      return data;\r\n    }\r\n\r\n    // main loop\r\n    let out = utils.transform(data);\r\n    const keys = utils.keys(out);\r\n\r\n    for (const key of keys) {\r\n      const attribute = schema?.attributes?.[key];\r\n\r\n      const newPath = { ...path };\r\n\r\n      newPath.raw = isNil(path.raw) ? key : `${path.raw}.${key}`;\r\n\r\n      if (!isNil(attribute)) {\r\n        newPath.attribute = isNil(path.attribute) ? key : `${path.attribute}.${key}`;\r\n      }\r\n\r\n      // visitors\r\n      const visitorOptions: VisitorOptions = {\r\n        key,\r\n        value: utils.get(key, out),\r\n        attribute,\r\n        schema,\r\n        path: newPath,\r\n        data: out,\r\n        getModel,\r\n        parent,\r\n      };\r\n\r\n      const transformUtils: TransformUtils = {\r\n        remove(key) {\r\n          out = utils.remove(key, out);\r\n        },\r\n        set(key, value) {\r\n          out = utils.set(key, value, out);\r\n        },\r\n        recurse: traverse,\r\n      };\r\n\r\n      await visitor(visitorOptions, pick(['remove', 'set'], transformUtils));\r\n\r\n      const value = utils.get(key, out);\r\n\r\n      const createContext = (): Context => ({\r\n        key,\r\n        value,\r\n        attribute,\r\n        schema,\r\n        path: newPath,\r\n        data: out,\r\n        visitor,\r\n        getModel,\r\n        parent,\r\n      });\r\n\r\n      // ignore\r\n      const ignoreCtx = createContext();\r\n      const shouldIgnore = state.ignore.some((predicate) => predicate(ignoreCtx));\r\n\r\n      if (shouldIgnore) {\r\n        continue;\r\n      }\r\n\r\n      // handlers\r\n      const handlers = [...state.handlers.common, ...state.handlers.attributes];\r\n\r\n      for await (const handler of handlers) {\r\n        const ctx = createContext();\r\n        const pass = await handler.predicate(ctx);\r\n\r\n        if (pass) {\r\n          await handler.handler(ctx, pick(['recurse', 'set'], transformUtils));\r\n        }\r\n      }\r\n    }\r\n\r\n    return out;\r\n  };\r\n\r\n  return {\r\n    traverse,\r\n\r\n    intercept<T>(predicate: Interceptor<T>['predicate'], handler: Interceptor<T>['handler']) {\r\n      state.interceptors.push({ predicate, handler });\r\n      return this;\r\n    },\r\n\r\n    parse<T>(predicate: Parser<T>['predicate'], parser: Parser<T>['parser']) {\r\n      state.parsers.push({ predicate, parser });\r\n      return this;\r\n    },\r\n\r\n    ignore(predicate: Ignore) {\r\n      state.ignore.push(predicate);\r\n      return this;\r\n    },\r\n\r\n    on(predicate: CommonHandler['predicate'], handler: CommonHandler['handler']) {\r\n      state.handlers.common.push({ predicate, handler });\r\n      return this;\r\n    },\r\n\r\n    onAttribute(predicate: AttributeHandler['predicate'], handler: AttributeHandler['handler']) {\r\n      state.handlers.attributes.push({ predicate, handler });\r\n      return this;\r\n    },\r\n\r\n    onRelation(handler: AttributeHandler<RelationalAttribute>['handler']) {\r\n      return this.onAttribute(({ attribute }) => attribute?.type === 'relation', handler);\r\n    },\r\n\r\n    onMedia(handler: AttributeHandler<RelationalAttribute>['handler']) {\r\n      return this.onAttribute(({ attribute }) => attribute?.type === 'media', handler);\r\n    },\r\n\r\n    onComponent(handler: AttributeHandler<ComponentAttribute>['handler']) {\r\n      return this.onAttribute(({ attribute }) => attribute?.type === 'component', handler);\r\n    },\r\n\r\n    onDynamicZone(handler: AttributeHandler<DynamicZoneAttribute>['handler']) {\r\n      return this.onAttribute(({ attribute }) => attribute?.type === 'dynamiczone', handler);\r\n    },\r\n  };\r\n};\r\n","import { curry, isObject, isEmpty, isArray, isNil, cloneDeep, omit } from 'lodash/fp';\r\n\r\nimport traverseFactory, { type Parent } from './factory';\r\n\r\nconst isObj = (value: unknown): value is Record<string, unknown> => isObject(value);\r\n\r\nconst filters = traverseFactory()\r\n  .intercept(\r\n    // Intercept filters arrays and apply the traversal to each one individually\r\n    isArray,\r\n    async (visitor, options, filters, { recurse }) => {\r\n      return Promise.all(\r\n        filters.map((filter, i) => {\r\n          // In filters, only operators such as $and, $in, $notIn or $or and implicit operators like [...]\r\n          // can have a value array, thus we can update the raw path but not the attribute one\r\n          const newPath = options.path\r\n            ? { ...options.path, raw: `${options.path.raw}[${i}]` }\r\n            : options.path;\r\n\r\n          return recurse(visitor, { ...options, path: newPath }, filter);\r\n        })\r\n        // todo: move that to the visitors\r\n      ).then((res) => res.filter((val) => !(isObject(val) && isEmpty(val))));\r\n    }\r\n  )\r\n  .intercept(\r\n    // Ignore non object filters and return the value as-is\r\n    (filters): filters is unknown => !isObject(filters),\r\n    (_, __, filters) => {\r\n      return filters;\r\n    }\r\n  )\r\n  // Parse object values\r\n  .parse(isObj, () => ({\r\n    transform: cloneDeep,\r\n\r\n    remove(key, data) {\r\n      return omit(key, data);\r\n    },\r\n\r\n    set(key, value, data) {\r\n      return { ...data, [key]: value };\r\n    },\r\n\r\n    keys(data) {\r\n      return Object.keys(data);\r\n    },\r\n\r\n    get(key, data) {\r\n      return data[key];\r\n    },\r\n  }))\r\n  // Ignore null or undefined values\r\n  .ignore(({ value }) => isNil(value))\r\n  // Recursion on operators (non attributes)\r\n  .on(\r\n    ({ attribute }) => isNil(attribute),\r\n    async ({ key, visitor, path, value, schema, getModel, attribute }, { set, recurse }) => {\r\n      const parent: Parent = { key, path, schema, attribute };\r\n\r\n      set(key, await recurse(visitor, { schema, path, getModel, parent }, value));\r\n    }\r\n  )\r\n  // Handle relation recursion\r\n  .onRelation(\r\n    async ({ key, attribute, visitor, path, value, schema, getModel }, { set, recurse }) => {\r\n      const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');\r\n\r\n      if (isMorphRelation) {\r\n        return;\r\n      }\r\n\r\n      const parent: Parent = { key, path, schema, attribute };\r\n\r\n      const targetSchemaUID = attribute.target;\r\n      const targetSchema = getModel(targetSchemaUID!);\r\n\r\n      const newValue = await recurse(\r\n        visitor,\r\n        { schema: targetSchema, path, getModel, parent },\r\n        value\r\n      );\r\n\r\n      set(key, newValue);\r\n    }\r\n  )\r\n  .onComponent(\r\n    async ({ key, attribute, visitor, path, schema, value, getModel }, { set, recurse }) => {\r\n      const parent: Parent = { key, path, schema, attribute };\r\n      const targetSchema = getModel(attribute.component);\r\n\r\n      const newValue = await recurse(\r\n        visitor,\r\n        { schema: targetSchema, path, getModel, parent },\r\n        value\r\n      );\r\n\r\n      set(key, newValue);\r\n    }\r\n  )\r\n  // Handle media recursion\r\n  .onMedia(async ({ key, visitor, path, schema, attribute, value, getModel }, { set, recurse }) => {\r\n    const parent: Parent = { key, path, schema, attribute };\r\n\r\n    const targetSchemaUID = 'plugin::upload.file';\r\n    const targetSchema = getModel(targetSchemaUID);\r\n\r\n    const newValue = await recurse(\r\n      visitor,\r\n      { schema: targetSchema, path, getModel, parent },\r\n      value\r\n    );\r\n\r\n    set(key, newValue);\r\n  });\r\n\r\nexport default curry(filters.traverse);\r\n","import {\r\n  curry,\r\n  isString,\r\n  isObject,\r\n  map,\r\n  trim,\r\n  split,\r\n  isEmpty,\r\n  flatten,\r\n  pipe,\r\n  isNil,\r\n  first,\r\n  cloneDeep,\r\n} from 'lodash/fp';\r\n\r\nimport traverseFactory, { type Parent } from './factory';\r\n\r\nconst ORDERS = { asc: 'asc', desc: 'desc' };\r\nconst ORDER_VALUES = Object.values(ORDERS);\r\n\r\nconst isSortOrder = (value: string) => ORDER_VALUES.includes(value.toLowerCase());\r\nconst isStringArray = (value: unknown): value is string[] =>\r\n  Array.isArray(value) && value.every(isString);\r\nconst isObjectArray = (value: unknown): value is object[] =>\r\n  Array.isArray(value) && value.every(isObject);\r\nconst isNestedSorts = (value: unknown): value is string =>\r\n  isString(value) && value.split(',').length > 1;\r\n\r\nconst isObj = (value: unknown): value is Record<string, unknown> => isObject(value);\r\n\r\nconst sort = traverseFactory()\r\n  .intercept(\r\n    // String with chained sorts (foo,bar,foobar) => split, map(recurse), then recompose\r\n    isNestedSorts,\r\n    async (visitor, options, sort, { recurse }) => {\r\n      return Promise.all(\r\n        sort\r\n          .split(',')\r\n          .map(trim)\r\n          .map((nestedSort) => recurse(visitor, options, nestedSort))\r\n      ).then((res) => res.filter((part) => !isEmpty(part)).join(','));\r\n    }\r\n  )\r\n  .intercept(\r\n    // Array of strings ['foo', 'foo,bar'] => map(recurse), then filter out empty items\r\n    isStringArray,\r\n    async (visitor, options, sort, { recurse }) => {\r\n      return Promise.all(sort.map((nestedSort) => recurse(visitor, options, nestedSort))).then(\r\n        (res) => res.filter((nestedSort) => !isEmpty(nestedSort))\r\n      );\r\n    }\r\n  )\r\n  .intercept(\r\n    // Array of objects [{ foo: 'asc' }, { bar: 'desc', baz: 'asc' }] => map(recurse), then filter out empty items\r\n    isObjectArray,\r\n    async (visitor, options, sort, { recurse }) => {\r\n      return Promise.all(sort.map((nestedSort) => recurse(visitor, options, nestedSort))).then(\r\n        (res) => res.filter((nestedSort) => !isEmpty(nestedSort))\r\n      );\r\n    }\r\n  )\r\n  // Parse string values\r\n  .parse(isString, () => {\r\n    const tokenize = pipe(split('.'), map(split(':')), flatten);\r\n    const recompose = (parts: string[]) => {\r\n      if (parts.length === 0) {\r\n        return undefined;\r\n      }\r\n\r\n      return parts.reduce((acc, part) => {\r\n        if (isEmpty(part)) {\r\n          return acc;\r\n        }\r\n\r\n        if (acc === '') {\r\n          return part;\r\n        }\r\n\r\n        return isSortOrder(part) ? `${acc}:${part}` : `${acc}.${part}`;\r\n      }, '');\r\n    };\r\n\r\n    return {\r\n      transform: trim,\r\n\r\n      remove(key, data) {\r\n        const [root] = tokenize(data);\r\n\r\n        return root === key ? undefined : data;\r\n      },\r\n\r\n      set(key, value, data) {\r\n        const [root] = tokenize(data);\r\n\r\n        if (root !== key) {\r\n          return data;\r\n        }\r\n\r\n        return isNil(value) ? root : `${root}.${value}`;\r\n      },\r\n\r\n      keys(data) {\r\n        const v = first(tokenize(data));\r\n        return v ? [v] : [];\r\n      },\r\n\r\n      get(key, data) {\r\n        const [root, ...rest] = tokenize(data);\r\n\r\n        return key === root ? recompose(rest) : undefined;\r\n      },\r\n    };\r\n  })\r\n  // Parse object values\r\n  .parse(isObj, () => ({\r\n    transform: cloneDeep,\r\n\r\n    remove(key, data) {\r\n      // eslint-disable-next-line no-unused-vars\r\n      const { [key]: ignored, ...rest } = data;\r\n\r\n      return rest;\r\n    },\r\n\r\n    set(key, value, data) {\r\n      return { ...data, [key]: value };\r\n    },\r\n\r\n    keys(data) {\r\n      return Object.keys(data);\r\n    },\r\n\r\n    get(key, data) {\r\n      return data[key];\r\n    },\r\n  }))\r\n  // Handle deep sort on relation\r\n  .onRelation(\r\n    async ({ key, value, attribute, visitor, path, getModel, schema }, { set, recurse }) => {\r\n      const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');\r\n\r\n      if (isMorphRelation) {\r\n        return;\r\n      }\r\n\r\n      const parent: Parent = { key, path, schema, attribute };\r\n\r\n      const targetSchemaUID = attribute.target;\r\n      const targetSchema = getModel(targetSchemaUID!);\r\n\r\n      const newValue = await recurse(\r\n        visitor,\r\n        { schema: targetSchema, path, getModel, parent },\r\n        value\r\n      );\r\n\r\n      set(key, newValue);\r\n    }\r\n  )\r\n  // Handle deep sort on media\r\n  .onMedia(async ({ key, path, schema, attribute, visitor, value, getModel }, { recurse, set }) => {\r\n    const parent: Parent = { key, path, schema, attribute };\r\n\r\n    const targetSchemaUID = 'plugin::upload.file';\r\n    const targetSchema = getModel(targetSchemaUID);\r\n\r\n    const newValue = await recurse(\r\n      visitor,\r\n      { schema: targetSchema, path, getModel, parent },\r\n      value\r\n    );\r\n\r\n    set(key, newValue);\r\n  })\r\n  // Handle deep sort on components\r\n  .onComponent(\r\n    async ({ key, value, visitor, path, schema, attribute, getModel }, { recurse, set }) => {\r\n      const parent: Parent = { key, path, schema, attribute };\r\n\r\n      const targetSchema = getModel(attribute.component);\r\n\r\n      const newValue = await recurse(\r\n        visitor,\r\n        { schema: targetSchema, path, getModel, parent },\r\n        value\r\n      );\r\n\r\n      set(key, newValue);\r\n    }\r\n  );\r\n\r\nexport default curry(sort.traverse);\r\n","import {\r\n  curry,\r\n  isString,\r\n  isArray,\r\n  isEmpty,\r\n  split,\r\n  isObject,\r\n  trim,\r\n  constant,\r\n  isNil,\r\n  identity,\r\n  cloneDeep,\r\n  join,\r\n  first,\r\n} from 'lodash/fp';\r\n\r\nimport traverseFactory, { type Parent } from './factory';\r\nimport { Attribute } from '../types';\r\nimport { isMorphToRelationalAttribute } from '../content-types';\r\n\r\nconst isKeyword = (keyword: string) => {\r\n  return ({ key, attribute }: { key: string; attribute: Attribute }) => {\r\n    return !attribute && keyword === key;\r\n  };\r\n};\r\n\r\nconst isWildcard = (value: unknown): value is '*' => value === '*';\r\n\r\nconst isPopulateString = (value: unknown): value is string => {\r\n  return isString(value) && !isWildcard(value);\r\n};\r\n\r\nconst isStringArray = (value: unknown): value is string[] =>\r\n  isArray(value) && value.every(isString);\r\n\r\nconst isObj = (value: unknown): value is Record<string, unknown> => isObject(value);\r\n\r\nconst populate = traverseFactory()\r\n  .intercept(isPopulateString, async (visitor, options, populate, { recurse }) => {\r\n    /**\r\n     * Ensure the populate clause its in the extended format ( { populate: { ... } }, and not just a string)\r\n     * This gives a consistent structure to track the \"parent\" node of each nested populate clause\r\n     */\r\n    const populateObject = pathsToObjectPopulate([populate]);\r\n    const traversedPopulate = (await recurse(visitor, options, populateObject)) as PopulateObject;\r\n    const [result] = objectPopulateToPaths(traversedPopulate);\r\n\r\n    return result;\r\n  })\r\n  // Array of strings ['foo', 'bar.baz'] => map(recurse), then filter out empty items\r\n  .intercept(isStringArray, async (visitor, options, populate, { recurse }) => {\r\n    const paths = await Promise.all(\r\n      populate.map((subClause) => recurse(visitor, options, subClause))\r\n    );\r\n\r\n    return paths.filter((item) => !isNil(item));\r\n  })\r\n  // for wildcard, generate custom utilities to modify the values\r\n  .parse(isWildcard, () => ({\r\n    /**\r\n     * Since value is '*', we don't need to transform it\r\n     */\r\n    transform: identity,\r\n\r\n    /**\r\n     * '*' isn't a key/value structure, so regardless\r\n     *  of the given key, it returns the data ('*')\r\n     */\r\n    get: (_key, data) => data,\r\n\r\n    /**\r\n     * '*' isn't a key/value structure, so regardless\r\n     * of the given `key`, use `value` as the new `data`\r\n     */\r\n    set: (_key, value) => value,\r\n\r\n    /**\r\n     * '*' isn't a key/value structure, but we need to simulate at least one to enable\r\n     * the data traversal. We're using '' since it represents a falsy string value\r\n     */\r\n    keys: constant(['']),\r\n\r\n    /**\r\n     * Removing '*' means setting it to undefined, regardless of the given key\r\n     */\r\n    remove: constant(undefined),\r\n  }))\r\n\r\n  // Parse string values\r\n  .parse(isString, () => {\r\n    const tokenize = split('.');\r\n    const recompose = join('.');\r\n\r\n    return {\r\n      transform: trim,\r\n\r\n      remove(key, data) {\r\n        const [root] = tokenize(data);\r\n\r\n        return root === key ? undefined : data;\r\n      },\r\n\r\n      set(key, value, data) {\r\n        const [root] = tokenize(data);\r\n\r\n        if (root !== key) {\r\n          return data;\r\n        }\r\n\r\n        return isNil(value) || isEmpty(value) ? root : `${root}.${value}`;\r\n      },\r\n\r\n      keys(data) {\r\n        const v = first(tokenize(data));\r\n        return v ? [v] : [];\r\n      },\r\n\r\n      get(key, data) {\r\n        const [root, ...rest] = tokenize(data);\r\n\r\n        return key === root ? recompose(rest) : undefined;\r\n      },\r\n    };\r\n  })\r\n  // Parse object values\r\n  .parse(isObj, () => ({\r\n    transform: cloneDeep,\r\n\r\n    remove(key, data) {\r\n      // eslint-disable-next-line no-unused-vars\r\n      const { [key]: ignored, ...rest } = data;\r\n\r\n      return rest;\r\n    },\r\n\r\n    set(key, value, data) {\r\n      return { ...data, [key]: value };\r\n    },\r\n\r\n    keys(data) {\r\n      return Object.keys(data);\r\n    },\r\n\r\n    get(key, data) {\r\n      return data[key];\r\n    },\r\n  }))\r\n  .ignore(({ key, attribute }) => {\r\n    // we don't want to recurse using traversePopulate and instead let\r\n    // the visitors recurse with the appropriate traversal (sort, filters, etc...)\r\n    return ['sort', 'filters', 'fields'].includes(key) && !attribute;\r\n  })\r\n  .on(\r\n    // Handle recursion on populate.\"populate\"\r\n    isKeyword('populate'),\r\n    async ({ key, visitor, path, value, schema, getModel, attribute }, { set, recurse }) => {\r\n      const parent: Parent = { key, path, schema, attribute };\r\n\r\n      const newValue = await recurse(visitor, { schema, path, getModel, parent }, value);\r\n\r\n      set(key, newValue);\r\n    }\r\n  )\r\n  .on(\r\n    isKeyword('on'),\r\n    async ({ key, visitor, path, value, getModel, parent }, { set, recurse }) => {\r\n      const newOn: Record<string, unknown> = {};\r\n\r\n      if (!isObj(value)) {\r\n        return;\r\n      }\r\n\r\n      for (const [uid, subPopulate] of Object.entries(value)) {\r\n        const model = getModel(uid);\r\n        const newPath = { ...path, raw: `${path.raw}[${uid}]` };\r\n\r\n        newOn[uid] = await recurse(\r\n          visitor,\r\n          { schema: model, path: newPath, getModel, parent },\r\n          subPopulate\r\n        );\r\n      }\r\n\r\n      set(key, newOn);\r\n    }\r\n  )\r\n  // Handle populate on relation\r\n  .onRelation(\r\n    async ({ key, value, attribute, visitor, path, schema, getModel }, { set, recurse }) => {\r\n      if (isNil(value)) {\r\n        return;\r\n      }\r\n\r\n      const parent: Parent = { key, path, schema, attribute };\r\n\r\n      if (isMorphToRelationalAttribute(attribute)) {\r\n        // Don't traverse values that cannot be parsed\r\n        if (!isObject(value) || !('on' in value && isObject(value?.on))) {\r\n          return;\r\n        }\r\n\r\n        // If there is a populate fragment defined, traverse it\r\n        const newValue = await recurse(\r\n          visitor,\r\n          { schema, path, getModel, parent },\r\n          { on: value?.on }\r\n        );\r\n\r\n        set(key, newValue);\r\n\r\n        return;\r\n      }\r\n\r\n      const targetSchemaUID = attribute.target;\r\n      const targetSchema = getModel(targetSchemaUID!);\r\n\r\n      const newValue = await recurse(\r\n        visitor,\r\n        { schema: targetSchema, path, getModel, parent },\r\n        value\r\n      );\r\n\r\n      set(key, newValue);\r\n    }\r\n  )\r\n  // Handle populate on media\r\n  .onMedia(async ({ key, path, schema, attribute, visitor, value, getModel }, { recurse, set }) => {\r\n    if (isNil(value)) {\r\n      return;\r\n    }\r\n\r\n    const parent: Parent = { key, path, schema, attribute };\r\n\r\n    const targetSchemaUID = 'plugin::upload.file';\r\n    const targetSchema = getModel(targetSchemaUID);\r\n\r\n    const newValue = await recurse(\r\n      visitor,\r\n      { schema: targetSchema, path, getModel, parent },\r\n      value\r\n    );\r\n\r\n    set(key, newValue);\r\n  })\r\n  // Handle populate on components\r\n  .onComponent(\r\n    async ({ key, value, schema, visitor, path, attribute, getModel }, { recurse, set }) => {\r\n      if (isNil(value)) {\r\n        return;\r\n      }\r\n\r\n      const parent: Parent = { key, path, schema, attribute };\r\n\r\n      const targetSchema = getModel(attribute.component);\r\n\r\n      const newValue = await recurse(\r\n        visitor,\r\n        { schema: targetSchema, path, getModel, parent },\r\n        value\r\n      );\r\n\r\n      set(key, newValue);\r\n    }\r\n  )\r\n  // Handle populate on dynamic zones\r\n  .onDynamicZone(\r\n    async ({ key, value, schema, visitor, path, attribute, getModel }, { set, recurse }) => {\r\n      if (isNil(value) || !isObject(value)) {\r\n        return;\r\n      }\r\n\r\n      const parent: Parent = { key, path, schema, attribute };\r\n\r\n      // Handle fragment syntax\r\n      if ('on' in value && value.on) {\r\n        const newOn = await recurse(visitor, { schema, path, getModel, parent }, { on: value.on });\r\n\r\n        set(key, newOn);\r\n      }\r\n    }\r\n  );\r\n\r\nexport default curry(populate.traverse);\r\n\r\ntype PopulateObject = {\r\n  [key: string]: true | { populate: PopulateObject };\r\n};\r\n\r\nconst objectPopulateToPaths = (input: PopulateObject): string[] => {\r\n  const paths: string[] = [];\r\n\r\n  function traverse(currentObj: PopulateObject, parentPath: string) {\r\n    for (const [key, value] of Object.entries(currentObj)) {\r\n      const currentPath = parentPath ? `${parentPath}.${key}` : key;\r\n      if (value === true) {\r\n        paths.push(currentPath);\r\n      } else {\r\n        traverse((value as { populate: PopulateObject }).populate, currentPath);\r\n      }\r\n    }\r\n  }\r\n\r\n  traverse(input, '');\r\n\r\n  return paths;\r\n};\r\n\r\nconst pathsToObjectPopulate = (input: string[]): PopulateObject => {\r\n  const result: PopulateObject = {};\r\n\r\n  function traverse(object: PopulateObject, keys: string[]): void {\r\n    const [first, ...rest] = keys;\r\n    if (rest.length === 0) {\r\n      object[first] = true;\r\n    } else {\r\n      if (!object[first] || typeof object[first] === 'boolean') {\r\n        object[first] = { populate: {} };\r\n      }\r\n      traverse((object[first] as { populate: PopulateObject }).populate, rest);\r\n    }\r\n  }\r\n\r\n  input.forEach((clause) => traverse(result, clause.split('.')));\r\n\r\n  return result;\r\n};\r\n","import { curry, isArray, isString, eq, trim, constant } from 'lodash/fp';\r\n\r\nimport traverseFactory from './factory';\r\n\r\nconst isStringArray = (value: unknown): value is string[] => {\r\n  return isArray(value) && value.every(isString);\r\n};\r\n\r\nconst fields = traverseFactory()\r\n  // Intercept array of strings\r\n  // e.g. fields=['title', 'description']\r\n  .intercept(isStringArray, async (visitor, options, fields, { recurse }) => {\r\n    return Promise.all(fields.map((field) => recurse(visitor, options, field)));\r\n  })\r\n  // Intercept comma separated fields (as string)\r\n  // e.g. fields='title,description'\r\n  .intercept(\r\n    (value): value is string => isString(value) && value.includes(','),\r\n    (visitor, options, fields, { recurse }) => {\r\n      return Promise.all(fields.split(',').map((field) => recurse(visitor, options, field)));\r\n    }\r\n  )\r\n  // Return wildcards as is\r\n  .intercept((value): value is string => eq('*', value), constant('*'))\r\n  // Parse string values\r\n  // Since we're parsing strings only, each value should be an attribute name (and it's value, undefined),\r\n  // thus it shouldn't be possible to set a new value, and get should return the whole data if key === data\r\n  .parse(isString, () => ({\r\n    transform: trim,\r\n\r\n    remove(key, data) {\r\n      return data === key ? undefined : data;\r\n    },\r\n\r\n    set(_key, _value, data) {\r\n      return data;\r\n    },\r\n\r\n    keys(data) {\r\n      return [data];\r\n    },\r\n\r\n    get(key, data) {\r\n      return key === data ? data : undefined;\r\n    },\r\n  }));\r\n\r\nexport default curry(fields.traverse);\r\n","import { curry, isEmpty, isNil, isArray, isObject } from 'lodash/fp';\r\n\r\nimport { pipe as pipeAsync } from '../async';\r\nimport traverseEntity from '../traverse-entity';\r\nimport { isScalarAttribute, constants } from '../content-types';\r\n\r\nimport {\r\n  traverseQueryFilters,\r\n  traverseQuerySort,\r\n  traverseQueryPopulate,\r\n  traverseQueryFields,\r\n} from '../traverse';\r\n\r\nimport {\r\n  removePassword,\r\n  removePrivate,\r\n  removeDynamicZones,\r\n  removeMorphToRelations,\r\n  expandWildcardPopulate,\r\n} from './visitors';\r\nimport { isOperator } from '../operators';\r\n\r\nimport type { Model, Data } from '../types';\r\nimport type { Parent } from '../traverse/factory';\r\n\r\ninterface Context {\r\n  schema: Model;\r\n  getModel: (model: string) => Model;\r\n  parent?: Parent;\r\n}\r\n\r\nconst { ID_ATTRIBUTE, DOC_ID_ATTRIBUTE } = constants;\r\n\r\nconst sanitizePasswords = (ctx: Context) => async (entity: Data) => {\r\n  if (!ctx.schema) {\r\n    throw new Error('Missing schema in sanitizePasswords');\r\n  }\r\n\r\n  return traverseEntity(removePassword, ctx, entity);\r\n};\r\n\r\nconst defaultSanitizeOutput = async (ctx: Context, entity: Data) => {\r\n  if (!ctx.schema) {\r\n    throw new Error('Missing schema in defaultSanitizeOutput');\r\n  }\r\n\r\n  return traverseEntity(\r\n    (...args) => {\r\n      removePassword(...args);\r\n      removePrivate(...args);\r\n    },\r\n    ctx,\r\n    entity\r\n  );\r\n};\r\n\r\nconst defaultSanitizeFilters = curry((ctx: Context, filters: unknown) => {\r\n  if (!ctx.schema) {\r\n    throw new Error('Missing schema in defaultSanitizeFilters');\r\n  }\r\n\r\n  return pipeAsync(\r\n    // Remove keys that are not attributes or valid operators\r\n    traverseQueryFilters(({ key, attribute }, { remove }) => {\r\n      const isAttribute = !!attribute;\r\n\r\n      // ID is not an attribute per se, so we need to make\r\n      // an extra check to ensure we're not checking it\r\n      if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\r\n        return;\r\n      }\r\n\r\n      if (!isAttribute && !isOperator(key)) {\r\n        remove(key);\r\n      }\r\n    }, ctx),\r\n    // Remove dynamic zones from filters\r\n    traverseQueryFilters(removeDynamicZones, ctx),\r\n    // Remove morpTo relations from filters\r\n    traverseQueryFilters(removeMorphToRelations, ctx),\r\n    // Remove passwords from filters\r\n    traverseQueryFilters(removePassword, ctx),\r\n    // Remove private from filters\r\n    traverseQueryFilters(removePrivate, ctx),\r\n    // Remove empty objects\r\n    traverseQueryFilters(({ key, value }, { remove }) => {\r\n      if (isObject(value) && isEmpty(value)) {\r\n        remove(key);\r\n      }\r\n    }, ctx)\r\n  )(filters);\r\n});\r\n\r\nconst defaultSanitizeSort = curry((ctx: Context, sort: unknown) => {\r\n  if (!ctx.schema) {\r\n    throw new Error('Missing schema in defaultSanitizeSort');\r\n  }\r\n\r\n  return pipeAsync(\r\n    // Remove non attribute keys\r\n    traverseQuerySort(({ key, attribute }, { remove }) => {\r\n      // ID is not an attribute per se, so we need to make\r\n      // an extra check to ensure we're not checking it\r\n      if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\r\n        return;\r\n      }\r\n\r\n      if (!attribute) {\r\n        remove(key);\r\n      }\r\n    }, ctx),\r\n    // Remove dynamic zones from sort\r\n    traverseQuerySort(removeDynamicZones, ctx),\r\n    // Remove morpTo relations from sort\r\n    traverseQuerySort(removeMorphToRelations, ctx),\r\n    // Remove private from sort\r\n    traverseQuerySort(removePrivate, ctx),\r\n    // Remove passwords from filters\r\n    traverseQuerySort(removePassword, ctx),\r\n    // Remove keys for empty non-scalar values\r\n    traverseQuerySort(({ key, attribute, value }, { remove }) => {\r\n      // ID is not an attribute per se, so we need to make\r\n      // an extra check to ensure we're not removing it\r\n      if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\r\n        return;\r\n      }\r\n\r\n      if (!isScalarAttribute(attribute) && isEmpty(value)) {\r\n        remove(key);\r\n      }\r\n    }, ctx)\r\n  )(sort);\r\n});\r\n\r\nconst defaultSanitizeFields = curry((ctx: Context, fields: unknown) => {\r\n  if (!ctx.schema) {\r\n    throw new Error('Missing schema in defaultSanitizeFields');\r\n  }\r\n\r\n  return pipeAsync(\r\n    // Only keep scalar attributes\r\n    traverseQueryFields(({ key, attribute }, { remove }) => {\r\n      // ID is not an attribute per se, so we need to make\r\n      // an extra check to ensure we're not checking it\r\n      if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\r\n        return;\r\n      }\r\n\r\n      if (isNil(attribute) || !isScalarAttribute(attribute)) {\r\n        remove(key);\r\n      }\r\n    }, ctx),\r\n    // Remove private fields\r\n    traverseQueryFields(removePrivate, ctx),\r\n    // Remove password fields\r\n    traverseQueryFields(removePassword, ctx),\r\n    // Remove nil values from fields array\r\n    (value) => (isArray(value) ? value.filter((field) => !isNil(field)) : value)\r\n  )(fields);\r\n});\r\n\r\nconst defaultSanitizePopulate = curry((ctx: Context, populate: unknown) => {\r\n  if (!ctx.schema) {\r\n    throw new Error('Missing schema in defaultSanitizePopulate');\r\n  }\r\n\r\n  return pipeAsync(\r\n    traverseQueryPopulate(expandWildcardPopulate, ctx),\r\n    traverseQueryPopulate(async ({ key, value, schema, attribute, getModel, path }, { set }) => {\r\n      if (attribute) {\r\n        return;\r\n      }\r\n\r\n      const parent = { key, path, schema, attribute } satisfies Parent;\r\n\r\n      if (key === 'sort') {\r\n        set(key, await defaultSanitizeSort({ schema, getModel, parent }, value));\r\n      }\r\n\r\n      if (key === 'filters') {\r\n        set(key, await defaultSanitizeFilters({ schema, getModel, parent }, value));\r\n      }\r\n\r\n      if (key === 'fields') {\r\n        set(key, await defaultSanitizeFields({ schema, getModel, parent }, value));\r\n      }\r\n\r\n      if (key === 'populate') {\r\n        set(key, await defaultSanitizePopulate({ schema, getModel, parent }, value));\r\n      }\r\n    }, ctx),\r\n    // Remove private fields\r\n    traverseQueryPopulate(removePrivate, ctx)\r\n  )(populate);\r\n});\r\n\r\nexport {\r\n  sanitizePasswords,\r\n  defaultSanitizeOutput,\r\n  defaultSanitizeFilters,\r\n  defaultSanitizeSort,\r\n  defaultSanitizeFields,\r\n  defaultSanitizePopulate,\r\n};\r\n","import { CurriedFunction1 } from 'lodash';\r\nimport { isArray, cloneDeep, omit } from 'lodash/fp';\r\n\r\nimport { constants, getNonWritableAttributes } from '../content-types';\r\nimport { pipe as pipeAsync } from '../async';\r\n\r\nimport * as visitors from './visitors';\r\nimport * as sanitizers from './sanitizers';\r\nimport traverseEntity from '../traverse-entity';\r\n\r\nimport { traverseQueryFilters, traverseQuerySort, traverseQueryPopulate } from '../traverse';\r\nimport type { Model, Data } from '../types';\r\n\r\nexport interface Options {\r\n  auth?: unknown;\r\n}\r\n\r\nexport interface Sanitizer {\r\n  (schema: Model): CurriedFunction1<Data, Promise<Data>>;\r\n}\r\nexport interface SanitizeFunc {\r\n  (data: unknown, schema: Model, options?: Options): Promise<unknown>;\r\n}\r\n\r\nexport interface APIOptions {\r\n  sanitizers?: Sanitizers;\r\n  getModel: (model: string) => Model;\r\n}\r\n\r\nexport interface Sanitizers {\r\n  input?: Sanitizer[];\r\n  output?: Sanitizer[];\r\n}\r\n\r\nconst createAPISanitizers = (opts: APIOptions) => {\r\n  const { getModel } = opts;\r\n\r\n  const sanitizeInput: SanitizeFunc = (data: unknown, schema: Model, { auth } = {}) => {\r\n    if (!schema) {\r\n      throw new Error('Missing schema in sanitizeInput');\r\n    }\r\n    if (isArray(data)) {\r\n      return Promise.all(data.map((entry) => sanitizeInput(entry, schema, { auth })));\r\n    }\r\n\r\n    const nonWritableAttributes = getNonWritableAttributes(schema);\r\n\r\n    const transforms = [\r\n      // Remove first level ID in inputs\r\n      omit(constants.ID_ATTRIBUTE),\r\n      omit(constants.DOC_ID_ATTRIBUTE),\r\n      // Remove non-writable attributes\r\n      traverseEntity(visitors.removeRestrictedFields(nonWritableAttributes), { schema, getModel }),\r\n    ];\r\n\r\n    if (auth) {\r\n      // Remove restricted relations\r\n      transforms.push(\r\n        traverseEntity(visitors.removeRestrictedRelations(auth), { schema, getModel })\r\n      );\r\n    }\r\n\r\n    // Apply sanitizers from registry if exists\r\n    opts?.sanitizers?.input?.forEach((sanitizer: Sanitizer) => transforms.push(sanitizer(schema)));\r\n\r\n    return pipeAsync(...transforms)(data as Data);\r\n  };\r\n\r\n  const sanitizeOutput: SanitizeFunc = async (data, schema: Model, { auth } = {}) => {\r\n    if (!schema) {\r\n      throw new Error('Missing schema in sanitizeOutput');\r\n    }\r\n    if (isArray(data)) {\r\n      const res = new Array(data.length);\r\n      for (let i = 0; i < data.length; i += 1) {\r\n        res[i] = await sanitizeOutput(data[i], schema, { auth });\r\n      }\r\n      return res;\r\n    }\r\n\r\n    const transforms = [\r\n      (data: Data) => sanitizers.defaultSanitizeOutput({ schema, getModel }, data),\r\n    ];\r\n\r\n    if (auth) {\r\n      transforms.push(\r\n        traverseEntity(visitors.removeRestrictedRelations(auth), { schema, getModel })\r\n      );\r\n    }\r\n\r\n    // Apply sanitizers from registry if exists\r\n    opts?.sanitizers?.output?.forEach((sanitizer: Sanitizer) => transforms.push(sanitizer(schema)));\r\n\r\n    return pipeAsync(...transforms)(data as Data);\r\n  };\r\n\r\n  const sanitizeQuery = async (\r\n    query: Record<string, unknown>,\r\n    schema: Model,\r\n    { auth }: Options = {}\r\n  ) => {\r\n    if (!schema) {\r\n      throw new Error('Missing schema in sanitizeQuery');\r\n    }\r\n    const { filters, sort, fields, populate } = query;\r\n\r\n    const sanitizedQuery = cloneDeep(query);\r\n\r\n    if (filters) {\r\n      Object.assign(sanitizedQuery, { filters: await sanitizeFilters(filters, schema, { auth }) });\r\n    }\r\n\r\n    if (sort) {\r\n      Object.assign(sanitizedQuery, { sort: await sanitizeSort(sort, schema, { auth }) });\r\n    }\r\n\r\n    if (fields) {\r\n      Object.assign(sanitizedQuery, { fields: await sanitizeFields(fields, schema) });\r\n    }\r\n\r\n    if (populate) {\r\n      Object.assign(sanitizedQuery, { populate: await sanitizePopulate(populate, schema) });\r\n    }\r\n\r\n    return sanitizedQuery;\r\n  };\r\n\r\n  const sanitizeFilters: SanitizeFunc = (filters, schema: Model, { auth } = {}) => {\r\n    if (!schema) {\r\n      throw new Error('Missing schema in sanitizeFilters');\r\n    }\r\n    if (isArray(filters)) {\r\n      return Promise.all(filters.map((filter) => sanitizeFilters(filter, schema, { auth })));\r\n    }\r\n\r\n    const transforms = [sanitizers.defaultSanitizeFilters({ schema, getModel })];\r\n\r\n    if (auth) {\r\n      transforms.push(\r\n        traverseQueryFilters(visitors.removeRestrictedRelations(auth), { schema, getModel })\r\n      );\r\n    }\r\n\r\n    return pipeAsync(...transforms)(filters);\r\n  };\r\n\r\n  const sanitizeSort: SanitizeFunc = (sort, schema: Model, { auth } = {}) => {\r\n    if (!schema) {\r\n      throw new Error('Missing schema in sanitizeSort');\r\n    }\r\n    const transforms = [sanitizers.defaultSanitizeSort({ schema, getModel })];\r\n\r\n    if (auth) {\r\n      transforms.push(\r\n        traverseQuerySort(visitors.removeRestrictedRelations(auth), { schema, getModel })\r\n      );\r\n    }\r\n\r\n    return pipeAsync(...transforms)(sort);\r\n  };\r\n\r\n  const sanitizeFields: SanitizeFunc = (fields, schema: Model) => {\r\n    if (!schema) {\r\n      throw new Error('Missing schema in sanitizeFields');\r\n    }\r\n    const transforms = [sanitizers.defaultSanitizeFields({ schema, getModel })];\r\n\r\n    return pipeAsync(...transforms)(fields);\r\n  };\r\n\r\n  const sanitizePopulate: SanitizeFunc = (populate, schema: Model, { auth } = {}) => {\r\n    if (!schema) {\r\n      throw new Error('Missing schema in sanitizePopulate');\r\n    }\r\n    const transforms = [sanitizers.defaultSanitizePopulate({ schema, getModel })];\r\n\r\n    if (auth) {\r\n      transforms.push(\r\n        traverseQueryPopulate(visitors.removeRestrictedRelations(auth), { schema, getModel })\r\n      );\r\n    }\r\n\r\n    return pipeAsync(...transforms)(populate);\r\n  };\r\n\r\n  return {\r\n    input: sanitizeInput,\r\n    output: sanitizeOutput,\r\n    query: sanitizeQuery,\r\n    filters: sanitizeFilters,\r\n    sort: sanitizeSort,\r\n    fields: sanitizeFields,\r\n    populate: sanitizePopulate,\r\n  };\r\n};\r\n\r\nexport { createAPISanitizers, sanitizers, visitors };\r\n\r\nexport type APISanitiers = ReturnType<typeof createAPISanitizers>;\r\n","import { ValidationError } from '../errors';\r\n\r\nexport const throwInvalidKey = ({ key, path }: { key: string; path?: string | null }): never => {\r\n  const msg = path && path !== key ? `Invalid key ${key} at ${path}` : `Invalid key ${key}`;\r\n\r\n  throw new ValidationError(msg, {\r\n    key,\r\n    path,\r\n  });\r\n};\r\n\r\n// lodash/fp curry does not detect async methods, so we'll use our own that is typed correctly\r\nexport const asyncCurry = <A extends unknown[], R>(\r\n  fn: (...args: A) => Promise<R>\r\n): ((...args: Partial<A>) => any) => {\r\n  const curried = (...args: unknown[]): unknown => {\r\n    if (args.length >= fn.length) {\r\n      return fn(...(args as A));\r\n    }\r\n    return (...moreArgs: unknown[]) => curried(...args, ...moreArgs);\r\n  };\r\n\r\n  return curried;\r\n};\r\n","import { throwInvalidKey } from '../utils';\r\nimport type { Visitor } from '../../traverse/factory';\r\n\r\nconst visitor: Visitor = ({ key, attribute, path }) => {\r\n  if (attribute?.type === 'password') {\r\n    throwInvalidKey({ key, path: path.attribute });\r\n  }\r\n};\r\n\r\nexport default visitor;\r\n","import { isPrivateAttribute } from '../../content-types';\r\nimport { throwInvalidKey } from '../utils';\r\nimport type { Visitor } from '../../traverse/factory';\r\n\r\nconst visitor: Visitor = ({ schema, key, attribute, path }) => {\r\n  if (!attribute) {\r\n    return;\r\n  }\r\n\r\n  const isPrivate = attribute.private === true || isPrivateAttribute(schema, key);\r\n\r\n  if (isPrivate) {\r\n    throwInvalidKey({ key, path: path.attribute });\r\n  }\r\n};\r\n\r\nexport default visitor;\r\n","import { isArray, isObject } from 'lodash/fp';\r\nimport * as contentTypeUtils from '../../content-types';\r\nimport { throwInvalidKey } from '../utils';\r\nimport type { Visitor } from '../../traverse/factory';\r\nimport { VALID_RELATION_ORDERING_KEYS } from '../../relations';\r\n\r\nconst ACTIONS_TO_VERIFY = ['find'];\r\nconst { CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE } = contentTypeUtils.constants;\r\n\r\ntype MorphArray = Array<{ __type: string }>;\r\n\r\nexport default (auth: unknown): Visitor =>\r\n  async ({ data, key, attribute, schema, path }) => {\r\n    if (!attribute) {\r\n      return;\r\n    }\r\n\r\n    const isRelation = attribute.type === 'relation';\r\n\r\n    if (!isRelation) {\r\n      return;\r\n    }\r\n\r\n    const handleMorphRelation = async () => {\r\n      const elements: any = (data as Record<string, MorphArray>)[key];\r\n\r\n      if (\r\n        'connect' in elements ||\r\n        'set' in elements ||\r\n        'disconnect' in elements ||\r\n        'options' in elements\r\n      ) {\r\n        await handleMorphElements(elements.connect || []);\r\n        await handleMorphElements(elements.set || []);\r\n        await handleMorphElements(elements.disconnect || []);\r\n\r\n        // TODO: this should technically be in its own visitor to check morph options, but for now we'll handle it here\r\n        if ('options' in elements) {\r\n          if (elements.options === null || elements.options === undefined) {\r\n            return;\r\n          }\r\n\r\n          if (typeof elements.options !== 'object') {\r\n            throwInvalidKey({ key, path: path.attribute });\r\n          }\r\n\r\n          const optionKeys = Object.keys(elements.options);\r\n\r\n          // Validate each key based on its validator function\r\n          for (const key of optionKeys) {\r\n            if (!(key in VALID_RELATION_ORDERING_KEYS)) {\r\n              throwInvalidKey({ key, path: path.attribute });\r\n            }\r\n            if (!VALID_RELATION_ORDERING_KEYS[key](elements.options[key])) {\r\n              throwInvalidKey({ key, path: path.attribute });\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        await handleMorphElements(elements);\r\n      }\r\n    };\r\n\r\n    const handleMorphElements = async (elements: any[]) => {\r\n      if (!isArray(elements)) {\r\n        throwInvalidKey({ key, path: path.attribute });\r\n      }\r\n\r\n      for (const element of elements) {\r\n        if (!isObject(element) || !('__type' in element)) {\r\n          throwInvalidKey({ key, path: path.attribute });\r\n        }\r\n\r\n        const scopes = ACTIONS_TO_VERIFY.map((action) => `${element.__type}.${action}`);\r\n        const isAllowed = await hasAccessToSomeScopes(scopes, auth);\r\n\r\n        if (!isAllowed) {\r\n          throwInvalidKey({ key, path: path.attribute });\r\n        }\r\n      }\r\n    };\r\n\r\n    const handleRegularRelation = async () => {\r\n      const scopes = ACTIONS_TO_VERIFY.map((action) => `${attribute.target}.${action}`);\r\n\r\n      const isAllowed = await hasAccessToSomeScopes(scopes, auth);\r\n\r\n      // If the authenticated user don't have access to any of the scopes\r\n      if (!isAllowed) {\r\n        throwInvalidKey({ key, path: path.attribute });\r\n      }\r\n    };\r\n\r\n    const isCreatorRelation = [CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE].includes(key);\r\n\r\n    // Polymorphic relations\r\n    if (contentTypeUtils.isMorphToRelationalAttribute(attribute)) {\r\n      await handleMorphRelation();\r\n      return;\r\n    }\r\n\r\n    // Creator relations\r\n    if (isCreatorRelation && schema.options?.populateCreatorFields) {\r\n      // do nothing\r\n      return;\r\n    }\r\n\r\n    // Regular relations\r\n    await handleRegularRelation();\r\n  };\r\n\r\nconst hasAccessToSomeScopes = async (scopes: string[], auth: unknown) => {\r\n  for (const scope of scopes) {\r\n    try {\r\n      await strapi.auth.verify(auth, { scope });\r\n      return true;\r\n    } catch {\r\n      continue;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n","import { isMorphToRelationalAttribute } from '../../content-types';\r\nimport { throwInvalidKey } from '../utils';\r\nimport type { Visitor } from '../../traverse/factory';\r\n\r\nconst visitor: Visitor = ({ key, attribute, path }) => {\r\n  if (isMorphToRelationalAttribute(attribute)) {\r\n    throwInvalidKey({ key, path: path.attribute });\r\n  }\r\n};\r\n\r\nexport default visitor;\r\n","import { isDynamicZoneAttribute } from '../../content-types';\r\nimport { throwInvalidKey } from '../utils';\r\nimport type { Visitor } from '../../traverse/factory';\r\n\r\nconst visitor: Visitor = ({ key, attribute, path }) => {\r\n  if (isDynamicZoneAttribute(attribute)) {\r\n    throwInvalidKey({ key, path: path.attribute });\r\n  }\r\n};\r\n\r\nexport default visitor;\r\n","import { isArray, isNil, isString, toPath } from 'lodash/fp';\r\nimport type { Visitor } from '../../traverse/factory';\r\nimport { throwInvalidKey } from '../utils';\r\n\r\nexport default (allowedFields: string[] | null = null): Visitor =>\r\n  ({ key, path: { attribute: path } }) => {\r\n    // All fields are allowed\r\n    if (allowedFields === null) {\r\n      return;\r\n    }\r\n\r\n    // Throw on invalid formats\r\n    if (!(isArray(allowedFields) && allowedFields.every(isString))) {\r\n      throw new TypeError(\r\n        `Expected array of strings for allowedFields but got \"${typeof allowedFields}\"`\r\n      );\r\n    }\r\n\r\n    if (isNil(path)) {\r\n      return;\r\n    }\r\n\r\n    const containedPaths = getContainedPaths(path);\r\n\r\n    /**\r\n     * Tells if the current path should be kept or not based\r\n     * on the success of the check functions for any of the allowed paths.\r\n     *\r\n     * The check functions are defined as follow:\r\n     *\r\n     * `containedPaths.includes(p)`\r\n     * @example\r\n     * ```js\r\n     * const path = 'foo.bar.field';\r\n     * const p = 'foo.bar';\r\n     * // it should match\r\n     *\r\n     * const path = 'foo.bar.field';\r\n     * const p = 'bar.foo';\r\n     * // it shouldn't match\r\n     *\r\n     * const path = 'foo.bar';\r\n     * const p = 'foo.bar.field';\r\n     * // it should match but isn't handled by this check\r\n     * ```\r\n     *\r\n     * `p.startsWith(`${path}.`)`\r\n     * @example\r\n     * ```js\r\n     * const path = 'foo.bar';\r\n     * const p = 'foo.bar.field';\r\n     * // it should match\r\n     *\r\n     * const path = 'foo.bar.field';\r\n     * const p = 'bar.foo';\r\n     * // it shouldn't match\r\n     *\r\n     * const path = 'foo.bar.field';\r\n     * const p = 'foo.bar';\r\n     * // it should match but isn't handled by this check\r\n     * ```\r\n     */\r\n    const isPathAllowed = allowedFields.some(\r\n      (p) => containedPaths.includes(p) || p.startsWith(`${path}.`)\r\n    );\r\n\r\n    if (isPathAllowed) {\r\n      return;\r\n    }\r\n\r\n    // throw otherwise\r\n    throwInvalidKey({ key, path });\r\n  };\r\n\r\n/**\r\n * Retrieve the list of allowed paths based on the given path\r\n *\r\n * @example\r\n * ```js\r\n * const containedPaths = getContainedPaths('foo');\r\n * // ['foo']\r\n *\r\n *  * const containedPaths = getContainedPaths('foo.bar');\r\n * // ['foo', 'foo.bar']\r\n *\r\n *  * const containedPaths = getContainedPaths('foo.bar.field');\r\n * // ['foo', 'foo.bar', 'foo.bar.field']\r\n * ```\r\n */\r\nconst getContainedPaths = (path: string) => {\r\n  const parts = toPath(path);\r\n\r\n  return parts.reduce((acc, value, index, list) => {\r\n    return [...acc, list.slice(0, index + 1).join('.')];\r\n  }, [] as string[]);\r\n};\r\n","import { isArray, isString } from 'lodash/fp';\r\nimport type { Visitor } from '../../traverse/factory';\r\nimport { throwInvalidKey } from '../utils';\r\n\r\nexport default (restrictedFields: string[] | null = null): Visitor =>\r\n  ({ key, path: { attribute: path } }) => {\r\n    // all fields\r\n    if (restrictedFields === null) {\r\n      throwInvalidKey({ key, path });\r\n    }\r\n\r\n    // Throw on invalid formats\r\n    if (!(isArray(restrictedFields) && restrictedFields.every(isString))) {\r\n      throw new TypeError(\r\n        `Expected array of strings for restrictedFields but got \"${typeof restrictedFields}\"`\r\n      );\r\n    }\r\n\r\n    // if an exact match was found\r\n    if (restrictedFields.includes(path as string)) {\r\n      throwInvalidKey({ key, path });\r\n    }\r\n\r\n    // nested matches\r\n    const isRestrictedNested = restrictedFields.some((allowedPath) =>\r\n      path?.toString().startsWith(`${allowedPath}.`)\r\n    );\r\n    if (isRestrictedNested) {\r\n      throwInvalidKey({ key, path });\r\n    }\r\n  };\r\n","import {\r\n  isDynamicZoneAttribute,\r\n  isMorphToRelationalAttribute,\r\n  isRelationalAttribute,\r\n  constants,\r\n  isComponentSchema,\r\n  isMediaAttribute,\r\n  hasRelationReordering,\r\n} from '../../content-types';\r\nimport type { Visitor } from '../../traverse-entity';\r\nimport { throwInvalidKey } from '../utils';\r\n\r\n// TODO these should all be centralized somewhere instead of maintaining a list\r\nconst ID_FIELDS = [constants.DOC_ID_ATTRIBUTE, constants.DOC_ID_ATTRIBUTE];\r\nconst ALLOWED_ROOT_LEVEL_FIELDS = [...ID_FIELDS];\r\nconst MORPH_TO_ALLOWED_FIELDS = ['__type'];\r\nconst DYNAMIC_ZONE_ALLOWED_FIELDS = ['__component'];\r\nconst RELATION_REORDERING_FIELDS = ['connect', 'disconnect', 'set', 'options'];\r\n\r\nconst throwUnrecognizedFields: Visitor = ({ key, attribute, path, schema, parent }) => {\r\n  // We only look at properties that are not attributes\r\n  if (attribute) {\r\n    return;\r\n  }\r\n\r\n  // At root level (path.attribute === null), only accept allowed fields\r\n  if (path.attribute === null) {\r\n    if (ALLOWED_ROOT_LEVEL_FIELDS.includes(key)) {\r\n      return;\r\n    }\r\n\r\n    return throwInvalidKey({ key, path: attribute });\r\n  }\r\n\r\n  // allow special morphTo keys\r\n  if (isMorphToRelationalAttribute(parent?.attribute) && MORPH_TO_ALLOWED_FIELDS.includes(key)) {\r\n    return;\r\n  }\r\n\r\n  // allow special dz keys\r\n  if (\r\n    isComponentSchema(schema) &&\r\n    isDynamicZoneAttribute(parent?.attribute) &&\r\n    DYNAMIC_ZONE_ALLOWED_FIELDS.includes(key)\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  // allow special relation reordering keys in manyToX and XtoMany relations\r\n  if (hasRelationReordering(parent?.attribute) && RELATION_REORDERING_FIELDS.includes(key)) {\r\n    return;\r\n  }\r\n\r\n  // allow id fields where it is needed for setting a relational id rather than trying to create with a given id\r\n  const canUseID = isRelationalAttribute(parent?.attribute) || isMediaAttribute(parent?.attribute);\r\n  if (canUseID && !ID_FIELDS.includes(key)) {\r\n    return;\r\n  }\r\n\r\n  // if we couldn't find any reason for it to be here, throw\r\n  throwInvalidKey({ key, path: attribute });\r\n};\r\n\r\nexport default throwUnrecognizedFields;\r\n","import { isEmpty, isNil, isObject } from 'lodash/fp';\r\n\r\nimport { pipe as pipeAsync } from '../async';\r\nimport { isScalarAttribute, constants } from '../content-types';\r\nimport {\r\n  traverseQueryFilters,\r\n  traverseQuerySort,\r\n  traverseQueryFields,\r\n  traverseQueryPopulate,\r\n} from '../traverse';\r\nimport { throwPassword, throwPrivate, throwDynamicZones, throwMorphToRelations } from './visitors';\r\nimport { isOperator } from '../operators';\r\nimport { asyncCurry, throwInvalidKey } from './utils';\r\nimport type { Model } from '../types';\r\nimport parseType from '../parse-type';\r\nimport type { Parent, Path } from '../traverse/factory';\r\n\r\nconst { ID_ATTRIBUTE, DOC_ID_ATTRIBUTE } = constants;\r\n\r\ninterface Context {\r\n  schema: Model;\r\n  getModel: (model: string) => Model;\r\n}\r\n\r\ninterface PopulateContext extends Context {\r\n  path?: Path;\r\n  parent?: Parent;\r\n}\r\n\r\ntype AnyFunc = (...args: any[]) => any;\r\n\r\nexport const FILTER_TRAVERSALS = [\r\n  'nonAttributesOperators',\r\n  'dynamicZones',\r\n  'morphRelations',\r\n  'passwords',\r\n  'private',\r\n];\r\n\r\nexport const validateFilters = asyncCurry(\r\n  async (ctx: Context, filters: unknown, include: (typeof FILTER_TRAVERSALS)[number][]) => {\r\n    // TODO: schema checks should check that it is a valid schema with yup\r\n    if (!ctx.schema) {\r\n      throw new Error('Missing schema in defaultValidateFilters');\r\n    }\r\n\r\n    // Build the list of functions conditionally\r\n    const functionsToApply: Array<AnyFunc> = [];\r\n\r\n    // keys that are not attributes or valid operators\r\n    if (include.includes('nonAttributesOperators')) {\r\n      functionsToApply.push(\r\n        traverseQueryFilters(({ key, attribute, path }) => {\r\n          // ID is not an attribute per se, so we need to make\r\n          // an extra check to ensure we're not removing it\r\n          if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\r\n            return;\r\n          }\r\n\r\n          const isAttribute = !!attribute;\r\n\r\n          if (!isAttribute && !isOperator(key)) {\r\n            throwInvalidKey({ key, path: path.attribute });\r\n          }\r\n        }, ctx)\r\n      );\r\n    }\r\n\r\n    if (include.includes('dynamicZones')) {\r\n      functionsToApply.push(traverseQueryFilters(throwDynamicZones, ctx));\r\n    }\r\n\r\n    if (include.includes('morphRelations')) {\r\n      functionsToApply.push(traverseQueryFilters(throwMorphToRelations, ctx));\r\n    }\r\n\r\n    if (include.includes('passwords')) {\r\n      functionsToApply.push(traverseQueryFilters(throwPassword, ctx));\r\n    }\r\n\r\n    if (include.includes('private')) {\r\n      functionsToApply.push(traverseQueryFilters(throwPrivate, ctx));\r\n    }\r\n\r\n    // Return directly if no validation functions are provided\r\n    if (functionsToApply.length === 0) {\r\n      return filters;\r\n    }\r\n\r\n    return pipeAsync(...functionsToApply)(filters);\r\n  }\r\n);\r\n\r\nexport const defaultValidateFilters = asyncCurry(async (ctx: Context, filters: unknown) => {\r\n  return validateFilters(ctx, filters, FILTER_TRAVERSALS);\r\n});\r\n\r\nexport const SORT_TRAVERSALS = [\r\n  'nonAttributesOperators',\r\n  'dynamicZones',\r\n  'morphRelations',\r\n  'passwords',\r\n  'private',\r\n  'nonScalarEmptyKeys',\r\n];\r\n\r\nexport const validateSort = asyncCurry(\r\n  async (ctx: Context, sort: unknown, include: (typeof SORT_TRAVERSALS)[number][]) => {\r\n    if (!ctx.schema) {\r\n      throw new Error('Missing schema in defaultValidateSort');\r\n    }\r\n\r\n    // Build the list of functions conditionally based on the include array\r\n    const functionsToApply: Array<AnyFunc> = [];\r\n\r\n    // Validate non attribute keys\r\n    if (include.includes('nonAttributesOperators')) {\r\n      functionsToApply.push(\r\n        traverseQuerySort(({ key, attribute, path }) => {\r\n          // ID is not an attribute per se, so we need to make\r\n          // an extra check to ensure we're not removing it\r\n          if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\r\n            return;\r\n          }\r\n\r\n          if (!attribute) {\r\n            throwInvalidKey({ key, path: path.attribute });\r\n          }\r\n        }, ctx)\r\n      );\r\n    }\r\n\r\n    // Validate dynamic zones from sort\r\n    if (include.includes('dynamicZones')) {\r\n      functionsToApply.push(traverseQuerySort(throwDynamicZones, ctx));\r\n    }\r\n\r\n    // Validate morphTo relations from sort\r\n    if (include.includes('morphRelations')) {\r\n      functionsToApply.push(traverseQuerySort(throwMorphToRelations, ctx));\r\n    }\r\n\r\n    // Validate passwords from sort\r\n    if (include.includes('passwords')) {\r\n      functionsToApply.push(traverseQuerySort(throwPassword, ctx));\r\n    }\r\n\r\n    // Validate private from sort\r\n    if (include.includes('private')) {\r\n      functionsToApply.push(traverseQuerySort(throwPrivate, ctx));\r\n    }\r\n\r\n    // Validate non-scalar empty keys\r\n    if (include.includes('nonScalarEmptyKeys')) {\r\n      functionsToApply.push(\r\n        traverseQuerySort(({ key, attribute, value, path }) => {\r\n          // ID is not an attribute per se, so we need to make\r\n          // an extra check to ensure we're not removing it\r\n          if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\r\n            return;\r\n          }\r\n\r\n          if (!isScalarAttribute(attribute) && isEmpty(value)) {\r\n            throwInvalidKey({ key, path: path.attribute });\r\n          }\r\n        }, ctx)\r\n      );\r\n    }\r\n\r\n    // Return directly if no validation functions are provided\r\n    if (functionsToApply.length === 0) {\r\n      return sort;\r\n    }\r\n\r\n    return pipeAsync(...functionsToApply)(sort);\r\n  }\r\n);\r\n\r\nexport const defaultValidateSort = asyncCurry(async (ctx: Context, sort: unknown) => {\r\n  return validateSort(ctx, sort, SORT_TRAVERSALS);\r\n});\r\n\r\nexport const FIELDS_TRAVERSALS = ['scalarAttributes', 'privateFields', 'passwordFields'];\r\n\r\nexport const validateFields = asyncCurry(\r\n  async (ctx: Context, fields: unknown, include: (typeof FIELDS_TRAVERSALS)[number][]) => {\r\n    if (!ctx.schema) {\r\n      throw new Error('Missing schema in defaultValidateFields');\r\n    }\r\n    // Build the list of functions conditionally based on the include array\r\n    const functionsToApply: Array<AnyFunc> = [];\r\n\r\n    // Only allow scalar attributes\r\n    if (include.includes('scalarAttributes')) {\r\n      functionsToApply.push(\r\n        traverseQueryFields(({ key, attribute, path }) => {\r\n          // ID is not an attribute per se, so we need to make\r\n          // an extra check to ensure we're not throwing because of it\r\n          if ([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE].includes(key)) {\r\n            return;\r\n          }\r\n\r\n          if (isNil(attribute) || !isScalarAttribute(attribute)) {\r\n            throwInvalidKey({ key, path: path.attribute });\r\n          }\r\n        }, ctx)\r\n      );\r\n    }\r\n\r\n    // Private fields\r\n    if (include.includes('privateFields')) {\r\n      functionsToApply.push(traverseQueryFields(throwPrivate, ctx));\r\n    }\r\n\r\n    // Password fields\r\n    if (include.includes('passwordFields')) {\r\n      functionsToApply.push(traverseQueryFields(throwPassword, ctx));\r\n    }\r\n\r\n    // Return directly if no validation functions are provided\r\n    if (functionsToApply.length === 0) {\r\n      return fields;\r\n    }\r\n\r\n    return pipeAsync(...functionsToApply)(fields);\r\n  }\r\n);\r\n\r\nexport const defaultValidateFields = asyncCurry(async (ctx: Context, fields: unknown) => {\r\n  return validateFields(ctx, fields, FIELDS_TRAVERSALS);\r\n});\r\n\r\nexport const POPULATE_TRAVERSALS = ['nonAttributesOperators', 'private'];\r\n\r\nexport const validatePopulate = asyncCurry(\r\n  async (\r\n    ctx: PopulateContext,\r\n    populate: unknown,\r\n    includes: {\r\n      fields?: (typeof FIELDS_TRAVERSALS)[number][];\r\n      sort?: (typeof SORT_TRAVERSALS)[number][];\r\n      filters?: (typeof FILTER_TRAVERSALS)[number][];\r\n      populate?: (typeof POPULATE_TRAVERSALS)[number][];\r\n    }\r\n  ) => {\r\n    if (!ctx.schema) {\r\n      throw new Error('Missing schema in defaultValidatePopulate');\r\n    }\r\n    // Build the list of functions conditionally based on the include array\r\n    const functionsToApply: Array<AnyFunc> = [];\r\n\r\n    // Always include the main traversal function\r\n    functionsToApply.push(\r\n      traverseQueryPopulate(\r\n        async ({ key, path, value, schema, attribute, getModel, parent }, { set }) => {\r\n          /**\r\n           * NOTE: The parent check is done to support \"filters\" (and the rest of keys) as valid attribute names.\r\n           *\r\n           * The parent will not be an attribute when its a \"populate\" / \"filters\" / \"sort\" ... key.\r\n           * Only in those scenarios the node will be an attribute.\r\n           */\r\n          if (!parent?.attribute && attribute) {\r\n            const isPopulatableAttribute = [\r\n              'relation',\r\n              'dynamiczone',\r\n              'component',\r\n              'media',\r\n            ].includes(attribute.type);\r\n\r\n            // Throw on non-populate attributes\r\n            if (!isPopulatableAttribute) {\r\n              throwInvalidKey({ key, path: path.raw });\r\n            }\r\n\r\n            // Valid populatable attribute, so return\r\n            return;\r\n          }\r\n\r\n          // If we're looking at a populate fragment, ensure its target is valid\r\n          if (key === 'on') {\r\n            // Populate fragment should always be an object\r\n            if (!isObject(value)) {\r\n              return throwInvalidKey({ key, path: path.raw });\r\n            }\r\n\r\n            const targets = Object.keys(value);\r\n\r\n            for (const target of targets) {\r\n              const model = getModel(target);\r\n\r\n              // If a target is invalid (no matching model), then raise an error\r\n              if (!model) {\r\n                throwInvalidKey({ key: target, path: `${path.raw}.${target}` });\r\n              }\r\n            }\r\n\r\n            // If the fragment's target is fine, then let it pass\r\n            return;\r\n          }\r\n\r\n          // Ignore plain wildcards\r\n          if (key === '' && value === '*') {\r\n            return;\r\n          }\r\n\r\n          // Ensure count is a boolean\r\n          if (key === 'count') {\r\n            try {\r\n              parseType({ type: 'boolean', value });\r\n              return;\r\n            } catch {\r\n              throwInvalidKey({ key, path: path.attribute });\r\n            }\r\n          }\r\n\r\n          // Allowed boolean-like keywords should be ignored\r\n          try {\r\n            parseType({ type: 'boolean', value: key });\r\n            // Key is an allowed boolean-like keyword, skipping validation...\r\n            return;\r\n          } catch {\r\n            // Continue, because it's not a boolean-like\r\n          }\r\n\r\n          // Handle nested `sort` validation with custom or default traversals\r\n          if (key === 'sort') {\r\n            set(\r\n              key,\r\n              await validateSort(\r\n                {\r\n                  schema,\r\n                  getModel,\r\n                },\r\n                value, // pass the sort value\r\n                includes?.sort || SORT_TRAVERSALS\r\n              )\r\n            );\r\n            return;\r\n          }\r\n\r\n          // Handle nested `filters` validation with custom or default traversals\r\n          if (key === 'filters') {\r\n            set(\r\n              key,\r\n              await validateFilters(\r\n                {\r\n                  schema,\r\n                  getModel,\r\n                },\r\n                value, // pass the filters value\r\n                includes?.filters || FILTER_TRAVERSALS\r\n              )\r\n            );\r\n            return;\r\n          }\r\n\r\n          // Handle nested `fields` validation with custom or default traversals\r\n          if (key === 'fields') {\r\n            set(\r\n              key,\r\n              await validateFields(\r\n                {\r\n                  schema,\r\n                  getModel,\r\n                },\r\n                value, // pass the fields value\r\n                includes?.fields || FIELDS_TRAVERSALS\r\n              )\r\n            );\r\n            return;\r\n          }\r\n\r\n          // Handle recursive nested `populate` validation with the same include object\r\n          if (key === 'populate') {\r\n            set(\r\n              key,\r\n              await validatePopulate(\r\n                {\r\n                  schema,\r\n                  getModel,\r\n                  parent: { key, path, schema, attribute },\r\n                  path,\r\n                },\r\n                value, // pass the nested populate value\r\n                includes // pass down the same includes object\r\n              )\r\n            );\r\n            return;\r\n          }\r\n\r\n          // Throw an error if non-attribute operators are included in the populate array\r\n          if (includes?.populate?.includes('nonAttributesOperators')) {\r\n            throwInvalidKey({ key, path: path.attribute });\r\n          }\r\n        },\r\n        ctx\r\n      )\r\n    );\r\n\r\n    // Conditionally traverse for private fields only if 'private' is included\r\n    if (includes?.populate?.includes('private')) {\r\n      functionsToApply.push(traverseQueryPopulate(throwPrivate, ctx));\r\n    }\r\n\r\n    // Return directly if no validation functions are provided\r\n    if (functionsToApply.length === 0) {\r\n      return populate;\r\n    }\r\n\r\n    return pipeAsync(...functionsToApply)(populate);\r\n  }\r\n);\r\n\r\nexport const defaultValidatePopulate = asyncCurry(async (ctx: Context, populate: unknown) => {\r\n  if (!ctx.schema) {\r\n    throw new Error('Missing schema in defaultValidatePopulate');\r\n  }\r\n\r\n  // Call validatePopulate and include all validations by passing in full traversal arrays\r\n  return validatePopulate(ctx, populate, {\r\n    filters: FILTER_TRAVERSALS,\r\n    sort: SORT_TRAVERSALS,\r\n    fields: FIELDS_TRAVERSALS,\r\n    populate: POPULATE_TRAVERSALS,\r\n  });\r\n});\r\n","import { CurriedFunction1 } from 'lodash';\r\nimport { isArray, isObject } from 'lodash/fp';\r\n\r\nimport { getNonWritableAttributes, constants } from '../content-types';\r\nimport { pipe as pipeAsync } from '../async';\r\nimport { throwInvalidKey } from './utils';\r\n\r\nimport * as visitors from './visitors';\r\nimport * as validators from './validators';\r\nimport traverseEntity from '../traverse-entity';\r\n\r\nimport { traverseQueryFilters, traverseQuerySort, traverseQueryPopulate } from '../traverse';\r\n\r\nimport { Model, Data } from '../types';\r\nimport { ValidationError } from '../errors';\r\n\r\nconst { ID_ATTRIBUTE, DOC_ID_ATTRIBUTE } = constants;\r\n\r\nexport interface Options {\r\n  auth?: unknown;\r\n}\r\n\r\nexport interface Validator {\r\n  (schema: Model): CurriedFunction1<Data, Promise<Data>>;\r\n}\r\nexport interface ValidateFunc {\r\n  (data: unknown, schema: Model, options?: Options): Promise<void>;\r\n}\r\n\r\ninterface APIOptions {\r\n  validators?: Validators;\r\n  getModel: (model: string) => Model;\r\n}\r\n\r\nexport interface Validators {\r\n  input?: Validator[];\r\n}\r\n\r\nconst createAPIValidators = (opts: APIOptions) => {\r\n  const { getModel } = opts || {};\r\n\r\n  const validateInput: ValidateFunc = async (data: unknown, schema: Model, { auth } = {}) => {\r\n    if (!schema) {\r\n      throw new Error('Missing schema in validateInput');\r\n    }\r\n\r\n    if (isArray(data)) {\r\n      await Promise.all(data.map((entry) => validateInput(entry, schema, { auth })));\r\n      return;\r\n    }\r\n\r\n    const nonWritableAttributes = getNonWritableAttributes(schema);\r\n\r\n    const transforms = [\r\n      (data: unknown) => {\r\n        if (isObject(data)) {\r\n          if (ID_ATTRIBUTE in data) {\r\n            throwInvalidKey({ key: ID_ATTRIBUTE });\r\n          }\r\n\r\n          if (DOC_ID_ATTRIBUTE in data) {\r\n            throwInvalidKey({ key: DOC_ID_ATTRIBUTE });\r\n          }\r\n        }\r\n        return data;\r\n      },\r\n      // non-writable attributes\r\n      traverseEntity(visitors.throwRestrictedFields(nonWritableAttributes), { schema, getModel }),\r\n      // unrecognized attributes\r\n      traverseEntity(visitors.throwUnrecognizedFields, { schema, getModel }),\r\n    ];\r\n\r\n    if (auth) {\r\n      // restricted relations\r\n      transforms.push(\r\n        traverseEntity(visitors.throwRestrictedRelations(auth), {\r\n          schema,\r\n          getModel,\r\n        })\r\n      );\r\n    }\r\n\r\n    // Apply validators from registry if exists\r\n    opts?.validators?.input?.forEach((validator: Validator) => transforms.push(validator(schema)));\r\n\r\n    try {\r\n      await pipeAsync(...transforms)(data as Data);\r\n    } catch (e) {\r\n      if (e instanceof ValidationError) {\r\n        e.details.source = 'body';\r\n      }\r\n      throw e;\r\n    }\r\n  };\r\n\r\n  const validateQuery = async (\r\n    query: Record<string, unknown>,\r\n    schema: Model,\r\n    { auth }: Options = {}\r\n  ) => {\r\n    if (!schema) {\r\n      throw new Error('Missing schema in validateQuery');\r\n    }\r\n    const { filters, sort, fields, populate } = query;\r\n\r\n    if (filters) {\r\n      await validateFilters(filters, schema, { auth });\r\n    }\r\n\r\n    if (sort) {\r\n      await validateSort(sort, schema, { auth });\r\n    }\r\n\r\n    if (fields) {\r\n      await validateFields(fields, schema);\r\n    }\r\n\r\n    // a wildcard is always valid; its conversion will be handled by the entity service and can be optimized with sanitizer\r\n    if (populate && populate !== '*') {\r\n      await validatePopulate(populate, schema);\r\n    }\r\n  };\r\n\r\n  const validateFilters: ValidateFunc = async (filters, schema: Model, { auth } = {}) => {\r\n    if (!schema) {\r\n      throw new Error('Missing schema in validateFilters');\r\n    }\r\n    if (isArray(filters)) {\r\n      await Promise.all(filters.map((filter) => validateFilters(filter, schema, { auth })));\r\n      return;\r\n    }\r\n\r\n    const transforms = [validators.defaultValidateFilters({ schema, getModel })];\r\n\r\n    if (auth) {\r\n      transforms.push(\r\n        traverseQueryFilters(visitors.throwRestrictedRelations(auth), {\r\n          schema,\r\n          getModel,\r\n        })\r\n      );\r\n    }\r\n\r\n    try {\r\n      await pipeAsync(...transforms)(filters);\r\n    } catch (e) {\r\n      if (e instanceof ValidationError) {\r\n        e.details.source = 'query';\r\n        e.details.param = 'filters';\r\n      }\r\n      throw e;\r\n    }\r\n  };\r\n\r\n  const validateSort: ValidateFunc = async (sort, schema: Model, { auth } = {}) => {\r\n    if (!schema) {\r\n      throw new Error('Missing schema in validateSort');\r\n    }\r\n    const transforms = [validators.defaultValidateSort({ schema, getModel })];\r\n\r\n    if (auth) {\r\n      transforms.push(\r\n        traverseQuerySort(visitors.throwRestrictedRelations(auth), {\r\n          schema,\r\n          getModel,\r\n        })\r\n      );\r\n    }\r\n\r\n    try {\r\n      await pipeAsync(...transforms)(sort);\r\n    } catch (e) {\r\n      if (e instanceof ValidationError) {\r\n        e.details.source = 'query';\r\n        e.details.param = 'sort';\r\n      }\r\n      throw e;\r\n    }\r\n  };\r\n\r\n  const validateFields: ValidateFunc = async (fields, schema: Model) => {\r\n    if (!schema) {\r\n      throw new Error('Missing schema in validateFields');\r\n    }\r\n    const transforms = [validators.defaultValidateFields({ schema, getModel })];\r\n\r\n    try {\r\n      await pipeAsync(...transforms)(fields);\r\n    } catch (e) {\r\n      if (e instanceof ValidationError) {\r\n        e.details.source = 'query';\r\n        e.details.param = 'fields';\r\n      }\r\n      throw e;\r\n    }\r\n  };\r\n\r\n  const validatePopulate: ValidateFunc = async (populate, schema: Model, { auth } = {}) => {\r\n    if (!schema) {\r\n      throw new Error('Missing schema in sanitizePopulate');\r\n    }\r\n    const transforms = [validators.defaultValidatePopulate({ schema, getModel })];\r\n\r\n    if (auth) {\r\n      transforms.push(\r\n        traverseQueryPopulate(visitors.throwRestrictedRelations(auth), {\r\n          schema,\r\n          getModel,\r\n        })\r\n      );\r\n    }\r\n\r\n    try {\r\n      await pipeAsync(...transforms)(populate);\r\n    } catch (e) {\r\n      if (e instanceof ValidationError) {\r\n        e.details.source = 'query';\r\n        e.details.param = 'populate';\r\n      }\r\n      throw e;\r\n    }\r\n  };\r\n\r\n  return {\r\n    input: validateInput,\r\n    query: validateQuery,\r\n    filters: validateFilters,\r\n    sort: validateSort,\r\n    fields: validateFields,\r\n    populate: validatePopulate,\r\n  };\r\n};\r\n\r\nexport { createAPIValidators, validators, visitors };\r\n\r\nexport type APIValidators = ReturnType<typeof createAPIValidators>;\r\n","import { merge, pipe, omit, isNil } from 'lodash/fp';\r\nimport { PaginationError } from './errors';\r\n\r\ninterface PaginationArgs {\r\n  page: number;\r\n  pageSize: number;\r\n  start: number;\r\n  limit: number;\r\n}\r\n\r\nexport interface Pagination {\r\n  start: number;\r\n  limit: number;\r\n}\r\n\r\nexport interface PagePatinationInformation {\r\n  page: number;\r\n  pageSize: number;\r\n  pageCount: number;\r\n  total: number;\r\n}\r\n\r\nexport interface OffsetPaginationInformation {\r\n  start: number;\r\n  limit: number;\r\n  total: number;\r\n}\r\n\r\nconst STRAPI_DEFAULTS = {\r\n  offset: {\r\n    start: 0,\r\n    limit: 10,\r\n  },\r\n  page: {\r\n    page: 1,\r\n    pageSize: 10,\r\n  },\r\n};\r\n\r\nconst paginationAttributes = ['start', 'limit', 'page', 'pageSize'];\r\n\r\nconst withMaxLimit = (limit: number, maxLimit = -1) => {\r\n  if (maxLimit === -1 || limit < maxLimit) {\r\n    return limit;\r\n  }\r\n\r\n  return maxLimit;\r\n};\r\n\r\n// Ensure minimum page & pageSize values (page >= 1, pageSize >= 0, start >= 0, limit >= 0)\r\nconst ensureMinValues = ({ start, limit }: Pagination) => ({\r\n  start: Math.max(start, 0),\r\n  limit: limit === -1 ? limit : Math.max(limit, 1),\r\n});\r\n\r\nconst ensureMaxValues =\r\n  (maxLimit = -1) =>\r\n  ({ start, limit }: { start: number; limit: number }) => ({\r\n    start,\r\n    limit: withMaxLimit(limit, maxLimit),\r\n  });\r\n\r\n// Apply maxLimit as the limit when limit is -1\r\nconst withNoLimit = (pagination: Pagination, maxLimit = -1) => ({\r\n  ...pagination,\r\n  limit: pagination.limit === -1 ? maxLimit : pagination.limit,\r\n});\r\n\r\nconst withDefaultPagination = <T extends Partial<PaginationArgs>>(\r\n  args: T,\r\n  { defaults = {}, maxLimit = -1 } = {}\r\n) => {\r\n  const defaultValues = merge(STRAPI_DEFAULTS, defaults);\r\n\r\n  const usePagePagination = !isNil(args.page) || !isNil(args.pageSize);\r\n  const useOffsetPagination = !isNil(args.start) || !isNil(args.limit);\r\n\r\n  const ensureValidValues = pipe(ensureMinValues, ensureMaxValues(maxLimit));\r\n\r\n  // If there is no pagination attribute, don't modify the payload\r\n  if (!usePagePagination && !useOffsetPagination) {\r\n    return merge(args, ensureValidValues(defaultValues.offset));\r\n  }\r\n\r\n  // If there is page & offset pagination attributes, throw an error\r\n  if (usePagePagination && useOffsetPagination) {\r\n    throw new PaginationError('Cannot use both page & offset pagination in the same query');\r\n  }\r\n\r\n  const pagination: Pagination = {\r\n    start: 0,\r\n    limit: 0,\r\n  };\r\n\r\n  // Start / Limit\r\n  if (useOffsetPagination) {\r\n    const { start, limit } = merge(defaultValues.offset, args);\r\n\r\n    Object.assign(pagination, { start, limit });\r\n  }\r\n\r\n  // Page / PageSize\r\n  if (usePagePagination) {\r\n    const { page, pageSize } = merge(defaultValues.page, {\r\n      ...args,\r\n      pageSize: Math.max(1, args.pageSize ?? 0),\r\n    });\r\n\r\n    Object.assign(pagination, {\r\n      start: (page - 1) * pageSize,\r\n      limit: pageSize,\r\n    });\r\n  }\r\n\r\n  // Handle -1 limit\r\n  Object.assign(pagination, withNoLimit(pagination, maxLimit));\r\n\r\n  const replacePaginationAttributes = pipe(\r\n    // Remove pagination attributes\r\n    omit(paginationAttributes),\r\n    // Merge the object with the new pagination + ensure minimum & maximum values\r\n    merge(ensureValidValues(pagination))\r\n  );\r\n\r\n  return replacePaginationAttributes(args);\r\n};\r\n\r\n/**\r\n * Transform pagination information into a paginated response:\r\n * {\r\n *    page: number,\r\n *    pageSize: number,\r\n *    pageCount: number,\r\n *    total: number\r\n * }\r\n */\r\nconst transformPagedPaginationInfo = (\r\n  paginationInfo: Partial<PaginationArgs>,\r\n  total: number\r\n): PagePatinationInformation => {\r\n  if (!isNil(paginationInfo.page)) {\r\n    const page = paginationInfo.page;\r\n    const pageSize = paginationInfo.pageSize ?? total;\r\n\r\n    return {\r\n      page,\r\n      pageSize,\r\n      pageCount: pageSize > 0 ? Math.ceil(total / pageSize) : 0,\r\n      total,\r\n    };\r\n  }\r\n\r\n  if (!isNil(paginationInfo.start)) {\r\n    const start = paginationInfo.start;\r\n    const limit = paginationInfo.limit ?? total;\r\n\r\n    // Start limit to page page size\r\n    return {\r\n      page: Math.floor(start / limit) + 1,\r\n      pageSize: limit,\r\n      pageCount: limit > 0 ? Math.ceil(total / limit) : 0,\r\n      total,\r\n    };\r\n  }\r\n\r\n  // Default pagination\r\n  return {\r\n    ...paginationInfo,\r\n    page: 1,\r\n    pageSize: 10,\r\n    pageCount: 1,\r\n    total,\r\n  };\r\n};\r\n\r\n/**\r\n * Transform pagination information into a offset response:\r\n * {\r\n *    start: number,\r\n *    limit: number,\r\n *    total: number\r\n * }\r\n */\r\nconst transformOffsetPaginationInfo = (\r\n  paginationInfo: Partial<PaginationArgs>,\r\n  total: number\r\n): OffsetPaginationInformation => {\r\n  if (!isNil(paginationInfo.page)) {\r\n    const limit = paginationInfo.pageSize ?? total;\r\n    const start = (paginationInfo.page - 1) * limit;\r\n\r\n    return { start, limit, total };\r\n  }\r\n\r\n  if (!isNil(paginationInfo.start)) {\r\n    const start = paginationInfo.start;\r\n    const limit = paginationInfo.limit ?? total;\r\n\r\n    // Start limit to page page size\r\n    return { start, limit, total };\r\n  }\r\n\r\n  // Default pagination\r\n  return {\r\n    ...paginationInfo,\r\n    start: 0,\r\n    limit: 10,\r\n    total,\r\n  };\r\n};\r\n\r\nexport { withDefaultPagination, transformPagedPaginationInfo, transformOffsetPaginationInfo };\r\n","import execa from 'execa';\r\nimport preferredPM from 'preferred-pm';\r\n\r\nimport type { Options as ProcessOptions } from 'execa';\r\n\r\nconst SUPPORTED_PACKAGE_MANAGERS = ['npm', 'yarn'];\r\nconst DEFAULT_PACKAGE_MANAGER = 'npm' as const;\r\n\r\ntype SupportedPackageManagerName = 'npm' | 'yarn';\r\n\r\nexport const getPreferred = async (pkgPath: string): Promise<SupportedPackageManagerName> => {\r\n  const pm = await preferredPM(pkgPath);\r\n\r\n  const hasPackageManager = pm !== undefined;\r\n  if (!hasPackageManager) {\r\n    throw new Error(`Couldn't find a package manager in your project.`);\r\n  }\r\n\r\n  const isPackageManagerSupported = SUPPORTED_PACKAGE_MANAGERS.includes(pm.name);\r\n  if (!isPackageManagerSupported) {\r\n    process.emitWarning(\r\n      `We detected your package manager (${pm.name} v${pm.version}), but it's not officially supported by Strapi yet. Defaulting to npm instead.`\r\n    );\r\n\r\n    return DEFAULT_PACKAGE_MANAGER;\r\n  }\r\n\r\n  return pm.name as SupportedPackageManagerName;\r\n};\r\n\r\nexport const installDependencies = (\r\n  path: string,\r\n  packageManager: SupportedPackageManagerName,\r\n  options: ProcessOptions<string> = {}\r\n) => {\r\n  return execa(packageManager, ['install'], { ...options, cwd: path, stdin: 'ignore' });\r\n};\r\n","/**\r\n * Create a strict interpolation RegExp based on the given variables' name\r\n */\r\nconst createStrictInterpolationRegExp = (allowedVariableNames: string[], flags: string) => {\r\n  const oneOfVariables = allowedVariableNames.join('|');\r\n\r\n  // 1. We need to match the delimiters: <%= ... %>\r\n  // 2. We accept any number of whitespaces characters before and/or after the variable name: \\s* ... \\s*\r\n  // 3. We only accept values from the variable list as interpolation variables' name: : (${oneOfVariables})\r\n  return new RegExp(`<%=\\\\s*(${oneOfVariables})\\\\s*%>`, flags);\r\n};\r\n\r\n/**\r\n * Create a loose interpolation RegExp to match as many groups as possible\r\n */\r\nconst createLooseInterpolationRegExp = (flags: string) => new RegExp(/<%=([\\s\\S]+?)%>/, flags);\r\n\r\nexport { createStrictInterpolationRegExp, createLooseInterpolationRegExp };\r\n","/**\r\n * Utils file containing file treatment utils\r\n */\r\nimport { Writable, WritableOptions } from 'node:stream';\r\n\r\nconst kbytesToBytes = (kbytes: number) => kbytes * 1000;\r\nconst bytesToKbytes = (bytes: number) => Math.round((bytes / 1000) * 100) / 100;\r\nconst bytesToHumanReadable = (bytes: number) => {\r\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];\r\n  if (bytes === 0) return '0 Bytes';\r\n  const i = parseInt(`${Math.floor(Math.log(bytes) / Math.log(1000))}`, 10);\r\n  return `${Math.round(bytes / 1000 ** i)} ${sizes[i]}`;\r\n};\r\n\r\nconst streamToBuffer = (stream: NodeJS.ReadableStream): Promise<Buffer> =>\r\n  new Promise((resolve, reject) => {\r\n    const chunks: Uint8Array[] = [];\r\n    stream.on('data', (chunk) => {\r\n      chunks.push(chunk);\r\n    });\r\n    stream.on('end', () => {\r\n      resolve(Buffer.concat(chunks));\r\n    });\r\n    stream.on('error', reject);\r\n  });\r\n\r\nconst getStreamSize = (stream: NodeJS.ReadableStream) =>\r\n  new Promise((resolve, reject) => {\r\n    let size = 0;\r\n    stream.on('data', (chunk) => {\r\n      size += Buffer.byteLength(chunk);\r\n    });\r\n    stream.on('close', () => resolve(size));\r\n    stream.on('error', reject);\r\n    stream.resume();\r\n  });\r\n\r\n/**\r\n * Create a writeable Node.js stream that discards received data.\r\n * Useful for testing, draining a stream of data, etc.\r\n */\r\nfunction writableDiscardStream(options?: WritableOptions) {\r\n  return new Writable({\r\n    ...options,\r\n    write(chunk, encding, callback) {\r\n      setImmediate(callback);\r\n    },\r\n  });\r\n}\r\n\r\nexport {\r\n  streamToBuffer,\r\n  bytesToHumanReadable,\r\n  bytesToKbytes,\r\n  kbytesToBytes,\r\n  getStreamSize,\r\n  writableDiscardStream,\r\n};\r\n","import { eq } from 'lodash/fp';\r\n\r\ninterface Options {\r\n  name: string;\r\n  validator?(config: unknown): void;\r\n  handler(...args: any[]): any;\r\n}\r\n\r\nconst createPolicy = (options: Options) => {\r\n  const { name = 'unnamed', validator, handler } = options;\r\n\r\n  const wrappedValidator = (config: unknown) => {\r\n    if (validator) {\r\n      try {\r\n        validator(config);\r\n      } catch (e) {\r\n        throw new Error(`Invalid config passed to \"${name}\" policy.`);\r\n      }\r\n    }\r\n  };\r\n\r\n  return {\r\n    name,\r\n    validator: wrappedValidator,\r\n    handler,\r\n  };\r\n};\r\n\r\nconst createPolicyContext = (type: string, ctx: object) => {\r\n  return Object.assign(\r\n    {\r\n      is: eq(type),\r\n      get type() {\r\n        return type;\r\n      },\r\n    },\r\n    ctx\r\n  );\r\n};\r\n\r\nexport { createPolicy, createPolicyContext };\r\n","import _, { kebabCase } from 'lodash';\r\nimport { trimChars, trimCharsEnd, trimCharsStart } from 'lodash/fp';\r\nimport slugify from '@sindresorhus/slugify';\r\n\r\nconst nameToSlug = (name: string, options: slugify.Options = { separator: '-' }) =>\r\n  slugify(name, options);\r\n\r\nconst nameToCollectionName = (name: string) => slugify(name, { separator: '_' });\r\n\r\nconst toRegressedEnumValue = (value: string) =>\r\n  slugify(value, {\r\n    decamelize: false,\r\n    lowercase: false,\r\n    separator: '_',\r\n  });\r\n\r\nconst getCommonPath = (...paths: string[]) => {\r\n  const [segments, ...otherSegments] = paths.map((it) => _.split(it, '/'));\r\n  return _.join(\r\n    _.takeWhile(segments, (str, index) => otherSegments.every((it) => it[index] === str)),\r\n    '/'\r\n  );\r\n};\r\n\r\nconst isEqual = (a: unknown, b: unknown) => String(a) === String(b);\r\nconst isCamelCase = (value: string) => /^[a-z][a-zA-Z0-9]+$/.test(value);\r\nconst isKebabCase = (value: string) => /^([a-z][a-z0-9]*)(-[a-z0-9]+)*$/.test(value);\r\nconst startsWithANumber = (value: string) => /^[0-9]/.test(value);\r\n\r\nconst joinBy = (joint: string, ...args: string[]) => {\r\n  const trim = trimChars(joint);\r\n  const trimEnd = trimCharsEnd(joint);\r\n  const trimStart = trimCharsStart(joint);\r\n\r\n  return args.reduce((url, path, index) => {\r\n    if (args.length === 1) return path;\r\n    if (index === 0) return trimEnd(path);\r\n    if (index === args.length - 1) return url + joint + trimStart(path);\r\n    return url + joint + trim(path);\r\n  }, '');\r\n};\r\n\r\nconst toKebabCase = (value: string) => kebabCase(value);\r\n\r\nexport {\r\n  nameToSlug,\r\n  nameToCollectionName,\r\n  getCommonPath,\r\n  isEqual,\r\n  isCamelCase,\r\n  isKebabCase,\r\n  toKebabCase,\r\n  toRegressedEnumValue,\r\n  startsWithANumber,\r\n  joinBy,\r\n};\r\n","const castIncludes = (arr: unknown[], val: unknown, cast: (val: unknown) => unknown): boolean =>\r\n  arr.map((val) => cast(val)).includes(cast(val));\r\n\r\nconst includesString = (arr: unknown[], val: unknown) => castIncludes(arr, val, String);\r\n\r\nexport { includesString };\r\n","import _ from 'lodash';\r\n\r\nconst keysDeep = (obj: object, path: string[] = []): string[] =>\r\n  !_.isObject(obj)\r\n    ? [path.join('.')]\r\n    : _.reduce(\r\n        obj,\r\n        (acc, next, key) => _.concat(acc, keysDeep(next, [...path, key])),\r\n        [] as string[]\r\n      );\r\n\r\nexport { keysDeep };\r\n","// Using timestamp (milliseconds) to be sure it is unique\r\n// + converting timestamp to base 36 for better readibility\r\nconst timestampCode = (date?: Date) => {\r\n  const referDate = date ?? new Date();\r\n\r\n  return referDate.getTime().toString(36);\r\n};\r\n\r\nexport { timestampCode };\r\n","// Code copied from the yup library (https://github.com/jquense/yup)\r\n// https://github.com/jquense/yup/blob/2778b88bdacd5260d593c6468793da2e77daf21f/src/util/printValue.ts\r\n\r\nconst { toString } = Object.prototype;\r\nconst errorToString = Error.prototype.toString;\r\nconst regExpToString = RegExp.prototype.toString;\r\nconst symbolToString = typeof Symbol !== 'undefined' ? Symbol.prototype.toString : () => '';\r\n\r\nconst SYMBOL_REGEXP = /^Symbol\\((.*)\\)(.*)$/;\r\n\r\nfunction printNumber(val: number) {\r\n  // eslint-disable-next-line eqeqeq\r\n  if (val != +val) return 'NaN';\r\n  const isNegativeZero = val === 0 && 1 / val < 0;\r\n  return isNegativeZero ? '-0' : `${val}`;\r\n}\r\n\r\nfunction printSimpleValue(val: unknown, quoteStrings = false) {\r\n  if (val == null || val === true || val === false) return `${val}`;\r\n\r\n  if (typeof val === 'number') return printNumber(val);\r\n  if (typeof val === 'string') return quoteStrings ? `\"${val}\"` : val;\r\n  if (typeof val === 'function') return `[Function ${val.name || 'anonymous'}]`;\r\n  if (typeof val === 'symbol') return symbolToString.call(val).replace(SYMBOL_REGEXP, 'Symbol($1)');\r\n\r\n  const tag = toString.call(val).slice(8, -1);\r\n\r\n  if (tag === 'Date') {\r\n    const v = val as Date;\r\n    return Number.isNaN(v.getTime()) ? `${v}` : v.toISOString();\r\n  }\r\n  if (tag === 'Error' || val instanceof Error) return `[${errorToString.call(val)}]`;\r\n  if (tag === 'RegExp') return regExpToString.call(val);\r\n\r\n  return null;\r\n}\r\n\r\nfunction printValue(value: unknown, quoteStrings: boolean) {\r\n  const result = printSimpleValue(value, quoteStrings);\r\n  if (result !== null) return result;\r\n\r\n  return JSON.stringify(\r\n    value,\r\n    function replacer(key, value) {\r\n      const result = printSimpleValue(this[key], quoteStrings);\r\n      if (result !== null) return result;\r\n      return value;\r\n    },\r\n    2\r\n  );\r\n}\r\n\r\nexport { printValue };\r\n","/* eslint-disable no-template-curly-in-string */\r\n/* eslint-disable @typescript-eslint/ban-ts-comment */\r\nimport * as yup from 'yup';\r\nimport _ from 'lodash';\r\nimport { isNumber, isInteger, get } from 'lodash/fp';\r\nimport { strings } from './primitives';\r\nimport { printValue } from './print-value';\r\n\r\nexport * from 'yup';\r\n\r\nexport const strapiID = (): InstanceType<typeof StrapiIDSchema> => new StrapiIDSchema();\r\n\r\nconst isNotNilTest = (value: unknown) => !_.isNil(value);\r\n\r\nconst isNotNullTest = (value: unknown) => !_.isNull(value);\r\n\r\nyup.addMethod(yup.mixed, 'notNil', function isNotNill(msg = '${path} must be defined.') {\r\n  return this.test('defined', msg, isNotNilTest);\r\n});\r\n\r\nyup.addMethod(yup.mixed, 'notNull', function isNotNull(msg = '${path} cannot be null.') {\r\n  return this.test('defined', msg, isNotNullTest);\r\n});\r\n\r\nyup.addMethod(yup.mixed, 'isFunction', function isFunction(message = '${path} is not a function') {\r\n  return this.test(\r\n    'is a function',\r\n    message,\r\n    (value) => _.isUndefined(value) || _.isFunction(value)\r\n  );\r\n});\r\n\r\nyup.addMethod(\r\n  yup.string,\r\n  'isCamelCase',\r\n  function isCamelCase(message = '${path} is not in camel case (anExampleOfCamelCase)') {\r\n    return this.test('is in camelCase', message, (value) =>\r\n      value ? strings.isCamelCase(value) : true\r\n    );\r\n  }\r\n);\r\n\r\nyup.addMethod(\r\n  yup.string,\r\n  'isKebabCase',\r\n  function isKebabCase(message = '${path} is not in kebab case (an-example-of-kebab-case)') {\r\n    return this.test('is in kebab-case', message, (value) =>\r\n      value ? strings.isKebabCase(value) : true\r\n    );\r\n  }\r\n);\r\n\r\nyup.addMethod(\r\n  yup.object,\r\n  'onlyContainsFunctions',\r\n  function onlyContainsFunctions(message = '${path} contains values that are not functions') {\r\n    return this.test(\r\n      'only contains functions',\r\n      message,\r\n      (value) => _.isUndefined(value) || (value && Object.values(value).every(_.isFunction))\r\n    );\r\n  }\r\n);\r\n\r\nyup.addMethod(\r\n  yup.array,\r\n  'uniqueProperty',\r\n  function uniqueProperty(propertyName: string, message: string) {\r\n    return this.test('unique', message, function unique(list) {\r\n      const errors: yup.ValidationError[] = [];\r\n\r\n      list?.forEach((element, index) => {\r\n        const sameElements = list.filter(\r\n          (e) => get(propertyName, e) === get(propertyName, element)\r\n        );\r\n        if (sameElements.length > 1) {\r\n          errors.push(\r\n            this.createError({\r\n              path: `${this.path}[${index}].${propertyName}`,\r\n              message,\r\n            })\r\n          );\r\n        }\r\n      });\r\n\r\n      if (errors.length) {\r\n        throw new yup.ValidationError(errors);\r\n      }\r\n      return true;\r\n    });\r\n  }\r\n);\r\n\r\nexport class StrapiIDSchema extends yup.MixedSchema {\r\n  constructor() {\r\n    super({ type: 'strapiID' });\r\n  }\r\n\r\n  _typeCheck(value: unknown): value is string | number {\r\n    return typeof value === 'string' || (isNumber(value) && isInteger(value) && value >= 0);\r\n  }\r\n}\r\n\r\ndeclare module 'yup' {\r\n  // const strapiID: () => InstanceType<typeof StrapiIDSchema>;\r\n\r\n  export interface BaseSchema {\r\n    isFunction(message?: string): this;\r\n    notNil(message?: string): this;\r\n    notNull(message?: string): this;\r\n  }\r\n\r\n  export interface StringSchema {\r\n    isCamelCase(message?: string): this;\r\n    isKebabCase(message?: string): this;\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n  export interface ObjectSchema<TShape> {\r\n    onlyContainsFunctions(message?: string): this;\r\n  }\r\n}\r\n\r\ninterface NoTypeOptions {\r\n  path: string;\r\n  type: string;\r\n  value: unknown;\r\n  originalValue: unknown;\r\n}\r\n\r\n// Temporary fix of this issue : https://github.com/jquense/yup/issues/616\r\nyup.setLocale({\r\n  mixed: {\r\n    notType(options: NoTypeOptions) {\r\n      const { path, type, value, originalValue } = options;\r\n      const isCast = originalValue != null && originalValue !== value;\r\n      const msg =\r\n        `${path} must be a \\`${type}\\` type, ` +\r\n        `but the final value was: \\`${printValue(value, true)}\\`${\r\n          isCast ? ` (cast from the value \\`${printValue(originalValue, true)}\\`).` : '.'\r\n        }`;\r\n\r\n      /* Remove comment that is not supposed to be seen by the enduser\r\n      if (value === null) {\r\n        msg += `\\n If \"null\" is intended as an empty value be sure to mark the schema as \\`.nullable()\\``;\r\n      }\r\n      */\r\n      return msg;\r\n    },\r\n  },\r\n});\r\n","import { z } from 'zod';\r\n\r\nimport { ValidationError } from './errors';\r\n\r\nexport const validateZod =\r\n  <T extends z.ZodTypeAny>(schema: T) =>\r\n  (data: unknown): z.TypeOf<T> => {\r\n    try {\r\n      return schema.parse(data);\r\n    } catch (error) {\r\n      if (error instanceof z.ZodError) {\r\n        const { message, errors } = formatZodErrors(error);\r\n        throw new ValidationError(message, { errors });\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  };\r\n\r\nconst formatZodErrors = (zodError: z.ZodError) => ({\r\n  errors: zodError.errors.map((error) => {\r\n    return {\r\n      path: error.path,\r\n      message: error.message,\r\n      name: 'ValidationError',\r\n    };\r\n  }),\r\n  message: 'Validation error',\r\n});\r\n"],"names":["dates","_","ID_ATTRIBUTE","DOC_ID_ATTRIBUTE","PUBLISHED_AT_ATTRIBUTE","CREATED_BY_ATTRIBUTE","UPDATED_BY_ATTRIBUTE","constants","contentTypes.constants","visitor","path","schema","i","errors","yup","isStringArray","populate","value","key","acc","sort","filters","fields","remove","ACTIONS_TO_VERIFY","contentTypeUtils.constants","hasAccessToSomeScopes","contentTypeUtils.isMorphToRelationalAttribute","getContainedPaths","index","parser","utils","isObj","pipe","map","newValue","first","traverseEntity","removePassword","removePrivate","pipeAsync","removeDynamicZones","removeMorphToRelations","expandWildcardPopulate","visitors.removeRestrictedFields","visitors.removeRestrictedRelations","data","sanitizers.defaultSanitizeOutput","sanitizers.defaultSanitizeFilters","sanitizers.defaultSanitizeSort","sanitizers.defaultSanitizeFields","sanitizers.defaultSanitizePopulate","throwDynamicZones","throwMorphToRelations","throwPassword","throwPrivate","visitors.throwRestrictedFields","visitors.throwUnrecognizedFields","visitors.throwRestrictedRelations","validateFilters","validateSort","validateFields","validatePopulate","validators.defaultValidateFilters","validators.defaultValidateSort","validators.defaultValidateFields","validators.defaultValidatePopulate","pagination","defaults","packageManager","trim","val","result","isCamelCase","strings.isCamelCase","isKebabCase","strings.isKebabCase"],"mappings":"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"}