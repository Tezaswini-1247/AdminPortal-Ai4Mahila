{"version":3,"file":"index.js","sources":["../src/utils/encryption/encrypt.ts","../src/utils/encryption/decrypt.ts","../src/utils/stream.ts","../src/utils/json.ts","../src/utils/schema.ts","../src/utils/transaction.ts","../src/utils/middleware.ts","../src/utils/diagnostic.ts","../src/engine/validation/schemas/index.ts","../src/errors/constants.ts","../src/errors/base.ts","../src/engine/errors.ts","../src/engine/validation/provider.ts","../src/errors/providers.ts","../src/engine/index.ts","../src/utils/components.ts","../src/strapi/queries/entity.ts","../src/strapi/queries/link.ts","../src/strapi/providers/local-destination/strategies/restore/entities.ts","../src/strapi/providers/local-destination/strategies/restore/configuration.ts","../src/strapi/providers/local-destination/strategies/restore/links.ts","../src/strapi/providers/local-destination/strategies/restore/index.ts","../src/utils/providers.ts","../src/strapi/providers/local-destination/index.ts","../src/strapi/providers/local-source/entities.ts","../src/strapi/providers/local-source/links.ts","../src/strapi/providers/local-source/configuration.ts","../src/strapi/providers/local-source/assets.ts","../src/strapi/providers/local-source/index.ts","../src/strapi/providers/utils.ts","../src/strapi/remote/constants.ts","../src/strapi/providers/remote-destination/index.ts","../src/strapi/providers/remote-source/index.ts","../src/strapi/remote/flows/default.ts","../src/strapi/remote/flows/index.ts","../src/strapi/remote/handlers/constants.ts","../src/strapi/remote/handlers/utils.ts","../src/strapi/remote/handlers/push.ts","../src/strapi/remote/handlers/pull.ts","../src/file/providers/source/utils.ts","../src/file/providers/source/index.ts","../src/file/providers/destination/utils.ts","../src/file/providers/destination/index.ts"],"sourcesContent":["import { createCipheriv, Cipher, scryptSync, CipherKey, BinaryLike } from 'crypto';\r\nimport { EncryptionStrategy, Strategies, Algorithm } from '../../../types';\r\n\r\n// different key values depending on algorithm chosen\r\nconst getEncryptionStrategy = (algorithm: Algorithm): EncryptionStrategy => {\r\n  const strategies: Strategies = {\r\n    'aes-128-ecb'(key: string): Cipher {\r\n      const hashedKey = scryptSync(key, '', 16);\r\n      const initVector: BinaryLike | null = null;\r\n      const securityKey: CipherKey = hashedKey;\r\n      return createCipheriv(algorithm, securityKey, initVector);\r\n    },\r\n    aes128(key: string): Cipher {\r\n      const hashedKey = scryptSync(key, '', 32);\r\n      const initVector: BinaryLike | null = hashedKey.slice(16);\r\n      const securityKey: CipherKey = hashedKey.slice(0, 16);\r\n      return createCipheriv(algorithm, securityKey, initVector);\r\n    },\r\n    aes192(key: string): Cipher {\r\n      const hashedKey = scryptSync(key, '', 40);\r\n      const initVector: BinaryLike | null = hashedKey.slice(24);\r\n      const securityKey: CipherKey = hashedKey.slice(0, 24);\r\n      return createCipheriv(algorithm, securityKey, initVector);\r\n    },\r\n    aes256(key: string): Cipher {\r\n      const hashedKey = scryptSync(key, '', 48);\r\n      const initVector: BinaryLike | null = hashedKey.slice(32);\r\n      const securityKey: CipherKey = hashedKey.slice(0, 32);\r\n      return createCipheriv(algorithm, securityKey, initVector);\r\n    },\r\n  };\r\n\r\n  return strategies[algorithm];\r\n};\r\n\r\n/**\r\n * It creates a cipher instance used for encryption\r\n *\r\n * @param key - The encryption key\r\n * @param algorithm - The algorithm to use to create the Cipher\r\n *\r\n * @returns A {@link Cipher} instance created with the given key & algorithm\r\n */\r\nexport const createEncryptionCipher = (\r\n  key: string,\r\n  algorithm: Algorithm = 'aes-128-ecb'\r\n): Cipher => {\r\n  return getEncryptionStrategy(algorithm)(key);\r\n};\r\n","import { Cipher, scryptSync, CipherKey, BinaryLike, createDecipheriv } from 'crypto';\r\nimport { EncryptionStrategy, Strategies, Algorithm } from '../../../types';\r\n\r\n// different key values depending on algorithm chosen\r\nconst getDecryptionStrategy = (algorithm: Algorithm): EncryptionStrategy => {\r\n  const strategies: Strategies = {\r\n    'aes-128-ecb'(key: string): Cipher {\r\n      const hashedKey = scryptSync(key, '', 16);\r\n      const initVector: BinaryLike | null = null;\r\n      const securityKey: CipherKey = hashedKey;\r\n      return createDecipheriv(algorithm, securityKey, initVector);\r\n    },\r\n    aes128(key: string): Cipher {\r\n      const hashedKey = scryptSync(key, '', 32);\r\n      const initVector: BinaryLike | null = hashedKey.slice(16);\r\n      const securityKey: CipherKey = hashedKey.slice(0, 16);\r\n      return createDecipheriv(algorithm, securityKey, initVector);\r\n    },\r\n    aes192(key: string): Cipher {\r\n      const hashedKey = scryptSync(key, '', 40);\r\n      const initVector: BinaryLike | null = hashedKey.slice(24);\r\n      const securityKey: CipherKey = hashedKey.slice(0, 24);\r\n      return createDecipheriv(algorithm, securityKey, initVector);\r\n    },\r\n    aes256(key: string): Cipher {\r\n      const hashedKey = scryptSync(key, '', 48);\r\n      const initVector: BinaryLike | null = hashedKey.slice(32);\r\n      const securityKey: CipherKey = hashedKey.slice(0, 32);\r\n      return createDecipheriv(algorithm, securityKey, initVector);\r\n    },\r\n  };\r\n\r\n  return strategies[algorithm];\r\n};\r\n\r\n/**\r\n * It creates a cipher instance used for decryption\r\n *\r\n * @param key - The decryption key\r\n * @param algorithm - The algorithm to use to create the Cipher\r\n *\r\n * @returns A {@link Cipher} instance created with the given key & algorithm\r\n */\r\nexport const createDecryptionCipher = (\r\n  key: string,\r\n  algorithm: Algorithm = 'aes-128-ecb'\r\n): Cipher => {\r\n  return getDecryptionStrategy(algorithm)(key);\r\n};\r\n","import { Transform, Readable } from 'stream';\r\n\r\ntype TransformOptions = ConstructorParameters<typeof Transform>[0];\r\n\r\n/**\r\n * Create a filter stream that discard chunks which doesn't satisfies the given predicate\r\n *\r\n * @param predicate - A filter predicate, takes a stream data chunk as parameter and returns a boolean value\r\n * @param options - Transform stream options\r\n */\r\nexport const filter = <T>(\r\n  predicate: (value: T) => boolean | Promise<boolean>,\r\n  options: TransformOptions = { objectMode: true }\r\n): Transform => {\r\n  return new Transform({\r\n    ...options,\r\n\r\n    async transform(chunk, _encoding, callback) {\r\n      const keep = await predicate(chunk);\r\n\r\n      callback(null, keep ? chunk : undefined);\r\n    },\r\n  });\r\n};\r\n\r\n/**\r\n * Create a map stream that transform chunks using the given predicate\r\n *\r\n * @param predicate - A map predicate, takes a stream data chunk as parameter and returns a mapped value\r\n * @param options - Transform stream options\r\n */\r\nexport const map = <T, U = T>(\r\n  predicate: (value: T) => U | Promise<U>,\r\n  options: TransformOptions = { objectMode: true }\r\n): Transform => {\r\n  return new Transform({\r\n    ...options,\r\n\r\n    async transform(chunk, _encoding, callback) {\r\n      const mappedValue = await predicate(chunk);\r\n\r\n      callback(null, mappedValue);\r\n    },\r\n  });\r\n};\r\n\r\n/**\r\n * Collect every chunks from a Readable stream.\r\n *\r\n * @param stream - The redable stream to collect data from\r\n * @param options.destroy - If set to true, it automatically calls `destroy()` on the given stream upon receiving the 'end' event\r\n */\r\nexport const collect = <T = unknown>(\r\n  stream: Readable,\r\n  options: { destroy: boolean } = { destroy: true }\r\n): Promise<T[]> => {\r\n  const chunks: T[] = [];\r\n\r\n  return new Promise((resolve, reject) => {\r\n    stream\r\n      .on('close', () => resolve(chunks))\r\n      .on('error', reject)\r\n      .on('data', (chunk) => chunks.push(chunk))\r\n      .on('end', () => {\r\n        if (options.destroy) {\r\n          stream.destroy();\r\n        }\r\n\r\n        resolve(chunks);\r\n      });\r\n  });\r\n};\r\n","import { isArray, isObject, zip, isEqual, uniq } from 'lodash/fp';\r\n\r\nconst createContext = (): Context => ({ path: [] });\r\n\r\n/**\r\n * Compute differences between two JSON objects and returns them\r\n *\r\n * @param a - First object\r\n * @param b - Second object\r\n * @param ctx - Context used to keep track of the current path during recursion\r\n */\r\nexport const diff = (a: unknown, b: unknown, ctx: Context = createContext()): Diff[] => {\r\n  const diffs: Diff[] = [];\r\n  const { path } = ctx;\r\n\r\n  const aType = typeof a;\r\n  const bType = typeof b;\r\n\r\n  // Define helpers\r\n\r\n  const added = () => {\r\n    diffs.push({ kind: 'added', path, type: bType, value: b });\r\n    return diffs;\r\n  };\r\n\r\n  const deleted = () => {\r\n    diffs.push({ kind: 'deleted', path, type: aType, value: a });\r\n    return diffs;\r\n  };\r\n\r\n  const modified = () => {\r\n    diffs.push({\r\n      kind: 'modified',\r\n      path,\r\n      types: [aType, bType],\r\n      values: [a, b],\r\n    });\r\n    return diffs;\r\n  };\r\n\r\n  if (isArray(a) && isArray(b)) {\r\n    let k = 0;\r\n\r\n    for (const [aItem, bItem] of zip(a, b)) {\r\n      const kCtx: Context = { path: [...path, k.toString()] };\r\n      const kDiffs = diff(aItem, bItem, kCtx);\r\n\r\n      diffs.push(...kDiffs);\r\n\r\n      k += 1;\r\n    }\r\n\r\n    return diffs;\r\n  }\r\n\r\n  if (isObject(a) && isObject(b)) {\r\n    const keys = uniq(Object.keys(a).concat(Object.keys(b)));\r\n\r\n    for (const key of keys) {\r\n      const aValue = (a as Record<string, unknown>)[key];\r\n      const bValue = (b as Record<string, unknown>)[key];\r\n\r\n      const nestedDiffs = diff(aValue, bValue, { path: [...path, key] });\r\n\r\n      diffs.push(...nestedDiffs);\r\n    }\r\n\r\n    return diffs;\r\n  }\r\n\r\n  if (!isEqual(a, b)) {\r\n    if (aType === 'undefined') {\r\n      return added();\r\n    }\r\n\r\n    if (bType === 'undefined') {\r\n      return deleted();\r\n    }\r\n\r\n    return modified();\r\n  }\r\n\r\n  return diffs;\r\n};\r\n\r\nexport interface AddedDiff<T = unknown> {\r\n  kind: 'added';\r\n  path: string[];\r\n  type: string;\r\n  value: T;\r\n}\r\n\r\nexport interface ModifiedDiff<T = unknown, P = unknown> {\r\n  kind: 'modified';\r\n  path: string[];\r\n  types: [string, string];\r\n  values: [T, P];\r\n}\r\n\r\nexport interface DeletedDiff<T = unknown> {\r\n  kind: 'deleted';\r\n  path: string[];\r\n  type: string;\r\n  value: T;\r\n}\r\n\r\nexport type Diff<T = unknown> = AddedDiff<T> | ModifiedDiff<T> | DeletedDiff<T>;\r\n\r\nexport interface Context {\r\n  path: string[];\r\n}\r\n","import type { Struct, Utils } from '@strapi/types';\r\nimport { mapValues, pick } from 'lodash/fp';\r\n\r\n/**\r\n * List of schema properties that should be kept when sanitizing schemas\r\n */\r\nconst VALID_SCHEMA_PROPERTIES = [\r\n  'collectionName',\r\n  'info',\r\n  'options',\r\n  'pluginOptions',\r\n  'attributes',\r\n  'kind',\r\n  'modelType',\r\n  'modelName',\r\n  'uid',\r\n  'plugin',\r\n  'globalId',\r\n];\r\n\r\n/**\r\n * Sanitize a schemas dictionary by omitting unwanted properties\r\n * The list of allowed properties can be found here: {@link VALID_SCHEMA_PROPERTIES}\r\n */\r\nexport const mapSchemasValues = (schemas: Utils.String.Dict<Struct.Schema>) => {\r\n  return mapValues(pick(VALID_SCHEMA_PROPERTIES), schemas) as Utils.String.Dict<Struct.Schema>;\r\n};\r\n\r\nexport const schemasToValidJSON = (schemas: Utils.String.Dict<Struct.Schema>) => {\r\n  return JSON.parse(JSON.stringify(schemas));\r\n};\r\n","import { EventEmitter } from 'events';\r\nimport { randomUUID } from 'crypto';\r\nimport type { Core } from '@strapi/types';\r\n\r\nimport { Transaction, TransactionCallback } from '../../types/utils';\r\n\r\nexport const createTransaction = (strapi: Core.Strapi): Transaction => {\r\n  const fns: { fn: TransactionCallback; uuid: string }[] = [];\r\n\r\n  let done = false;\r\n  let resume: null | (() => void) = null;\r\n\r\n  const e = new EventEmitter();\r\n  e.on('spawn', (uuid, cb) => {\r\n    fns.push({ fn: cb, uuid });\r\n    resume?.();\r\n  });\r\n\r\n  e.on('close', () => {\r\n    e.removeAllListeners('rollback');\r\n    e.removeAllListeners('spawn');\r\n\r\n    done = true;\r\n    resume?.();\r\n  });\r\n\r\n  strapi.db.transaction(async ({ trx, rollback }) => {\r\n    e.once('rollback', async () => {\r\n      e.removeAllListeners('close');\r\n      e.removeAllListeners('spawn');\r\n\r\n      try {\r\n        await rollback();\r\n        e.emit('rollback_completed');\r\n      } catch {\r\n        e.emit('rollback_failed');\r\n      } finally {\r\n        done = true;\r\n        resume?.();\r\n      }\r\n    });\r\n\r\n    while (!done) {\r\n      while (fns.length) {\r\n        const item = fns.shift();\r\n\r\n        if (item) {\r\n          const { fn, uuid } = item;\r\n\r\n          try {\r\n            const res = await fn(trx);\r\n            e.emit(uuid, { data: res });\r\n          } catch (error) {\r\n            e.emit(uuid, { error });\r\n          }\r\n        }\r\n      }\r\n      if (!done && !fns.length) {\r\n        // eslint-disable-next-line @typescript-eslint/no-loop-func\r\n        await new Promise<void>((resolve) => {\r\n          resume = resolve;\r\n        });\r\n      }\r\n    }\r\n  });\r\n\r\n  return {\r\n    async attach<T = undefined>(callback: TransactionCallback): Promise<T | undefined> {\r\n      const uuid = randomUUID();\r\n      e.emit('spawn', uuid, callback);\r\n      return new Promise<T | undefined>((resolve, reject) => {\r\n        e.on(uuid, ({ data, error }) => {\r\n          if (data) {\r\n            resolve(data);\r\n          }\r\n\r\n          if (error) {\r\n            reject(error);\r\n          }\r\n          resolve(undefined);\r\n        });\r\n      });\r\n    },\r\n\r\n    end() {\r\n      return e.emit('close');\r\n    },\r\n\r\n    rollback() {\r\n      return new Promise<boolean>((resolve) => {\r\n        e.emit('rollback');\r\n\r\n        e.once('rollback_failed', () => resolve(false));\r\n        e.once('rollback_completed', () => resolve(true));\r\n      });\r\n    },\r\n  };\r\n};\r\n","import { Middleware } from '../../types';\r\n\r\nexport const runMiddleware = async <T>(context: T, middlewares: Middleware<T>[]): Promise<void> => {\r\n  if (!middlewares.length) {\r\n    return;\r\n  }\r\n  const cb = middlewares[0];\r\n  await cb(context, async (newContext: T) => {\r\n    await runMiddleware(newContext, middlewares.slice(1));\r\n  });\r\n};\r\n","import { EventEmitter } from 'events';\r\n\r\nexport interface IDiagnosticReporterOptions {\r\n  stackSize?: number;\r\n}\r\n\r\nexport type GenericDiagnostic<K extends DiagnosticKind, T = unknown> = {\r\n  kind: K;\r\n  details: {\r\n    message: string;\r\n    createdAt: Date;\r\n  } & T;\r\n};\r\n\r\nexport type DiagnosticKind = 'error' | 'warning' | 'info';\r\n\r\nexport type DiagnosticListener<T extends DiagnosticKind = DiagnosticKind> = (\r\n  diagnostic: { kind: T } & Diagnostic extends infer U ? U : never\r\n) => void | Promise<void>;\r\n\r\nexport type DiagnosticEvent = 'diagnostic' | `diagnostic.${DiagnosticKind}`;\r\n\r\nexport type GetEventListener<E extends DiagnosticEvent> = E extends 'diagnostic'\r\n  ? DiagnosticListener\r\n  : E extends `diagnostic.${infer K}`\r\n    ? K extends DiagnosticKind\r\n      ? DiagnosticListener<K>\r\n      : never\r\n    : never;\r\n\r\nexport type Diagnostic = ErrorDiagnostic | WarningDiagnostic | InfoDiagnostic;\r\n\r\nexport type ErrorDiagnosticSeverity = 'fatal' | 'error' | 'silly';\r\n\r\nexport type ErrorDiagnostic = GenericDiagnostic<\r\n  'error',\r\n  {\r\n    name: string;\r\n    severity: ErrorDiagnosticSeverity;\r\n    error: Error;\r\n  }\r\n>;\r\n\r\nexport type WarningDiagnostic = GenericDiagnostic<\r\n  'warning',\r\n  {\r\n    origin?: string;\r\n  }\r\n>;\r\n\r\nexport type InfoDiagnostic<T = unknown> = GenericDiagnostic<\r\n  'info',\r\n  {\r\n    origin?: string;\r\n    params?: T;\r\n  }\r\n>;\r\n\r\nexport interface IDiagnosticReporter {\r\n  stack: {\r\n    readonly size: number;\r\n    readonly items: Diagnostic[];\r\n  };\r\n\r\n  report(diagnostic: Diagnostic): IDiagnosticReporter;\r\n  onDiagnostic(listener: DiagnosticListener): IDiagnosticReporter;\r\n  on<T extends DiagnosticKind>(kind: T, listener: DiagnosticListener<T>): IDiagnosticReporter;\r\n}\r\n\r\nconst createDiagnosticReporter = (\r\n  options: IDiagnosticReporterOptions = {}\r\n): IDiagnosticReporter => {\r\n  const { stackSize = -1 } = options;\r\n\r\n  const emitter = new EventEmitter();\r\n  const stack: Diagnostic[] = [];\r\n\r\n  const addListener = <T extends DiagnosticEvent>(event: T, listener: GetEventListener<T>) => {\r\n    emitter.on(event, listener);\r\n  };\r\n\r\n  const isDiagnosticValid = (diagnostic: Diagnostic) => {\r\n    if (!diagnostic.kind || !diagnostic.details || !diagnostic.details.message) {\r\n      return false;\r\n    }\r\n    return true;\r\n  };\r\n\r\n  return {\r\n    stack: {\r\n      get size() {\r\n        return stack.length;\r\n      },\r\n\r\n      get items() {\r\n        return stack;\r\n      },\r\n    },\r\n\r\n    report(diagnostic: Diagnostic) {\r\n      if (!isDiagnosticValid(diagnostic)) {\r\n        return this;\r\n      }\r\n\r\n      emitter.emit('diagnostic', diagnostic);\r\n      emitter.emit(`diagnostic.${diagnostic.kind}`, diagnostic);\r\n\r\n      if (stackSize !== -1 && stack.length >= stackSize) {\r\n        stack.shift();\r\n      }\r\n\r\n      stack.push(diagnostic);\r\n\r\n      return this;\r\n    },\r\n\r\n    onDiagnostic(listener: DiagnosticListener) {\r\n      addListener('diagnostic', listener);\r\n\r\n      return this;\r\n    },\r\n\r\n    on<T extends DiagnosticKind>(kind: T, listener: DiagnosticListener<T>) {\r\n      addListener(`diagnostic.${kind}`, listener as never);\r\n\r\n      return this;\r\n    },\r\n  };\r\n};\r\n\r\nexport { createDiagnosticReporter };\r\n","import type { Struct } from '@strapi/types';\r\nimport { isArray, isObject, reject } from 'lodash/fp';\r\nimport type { Diff } from '../../../utils/json';\r\nimport * as utils from '../../../utils';\r\n\r\nconst OPTIONAL_CONTENT_TYPES = ['audit-log'] as const;\r\n\r\nconst isAttributeIgnorable = (diff: Diff) => {\r\n  return (\r\n    diff.path.length === 3 &&\r\n    // Root property must be attributes\r\n    diff.path[0] === 'attributes' &&\r\n    // Need a valid string attribute name\r\n    typeof diff.path[1] === 'string' &&\r\n    // The diff must be on ignorable attribute properties\r\n    ['private', 'required', 'configurable', 'default'].includes(diff.path[2])\r\n  );\r\n};\r\n\r\n// TODO: clean up the type checking, which will require cleaning up the typings in utils/json.ts\r\n// exclude admin tables that are not transferable and are optionally available (such as audit logs which are only available in EE)\r\nconst isOptionalAdminType = (diff: Diff) => {\r\n  // added/deleted\r\n  if ('value' in diff && isObject(diff.value)) {\r\n    const name = (diff?.value as Struct.ContentTypeSchema)?.info?.singularName;\r\n    return (OPTIONAL_CONTENT_TYPES as ReadonlyArray<string | undefined>).includes(name);\r\n  }\r\n\r\n  // modified\r\n  if ('values' in diff && isArray(diff.values) && isObject(diff.values[0])) {\r\n    const name = (diff?.values[0] as Struct.ContentTypeSchema)?.info?.singularName;\r\n    return (OPTIONAL_CONTENT_TYPES as ReadonlyArray<string | undefined>).includes(name);\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nconst isIgnorableStrict = (diff: Diff) => isAttributeIgnorable(diff) || isOptionalAdminType(diff);\r\n\r\nconst strategies = {\r\n  // No diffs\r\n  exact(diffs: Diff[]) {\r\n    return diffs;\r\n  },\r\n\r\n  // Strict: all content types must match except:\r\n  // - the property within a content type is an ignorable one\r\n  // - those that are (not transferrable and optionally available), for example EE features such as audit logs\r\n  strict(diffs: Diff[]) {\r\n    return reject(isIgnorableStrict, diffs);\r\n  },\r\n};\r\n\r\nconst compareSchemas = <T, P>(a: T, b: P, strategy: keyof typeof strategies) => {\r\n  const diffs = utils.json.diff(a, b);\r\n  return strategies[strategy](diffs);\r\n};\r\n\r\nexport { compareSchemas };\r\n","import { ErrorDiagnosticSeverity } from '../utils/diagnostic';\r\n\r\nexport const SeverityKind: Record<string, ErrorDiagnosticSeverity> = {\r\n  FATAL: 'fatal',\r\n  ERROR: 'error',\r\n  SILLY: 'silly',\r\n} as const;\r\nexport type Severity = (typeof SeverityKind)[keyof typeof SeverityKind];\r\n","import { Severity } from './constants';\r\n\r\nclass DataTransferError<T = unknown> extends Error {\r\n  origin: string;\r\n\r\n  severity: Severity;\r\n\r\n  details: T | null;\r\n\r\n  constructor(origin: string, severity: Severity, message?: string, details?: T | null) {\r\n    super(message);\r\n\r\n    this.origin = origin;\r\n    this.severity = severity;\r\n    this.details = details ?? null;\r\n  }\r\n}\r\n\r\nexport { DataTransferError };\r\n","import { DataTransferError, Severity, SeverityKind } from '../errors';\r\n\r\ntype TransferEngineStep = 'initialization' | 'validation' | 'transfer';\r\n\r\ntype TransferEngineErrorDetails<P extends TransferEngineStep = TransferEngineStep, U = never> = {\r\n  step: P;\r\n} & ([U] extends [never] ? unknown : { details?: U });\r\n\r\nclass TransferEngineError<\r\n  P extends TransferEngineStep = TransferEngineStep,\r\n  U = never,\r\n  T extends TransferEngineErrorDetails<P, U> = TransferEngineErrorDetails<P, U>,\r\n> extends DataTransferError<T> {\r\n  constructor(severity: Severity, message?: string, details?: T | null) {\r\n    super('engine', severity, message, details);\r\n  }\r\n}\r\n\r\nclass TransferEngineInitializationError extends TransferEngineError<'initialization'> {\r\n  constructor(message?: string) {\r\n    super(SeverityKind.FATAL, message, { step: 'initialization' });\r\n  }\r\n}\r\n\r\nclass TransferEngineValidationError<\r\n  T extends { check: string } = { check: string },\r\n> extends TransferEngineError<'validation', T> {\r\n  constructor(message?: string, details?: T) {\r\n    super(SeverityKind.FATAL, message, { step: 'validation', details });\r\n  }\r\n}\r\n\r\nclass TransferEngineTransferError<\r\n  T extends { check: string } = { check: string },\r\n> extends TransferEngineError<'transfer', T> {\r\n  constructor(message?: string, details?: T) {\r\n    super(SeverityKind.FATAL, message, { step: 'transfer', details });\r\n  }\r\n}\r\n\r\nexport {\r\n  TransferEngineError,\r\n  TransferEngineInitializationError,\r\n  TransferEngineValidationError,\r\n  TransferEngineTransferError,\r\n};\r\n","import { capitalize } from 'lodash/fp';\r\n\r\nimport type { IDestinationProvider, ISourceProvider, ProviderType } from '../../../types';\r\nimport { TransferEngineValidationError } from '../errors';\r\n\r\nconst reject = (reason: string): never => {\r\n  throw new TransferEngineValidationError(`Invalid provider supplied. ${reason}`);\r\n};\r\n\r\nconst validateProvider = <T extends ProviderType>(\r\n  type: ProviderType,\r\n  provider?: ([T] extends ['source'] ? ISourceProvider : IDestinationProvider) | null\r\n) => {\r\n  if (!provider) {\r\n    return reject(\r\n      `Expected an instance of \"${capitalize(type)}Provider\", but got \"${typeof provider}\" instead.`\r\n    );\r\n  }\r\n\r\n  if (provider.type !== type) {\r\n    return reject(\r\n      `Expected the provider to be of type \"${type}\" but got \"${provider.type}\" instead.`\r\n    );\r\n  }\r\n};\r\n\r\nexport { validateProvider };\r\n","import { ErrorCode } from '../../types';\r\nimport { DataTransferError } from './base';\r\nimport { Severity, SeverityKind } from './constants';\r\n\r\ntype ProviderStep = 'initialization' | 'validation' | 'transfer';\r\n\r\nexport type ProviderErrorDetails<P extends ProviderStep = ProviderStep, U = never> = {\r\n  step: P;\r\n  code?: ErrorCode;\r\n} & ([U] extends [never] ? unknown : { details?: U });\r\n\r\nexport class ProviderError<\r\n  P extends ProviderStep = ProviderStep,\r\n  U = never,\r\n  T extends ProviderErrorDetails<P, U> = ProviderErrorDetails<P, U>,\r\n> extends DataTransferError<T> {\r\n  constructor(severity: Severity, message?: string, details?: T | null) {\r\n    super('provider', severity, message, details);\r\n  }\r\n}\r\n\r\nexport class ProviderInitializationError extends ProviderError<'initialization'> {\r\n  constructor(message?: string) {\r\n    super(SeverityKind.FATAL, message, { step: 'initialization' });\r\n  }\r\n}\r\n\r\n// TODO: these types are not working correctly, ProviderTransferError() is accepting any details object rather than requiring T\r\nexport class ProviderValidationError<T = ProviderErrorDetails> extends ProviderError<\r\n  'validation',\r\n  T\r\n> {\r\n  constructor(message?: string, details?: T) {\r\n    super(SeverityKind.SILLY, message, { step: 'validation', details });\r\n  }\r\n}\r\n// TODO: these types are not working correctly, ProviderTransferError() is accepting any details object rather than requiring T\r\nexport class ProviderTransferError<T = ProviderErrorDetails> extends ProviderError<'transfer', T> {\r\n  constructor(message?: string, details?: T) {\r\n    super(SeverityKind.FATAL, message, { step: 'transfer', details });\r\n  }\r\n}\r\n","import { PassThrough, Transform, Readable, Writable } from 'stream';\r\nimport { extname } from 'path';\r\nimport { EOL } from 'os';\r\nimport type Chain from 'stream-chain';\r\nimport { chain } from 'stream-chain';\r\nimport { isEmpty, uniq, last, isNumber, set, pick } from 'lodash/fp';\r\nimport { diff as semverDiff } from 'semver';\r\n\r\nimport type { Struct, Utils } from '@strapi/types';\r\n\r\nimport type {\r\n  IAsset,\r\n  IDestinationProvider,\r\n  IEntity,\r\n  ILink,\r\n  IMetadata,\r\n  ISourceProvider,\r\n  ITransferEngine,\r\n  ITransferEngineOptions,\r\n  TransferProgress,\r\n  ITransferResults,\r\n  TransferStage,\r\n  TransferTransform,\r\n  IProvider,\r\n  TransferFilters,\r\n  TransferFilterPreset,\r\n  StreamItem,\r\n  SchemaDiffHandler,\r\n  SchemaDiffHandlerContext,\r\n  ErrorHandler,\r\n  ErrorHandlerContext,\r\n  ErrorHandlers,\r\n  ErrorCode,\r\n} from '../../types';\r\nimport type { Diff } from '../utils/json';\r\n\r\nimport { compareSchemas, validateProvider } from './validation';\r\n\r\nimport { TransferEngineError, TransferEngineValidationError } from './errors';\r\nimport {\r\n  createDiagnosticReporter,\r\n  IDiagnosticReporter,\r\n  ErrorDiagnosticSeverity,\r\n} from '../utils/diagnostic';\r\nimport { DataTransferError } from '../errors';\r\nimport * as utils from '../utils';\r\nimport { ProviderTransferError } from '../errors/providers';\r\n\r\nexport const TRANSFER_STAGES: ReadonlyArray<TransferStage> = Object.freeze([\r\n  'entities',\r\n  'links',\r\n  'assets',\r\n  'schemas',\r\n  'configuration',\r\n]);\r\n\r\nexport type TransferGroupFilter = Record<TransferFilterPreset, TransferFilters>;\r\n\r\n/**\r\n * Preset filters for only/exclude options\r\n * */\r\nexport const TransferGroupPresets: TransferGroupFilter = {\r\n  content: {\r\n    links: true, // Example: content includes the entire links stage\r\n    entities: true,\r\n    // TODO: If we need to implement filtering on a running stage, it would be done like this, but we still need to implement it\r\n    // [\r\n    //   // Example: content processes the entities stage, but filters individual entities\r\n    //   {\r\n    //     filter(data) {\r\n    //       return shouldIncludeThisData(data);\r\n    //     },\r\n    //   },\r\n    // ],\r\n  },\r\n  files: {\r\n    assets: true,\r\n  },\r\n  config: {\r\n    configuration: true,\r\n  },\r\n};\r\n\r\nexport const DEFAULT_VERSION_STRATEGY = 'ignore';\r\nexport const DEFAULT_SCHEMA_STRATEGY = 'strict';\r\n\r\ntype SchemaMap = Utils.String.Dict<Struct.Schema>;\r\n\r\nclass TransferEngine<\r\n  S extends ISourceProvider = ISourceProvider,\r\n  D extends IDestinationProvider = IDestinationProvider,\r\n> implements ITransferEngine\r\n{\r\n  sourceProvider: ISourceProvider;\r\n\r\n  destinationProvider: IDestinationProvider;\r\n\r\n  options: ITransferEngineOptions;\r\n\r\n  #metadata: { source?: IMetadata; destination?: IMetadata } = {};\r\n\r\n  #schema: { source?: SchemaMap; destination?: SchemaMap } = {};\r\n\r\n  // Progress of the current stage\r\n  progress: {\r\n    // metrics on the progress such as size and record count\r\n    data: TransferProgress;\r\n    // stream that emits events\r\n    stream: PassThrough;\r\n  };\r\n\r\n  diagnostics: IDiagnosticReporter;\r\n\r\n  #handlers: {\r\n    schemaDiff: SchemaDiffHandler[];\r\n    errors: Partial<ErrorHandlers>;\r\n  } = {\r\n    schemaDiff: [],\r\n    errors: {},\r\n  };\r\n\r\n  onSchemaDiff(handler: SchemaDiffHandler) {\r\n    this.#handlers?.schemaDiff?.push(handler);\r\n  }\r\n\r\n  addErrorHandler(handlerName: ErrorCode, handler: ErrorHandler) {\r\n    if (!this.#handlers.errors[handlerName]) {\r\n      this.#handlers.errors[handlerName] = [];\r\n    }\r\n    this.#handlers.errors[handlerName]?.push(handler);\r\n  }\r\n\r\n  async attemptResolveError(error: Error) {\r\n    const context: ErrorHandlerContext = {};\r\n    if (error instanceof ProviderTransferError && error.details?.details.code) {\r\n      const errorCode = error.details?.details.code as ErrorCode;\r\n      if (!this.#handlers.errors[errorCode]) {\r\n        this.#handlers.errors[errorCode] = [];\r\n      }\r\n      await utils.middleware.runMiddleware(context ?? {}, this.#handlers.errors[errorCode] ?? []);\r\n    }\r\n\r\n    return !!context.ignore;\r\n  }\r\n\r\n  // Save the currently open stream so that we can access it at any time\r\n  #currentStream?: Writable;\r\n\r\n  constructor(sourceProvider: S, destinationProvider: D, options: ITransferEngineOptions) {\r\n    this.diagnostics = createDiagnosticReporter();\r\n\r\n    validateProvider('source', sourceProvider);\r\n    validateProvider('destination', destinationProvider);\r\n\r\n    this.sourceProvider = sourceProvider;\r\n    this.destinationProvider = destinationProvider;\r\n    this.options = options;\r\n\r\n    this.progress = { data: {}, stream: new PassThrough({ objectMode: true }) };\r\n  }\r\n\r\n  /**\r\n   * Report a fatal error and throw it\r\n   */\r\n  panic(error: Error) {\r\n    this.reportError(error, 'fatal');\r\n\r\n    throw error;\r\n  }\r\n\r\n  /**\r\n   * Report an error diagnostic\r\n   */\r\n  reportError(error: Error, severity: ErrorDiagnosticSeverity) {\r\n    this.diagnostics.report({\r\n      kind: 'error',\r\n      details: {\r\n        severity,\r\n        createdAt: new Date(),\r\n        name: error.name,\r\n        message: error.message,\r\n        error,\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Report a warning diagnostic\r\n   */\r\n  reportWarning(message: string, origin?: string) {\r\n    this.diagnostics.report({\r\n      kind: 'warning',\r\n      details: { createdAt: new Date(), message, origin },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Report an info diagnostic\r\n   */\r\n  reportInfo(message: string, params?: unknown) {\r\n    this.diagnostics.report({\r\n      kind: 'info',\r\n      details: { createdAt: new Date(), message, params, origin: 'engine' },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create and return a transform stream based on the given stage and options.\r\n   *\r\n   * Allowed transformations includes 'filter' and 'map'.\r\n   */\r\n  #createStageTransformStream<T extends TransferStage>(\r\n    key: T,\r\n    options: { includeGlobal?: boolean } = {}\r\n  ): PassThrough | Transform {\r\n    const { includeGlobal = true } = options;\r\n    const { throttle } = this.options;\r\n    const { global: globalTransforms, [key]: stageTransforms } = this.options?.transforms ?? {};\r\n\r\n    let stream: PassThrough | Chain = new PassThrough({ objectMode: true });\r\n\r\n    const applyTransforms = <U>(transforms: TransferTransform<U>[] = []) => {\r\n      const chainTransforms: StreamItem[] = [];\r\n      for (const transform of transforms) {\r\n        if ('filter' in transform) {\r\n          chainTransforms.push(utils.stream.filter(transform.filter));\r\n        }\r\n\r\n        if ('map' in transform) {\r\n          chainTransforms.push(utils.stream.map(transform.map));\r\n        }\r\n      }\r\n      if (chainTransforms.length) {\r\n        stream = stream.pipe(chain(chainTransforms));\r\n      }\r\n    };\r\n\r\n    if (includeGlobal) {\r\n      applyTransforms(globalTransforms);\r\n    }\r\n\r\n    if (isNumber(throttle) && throttle > 0) {\r\n      stream = stream.pipe(\r\n        new PassThrough({\r\n          objectMode: true,\r\n          async transform(data, _encoding, callback) {\r\n            await new Promise((resolve) => {\r\n              setTimeout(resolve, throttle);\r\n            });\r\n            callback(null, data);\r\n          },\r\n        })\r\n      );\r\n    }\r\n\r\n    applyTransforms(stageTransforms as TransferTransform<unknown>[]);\r\n\r\n    return stream;\r\n  }\r\n\r\n  /**\r\n   * Update the Engine's transfer progress data for a given stage.\r\n   *\r\n   * Providing aggregate options enable custom computation to get the size (bytes) or the aggregate key associated with the data\r\n   */\r\n  #updateTransferProgress<T = unknown>(\r\n    stage: TransferStage,\r\n    data: T,\r\n    aggregate?: {\r\n      size?: (value: T) => number;\r\n      key?: (value: T) => string;\r\n    }\r\n  ) {\r\n    if (!this.progress.data[stage]) {\r\n      this.progress.data[stage] = { count: 0, bytes: 0, startTime: Date.now() };\r\n    }\r\n\r\n    const stageProgress = this.progress.data[stage];\r\n\r\n    if (!stageProgress) {\r\n      return;\r\n    }\r\n\r\n    const size = aggregate?.size?.(data) ?? JSON.stringify(data).length;\r\n    const key = aggregate?.key?.(data);\r\n\r\n    stageProgress.count += 1;\r\n    stageProgress.bytes += size;\r\n\r\n    // Handle aggregate updates if necessary\r\n    if (key) {\r\n      if (!stageProgress.aggregates) {\r\n        stageProgress.aggregates = {};\r\n      }\r\n\r\n      const { aggregates } = stageProgress;\r\n\r\n      if (!aggregates[key]) {\r\n        aggregates[key] = { count: 0, bytes: 0 };\r\n      }\r\n\r\n      aggregates[key].count += 1;\r\n      aggregates[key].bytes += size;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create and return a PassThrough stream.\r\n   *\r\n   * Upon writing data into it, it'll update the Engine's transfer progress data and trigger stage update events.\r\n   */\r\n  #progressTracker(\r\n    stage: TransferStage,\r\n    aggregate?: {\r\n      size?(value: unknown): number;\r\n      key?(value: unknown): string;\r\n    }\r\n  ) {\r\n    return new PassThrough({\r\n      objectMode: true,\r\n      transform: (data, _encoding, callback) => {\r\n        this.#updateTransferProgress(stage, data, aggregate);\r\n        this.#emitStageUpdate('progress', stage);\r\n        callback(null, data);\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Shorthand method used to trigger transfer update events to every listeners\r\n   */\r\n  #emitTransferUpdate(type: 'init' | 'start' | 'finish' | 'error', payload?: object) {\r\n    this.progress.stream.emit(`transfer::${type}`, payload);\r\n  }\r\n\r\n  /**\r\n   * Shorthand method used to trigger stage update events to every listeners\r\n   */\r\n  #emitStageUpdate(\r\n    type: 'start' | 'finish' | 'progress' | 'skip' | 'error',\r\n    transferStage: TransferStage\r\n  ) {\r\n    this.progress.stream.emit(`stage::${type}`, {\r\n      data: this.progress.data,\r\n      stage: transferStage,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Run a version check between two strapi version (source and destination) using the strategy given to the engine during initialization.\r\n   *\r\n   * If there is a mismatch, throws a validation error.\r\n   */\r\n  #assertStrapiVersionIntegrity(sourceVersion?: string, destinationVersion?: string) {\r\n    const strategy = this.options.versionStrategy || DEFAULT_VERSION_STRATEGY;\r\n\r\n    const reject = () => {\r\n      throw new TransferEngineValidationError(\r\n        `The source and destination provide are targeting incompatible Strapi versions (using the \"${strategy}\" strategy). The source (${this.sourceProvider.name}) version is ${sourceVersion} and the destination (${this.destinationProvider.name}) version is ${destinationVersion}`,\r\n        {\r\n          check: 'strapi.version',\r\n          strategy,\r\n          versions: { source: sourceVersion, destination: destinationVersion },\r\n        }\r\n      );\r\n    };\r\n\r\n    if (\r\n      !sourceVersion ||\r\n      !destinationVersion ||\r\n      strategy === 'ignore' ||\r\n      destinationVersion === sourceVersion\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    let diff;\r\n    try {\r\n      diff = semverDiff(sourceVersion, destinationVersion);\r\n    } catch {\r\n      reject();\r\n    }\r\n\r\n    if (!diff) {\r\n      return;\r\n    }\r\n\r\n    const validPatch = ['prelease', 'build'];\r\n    const validMinor = [...validPatch, 'patch', 'prepatch'];\r\n    const validMajor = [...validMinor, 'minor', 'preminor'];\r\n    if (strategy === 'patch' && validPatch.includes(diff)) {\r\n      return;\r\n    }\r\n    if (strategy === 'minor' && validMinor.includes(diff)) {\r\n      return;\r\n    }\r\n    if (strategy === 'major' && validMajor.includes(diff)) {\r\n      return;\r\n    }\r\n\r\n    reject();\r\n  }\r\n\r\n  /**\r\n   * Run a check between two set of schemas (source and destination) using the strategy given to the engine during initialization.\r\n   *\r\n   * If there are differences and/or incompatibilities between source and destination schemas, then throw a validation error.\r\n   */\r\n  #assertSchemasMatching(sourceSchemas: SchemaMap, destinationSchemas: SchemaMap) {\r\n    const strategy = this.options.schemaStrategy || DEFAULT_SCHEMA_STRATEGY;\r\n\r\n    if (strategy === 'ignore') {\r\n      return;\r\n    }\r\n\r\n    const keys = uniq(Object.keys(sourceSchemas).concat(Object.keys(destinationSchemas)));\r\n    const diffs: { [key: string]: Diff[] } = {};\r\n\r\n    keys.forEach((key) => {\r\n      const sourceSchema = sourceSchemas[key];\r\n      const destinationSchema = destinationSchemas[key];\r\n      const schemaDiffs = compareSchemas(sourceSchema, destinationSchema, strategy);\r\n\r\n      if (schemaDiffs.length) {\r\n        diffs[key] = schemaDiffs as Diff<Struct.Schema>[];\r\n      }\r\n    });\r\n\r\n    if (!isEmpty(diffs)) {\r\n      const formattedDiffs = Object.entries(diffs)\r\n        .map(([uid, ctDiffs]) => {\r\n          let msg = `- ${uid}:${EOL}`;\r\n\r\n          msg += ctDiffs\r\n            .sort((a, b) => (a.kind > b.kind ? -1 : 1))\r\n            .map((diff) => {\r\n              const path = diff.path.join('.');\r\n\r\n              if (diff.kind === 'added') {\r\n                return `${path} exists in destination schema but not in source schema and the data will not be transferred.`;\r\n              }\r\n\r\n              if (diff.kind === 'deleted') {\r\n                return `${path} exists in source schema but not in destination schema and the data will not be transferred.`;\r\n              }\r\n\r\n              if (diff.kind === 'modified') {\r\n                if (diff.types[0] === diff.types[1]) {\r\n                  return `Schema value changed at \"${path}\": \"${diff.values[0]}\" (${diff.types[0]}) => \"${diff.values[1]}\" (${diff.types[1]})`;\r\n                }\r\n\r\n                return `Schema has differing data types at \"${path}\": \"${diff.values[0]}\" (${diff.types[0]}) => \"${diff.values[1]}\" (${diff.types[1]})`;\r\n              }\r\n\r\n              throw new TransferEngineValidationError(`Invalid diff found for \"${uid}\"`, {\r\n                check: `schema on ${uid}`,\r\n              });\r\n            })\r\n            .map((line) => `  - ${line}`)\r\n            .join(EOL);\r\n\r\n          return msg;\r\n        })\r\n        .join(EOL);\r\n\r\n      throw new TransferEngineValidationError(\r\n        `Invalid schema changes detected during integrity checks (using the ${strategy} strategy). Please find a summary of the changes below:\\n${formattedDiffs}`,\r\n        {\r\n          check: 'schema.changes',\r\n          strategy,\r\n          diffs,\r\n        }\r\n      );\r\n    }\r\n  }\r\n\r\n  shouldSkipStage(stage: TransferStage) {\r\n    const { exclude, only } = this.options;\r\n\r\n    // schemas must always be included\r\n    if (stage === 'schemas') {\r\n      return false;\r\n    }\r\n\r\n    // everything is included by default unless 'only' has been set\r\n    let included = isEmpty(only);\r\n    if (only && only.length > 0) {\r\n      included = only.some((transferGroup) => {\r\n        return TransferGroupPresets[transferGroup][stage];\r\n      });\r\n    }\r\n\r\n    if (exclude && exclude.length > 0) {\r\n      if (included) {\r\n        included = !exclude.some((transferGroup) => {\r\n          return TransferGroupPresets[transferGroup][stage];\r\n        });\r\n      }\r\n    }\r\n\r\n    return !included;\r\n  }\r\n\r\n  async #transferStage(options: {\r\n    stage: TransferStage;\r\n    source?: Readable;\r\n    destination?: Writable;\r\n    transform?: PassThrough | Chain;\r\n    tracker?: PassThrough;\r\n  }) {\r\n    const { stage, source, destination, transform, tracker } = options;\r\n\r\n    const updateEndTime = () => {\r\n      const stageData = this.progress.data[stage];\r\n\r\n      if (stageData) {\r\n        stageData.endTime = Date.now();\r\n      }\r\n    };\r\n\r\n    if (!source || !destination || this.shouldSkipStage(stage)) {\r\n      // Wait until source and destination are closed\r\n      const results = await Promise.allSettled(\r\n        [source, destination].map((stream) => {\r\n          // if stream is undefined or already closed, resolve immediately\r\n          if (!stream || stream.destroyed) {\r\n            return Promise.resolve();\r\n          }\r\n\r\n          // Wait until the close event is produced and then destroy the stream and resolve\r\n          return new Promise((resolve, reject) => {\r\n            stream.on('close', resolve).on('error', reject).destroy();\r\n          });\r\n        })\r\n      );\r\n\r\n      results.forEach((state) => {\r\n        if (state.status === 'rejected') {\r\n          this.reportWarning(state.reason, `transfer(${stage})`);\r\n        }\r\n      });\r\n\r\n      this.#emitStageUpdate('skip', stage);\r\n\r\n      return;\r\n    }\r\n\r\n    this.#emitStageUpdate('start', stage);\r\n\r\n    await new Promise<void>((resolve, reject) => {\r\n      let stream: Readable = source;\r\n\r\n      if (transform) {\r\n        stream = stream.pipe(transform);\r\n      }\r\n\r\n      if (tracker) {\r\n        stream = stream.pipe(tracker);\r\n      }\r\n\r\n      this.#currentStream = stream\r\n        .pipe(destination)\r\n        .on('error', (e) => {\r\n          updateEndTime();\r\n          this.#emitStageUpdate('error', stage);\r\n          this.reportError(e, 'error');\r\n          destination.destroy(e);\r\n          reject(e);\r\n        })\r\n        .on('close', () => {\r\n          this.#currentStream = undefined;\r\n          updateEndTime();\r\n          resolve();\r\n        });\r\n    });\r\n\r\n    this.#emitStageUpdate('finish', stage);\r\n  }\r\n\r\n  // Cause an ongoing transfer to abort gracefully\r\n  async abortTransfer(): Promise<void> {\r\n    const err = new TransferEngineError('fatal', 'Transfer aborted.');\r\n    if (!this.#currentStream) {\r\n      throw err;\r\n    }\r\n    this.#currentStream.destroy(err);\r\n  }\r\n\r\n  async init(): Promise<void> {\r\n    // Resolve providers' resource and store\r\n    // them in the engine's internal state\r\n    await this.#resolveProviderResource();\r\n\r\n    // Update the destination provider's source metadata\r\n    const { source: sourceMetadata } = this.#metadata;\r\n\r\n    if (sourceMetadata) {\r\n      this.destinationProvider.setMetadata?.('source', sourceMetadata);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Run the bootstrap method in both source and destination providers\r\n   */\r\n  async bootstrap(): Promise<void> {\r\n    const results = await Promise.allSettled([\r\n      this.sourceProvider.bootstrap?.(this.diagnostics),\r\n      this.destinationProvider.bootstrap?.(this.diagnostics),\r\n    ]);\r\n\r\n    results.forEach((result) => {\r\n      if (result.status === 'rejected') {\r\n        this.panic(result.reason);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Run the close method in both source and destination providers\r\n   */\r\n  async close(): Promise<void> {\r\n    const results = await Promise.allSettled([\r\n      this.sourceProvider.close?.(),\r\n      this.destinationProvider.close?.(),\r\n    ]);\r\n\r\n    results.forEach((result) => {\r\n      if (result.status === 'rejected') {\r\n        this.panic(result.reason);\r\n      }\r\n    });\r\n  }\r\n\r\n  async #resolveProviderResource() {\r\n    const sourceMetadata = await this.sourceProvider.getMetadata();\r\n    const destinationMetadata = await this.destinationProvider.getMetadata();\r\n\r\n    if (sourceMetadata) {\r\n      this.#metadata.source = sourceMetadata;\r\n    }\r\n\r\n    if (destinationMetadata) {\r\n      this.#metadata.destination = destinationMetadata;\r\n    }\r\n  }\r\n\r\n  async #getSchemas() {\r\n    if (!this.#schema.source) {\r\n      this.#schema.source = (await this.sourceProvider.getSchemas?.()) as SchemaMap;\r\n    }\r\n\r\n    if (!this.#schema.destination) {\r\n      this.#schema.destination = (await this.destinationProvider.getSchemas?.()) as SchemaMap;\r\n    }\r\n\r\n    return {\r\n      sourceSchemas: this.#schema.source,\r\n      destinationSchemas: this.#schema.destination,\r\n    };\r\n  }\r\n\r\n  async integrityCheck() {\r\n    const sourceMetadata = await this.sourceProvider.getMetadata();\r\n    const destinationMetadata = await this.destinationProvider.getMetadata();\r\n\r\n    if (sourceMetadata && destinationMetadata) {\r\n      this.#assertStrapiVersionIntegrity(\r\n        sourceMetadata?.strapi?.version,\r\n        destinationMetadata?.strapi?.version\r\n      );\r\n    }\r\n\r\n    const { sourceSchemas, destinationSchemas } = await this.#getSchemas();\r\n\r\n    try {\r\n      if (sourceSchemas && destinationSchemas) {\r\n        this.#assertSchemasMatching(sourceSchemas, destinationSchemas);\r\n      }\r\n    } catch (error) {\r\n      // if this is a schema matching error, allow handlers to resolve it\r\n      if (error instanceof TransferEngineValidationError && error.details?.details?.diffs) {\r\n        const schemaDiffs = error.details?.details?.diffs as Record<string, Diff[]>;\r\n\r\n        const context: SchemaDiffHandlerContext = {\r\n          ignoredDiffs: {},\r\n          diffs: schemaDiffs,\r\n          source: this.sourceProvider,\r\n          destination: this.destinationProvider,\r\n        };\r\n\r\n        // if we don't have any handlers, throw the original error\r\n        if (isEmpty(this.#handlers.schemaDiff)) {\r\n          throw error;\r\n        }\r\n\r\n        await utils.middleware.runMiddleware<SchemaDiffHandlerContext>(\r\n          context,\r\n          this.#handlers.schemaDiff\r\n        );\r\n\r\n        // if there are any remaining diffs that weren't ignored\r\n        const unresolvedDiffs = utils.json.diff(context.diffs, context.ignoredDiffs);\r\n        if (unresolvedDiffs.length) {\r\n          this.panic(\r\n            new TransferEngineValidationError('Unresolved differences in schema', {\r\n              check: 'schema.changes',\r\n              unresolvedDiffs,\r\n            })\r\n          );\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async transfer(): Promise<ITransferResults<S, D>> {\r\n    // reset data between transfers\r\n    this.progress.data = {};\r\n\r\n    try {\r\n      this.#emitTransferUpdate('init');\r\n      await this.bootstrap();\r\n      await this.init();\r\n\r\n      await this.integrityCheck();\r\n\r\n      this.#emitTransferUpdate('start');\r\n\r\n      await this.beforeTransfer();\r\n\r\n      // Run the transfer stages\r\n      await this.transferSchemas();\r\n      await this.transferEntities();\r\n      await this.transferAssets();\r\n      await this.transferLinks();\r\n      await this.transferConfiguration();\r\n      // Gracefully close the providers\r\n      await this.close();\r\n\r\n      this.#emitTransferUpdate('finish');\r\n    } catch (e: unknown) {\r\n      this.#emitTransferUpdate('error', { error: e });\r\n\r\n      const lastDiagnostic = last(this.diagnostics.stack.items);\r\n      // Do not report an error diagnostic if the last one reported the same error\r\n      if (\r\n        e instanceof Error &&\r\n        (!lastDiagnostic || lastDiagnostic.kind !== 'error' || lastDiagnostic.details.error !== e)\r\n      ) {\r\n        this.reportError(e, (e as DataTransferError).severity || 'fatal');\r\n      }\r\n\r\n      // Rollback the destination provider if an exception is thrown during the transfer\r\n      // Note: This will be configurable in the future\r\n      await this.destinationProvider.rollback?.(e as Error);\r\n\r\n      throw e;\r\n    }\r\n\r\n    return {\r\n      source: this.sourceProvider.results,\r\n      destination: this.destinationProvider.results,\r\n      engine: this.progress.data,\r\n    };\r\n  }\r\n\r\n  async beforeTransfer(): Promise<void> {\r\n    const runWithDiagnostic = async (provider: IProvider) => {\r\n      try {\r\n        await provider.beforeTransfer?.();\r\n      } catch (error) {\r\n        if (error instanceof Error) {\r\n          const resolved = await this.attemptResolveError(error);\r\n\r\n          if (resolved) {\r\n            return;\r\n          }\r\n          this.panic(error);\r\n        } else {\r\n          this.panic(\r\n            new Error(`Unknwon error when executing \"beforeTransfer\" on the ${origin} provider`)\r\n          );\r\n        }\r\n      }\r\n    };\r\n\r\n    await runWithDiagnostic(this.sourceProvider);\r\n    await runWithDiagnostic(this.destinationProvider);\r\n  }\r\n\r\n  async transferSchemas(): Promise<void> {\r\n    const stage: TransferStage = 'schemas';\r\n    if (this.shouldSkipStage(stage)) {\r\n      return;\r\n    }\r\n\r\n    const source = await this.sourceProvider.createSchemasReadStream?.();\r\n    const destination = await this.destinationProvider.createSchemasWriteStream?.();\r\n\r\n    const transform = this.#createStageTransformStream(stage);\r\n    const tracker = this.#progressTracker(stage, {\r\n      key: (value: Struct.Schema) => value.modelType,\r\n    });\r\n\r\n    await this.#transferStage({ stage, source, destination, transform, tracker });\r\n  }\r\n\r\n  async transferEntities(): Promise<void> {\r\n    const stage: TransferStage = 'entities';\r\n    if (this.shouldSkipStage(stage)) {\r\n      return;\r\n    }\r\n\r\n    const source = await this.sourceProvider.createEntitiesReadStream?.();\r\n    const destination = await this.destinationProvider.createEntitiesWriteStream?.();\r\n\r\n    const transform = chain([\r\n      this.#createStageTransformStream(stage),\r\n      new Transform({\r\n        objectMode: true,\r\n        transform: async (entity: IEntity, _encoding, callback) => {\r\n          const { destinationSchemas: schemas } = await this.#getSchemas();\r\n\r\n          if (!schemas) {\r\n            return callback(null, entity);\r\n          }\r\n\r\n          // TODO: this would be safer if we only ignored things in ignoredDiffs, otherwise continue and let an error be thrown\r\n          const availableContentTypes = Object.entries(schemas)\r\n            .filter(([, schema]) => schema.modelType === 'contentType')\r\n            .map(([uid]) => uid);\r\n\r\n          // If the type of the transferred entity doesn't exist in the destination, then discard it\r\n          if (!availableContentTypes.includes(entity.type)) {\r\n            return callback(null, undefined);\r\n          }\r\n\r\n          const { type, data } = entity;\r\n          const attributes = schemas[type].attributes;\r\n          const attributesToKeep = Object.keys(attributes).concat('documentId');\r\n          const updatedEntity = set('data', pick(attributesToKeep, data), entity);\r\n\r\n          callback(null, updatedEntity);\r\n        },\r\n      }),\r\n    ]);\r\n\r\n    const tracker = this.#progressTracker(stage, { key: (value: IEntity) => value.type });\r\n\r\n    await this.#transferStage({ stage, source, destination, transform, tracker });\r\n  }\r\n\r\n  async transferLinks(): Promise<void> {\r\n    const stage: TransferStage = 'links';\r\n    if (this.shouldSkipStage(stage)) {\r\n      return;\r\n    }\r\n\r\n    const source = await this.sourceProvider.createLinksReadStream?.();\r\n    const destination = await this.destinationProvider.createLinksWriteStream?.();\r\n\r\n    const transform = chain([\r\n      this.#createStageTransformStream(stage),\r\n      new Transform({\r\n        objectMode: true,\r\n        transform: async (link: ILink, _encoding, callback) => {\r\n          const { destinationSchemas: schemas } = await this.#getSchemas();\r\n          if (!schemas) {\r\n            return callback(null, link);\r\n          }\r\n\r\n          // TODO: this would be safer if we only ignored things in ignoredDiffs, otherwise continue and let an error be thrown\r\n          const availableContentTypes = Object.keys(schemas);\r\n\r\n          const isValidType = (uid: string) => availableContentTypes.includes(uid);\r\n\r\n          if (!isValidType(link.left.type) || !isValidType(link.right.type)) {\r\n            return callback(null, undefined); // ignore the link\r\n          }\r\n\r\n          callback(null, link);\r\n        },\r\n      }),\r\n    ]);\r\n\r\n    const tracker = this.#progressTracker(stage);\r\n\r\n    await this.#transferStage({ stage, source, destination, transform, tracker });\r\n  }\r\n\r\n  async transferAssets(): Promise<void> {\r\n    const stage: TransferStage = 'assets';\r\n    if (this.shouldSkipStage(stage)) {\r\n      return;\r\n    }\r\n\r\n    const source = await this.sourceProvider.createAssetsReadStream?.();\r\n    const destination = await this.destinationProvider.createAssetsWriteStream?.();\r\n\r\n    const transform = this.#createStageTransformStream(stage);\r\n    const tracker = this.#progressTracker(stage, {\r\n      size: (value: IAsset) => value.stats.size,\r\n      key: (value: IAsset) => extname(value.filename) || 'No extension',\r\n    });\r\n\r\n    await this.#transferStage({ stage, source, destination, transform, tracker });\r\n  }\r\n\r\n  async transferConfiguration(): Promise<void> {\r\n    const stage: TransferStage = 'configuration';\r\n    if (this.shouldSkipStage(stage)) {\r\n      return;\r\n    }\r\n\r\n    const source = await this.sourceProvider.createConfigurationReadStream?.();\r\n    const destination = await this.destinationProvider.createConfigurationWriteStream?.();\r\n\r\n    const transform = this.#createStageTransformStream(stage);\r\n    const tracker = this.#progressTracker(stage);\r\n\r\n    await this.#transferStage({ stage, source, destination, transform, tracker });\r\n  }\r\n}\r\n\r\nexport const createTransferEngine = <S extends ISourceProvider, D extends IDestinationProvider>(\r\n  sourceProvider: S,\r\n  destinationProvider: D,\r\n  options: ITransferEngineOptions\r\n): TransferEngine<S, D> => {\r\n  return new TransferEngine<S, D>(sourceProvider, destinationProvider, options);\r\n};\r\n\r\nexport type {\r\n  TransferEngine,\r\n  ITransferEngine,\r\n  ITransferEngineOptions,\r\n  ISourceProvider,\r\n  IDestinationProvider,\r\n  TransferStage,\r\n  TransferFilterPreset,\r\n  ErrorHandlerContext,\r\n  SchemaDiffHandlerContext,\r\n  ITransferResults,\r\n};\r\n\r\nexport * as errors from './errors';\r\n","import _ from 'lodash';\r\nimport { get, has, omit, pipe, assign } from 'lodash/fp';\r\n\r\nimport { contentTypes as contentTypesUtils, async, errors } from '@strapi/utils';\r\nimport type { Modules, UID, Data, Utils, Schema, Core } from '@strapi/types';\r\n\r\ntype LoadedComponents<TUID extends UID.Schema> = Data.Entity<\r\n  TUID,\r\n  Schema.AttributeNamesByType<TUID, 'component' | 'dynamiczone'>\r\n>;\r\n\r\ntype ComponentValue = Schema.Attribute.Value<\r\n  Schema.Attribute.Component<UID.Component, false> | Schema.Attribute.Component<UID.Component, true>\r\n>;\r\n\r\ntype ComponentBody = {\r\n  [key: string]: Schema.Attribute.Value<\r\n    | Schema.Attribute.Component<UID.Component, false>\r\n    | Schema.Attribute.Component<UID.Component, true>\r\n    | Schema.Attribute.DynamicZone\r\n  >;\r\n};\r\n\r\nconst isDialectMySQL = () => strapi.db?.dialect.client === 'mysql';\r\n\r\nfunction omitComponentData(\r\n  contentType: Schema.ContentType,\r\n  data: Modules.EntityService.Params.Data.Input<Schema.ContentType['uid']>\r\n): Partial<Modules.EntityService.Params.Data.Input<Schema.ContentType['uid']>>;\r\nfunction omitComponentData(\r\n  contentType: Schema.Component,\r\n  data: Modules.EntityService.Params.Data.Input<Schema.Component['uid']>\r\n): Partial<Modules.EntityService.Params.Data.Input<Schema.Component['uid']>>;\r\nfunction omitComponentData(\r\n  contentType: Schema.ContentType | Schema.Component,\r\n  data: Modules.EntityService.Params.Data.Input<Schema.ContentType['uid'] | Schema.Component['uid']>\r\n): Partial<\r\n  Modules.EntityService.Params.Data.Input<Schema.ContentType['uid'] | Schema.Component['uid']>\r\n> {\r\n  const { attributes } = contentType;\r\n  const componentAttributes = Object.keys(attributes).filter((attributeName) =>\r\n    contentTypesUtils.isComponentAttribute(attributes[attributeName])\r\n  );\r\n\r\n  return omit(componentAttributes, data);\r\n}\r\n\r\n// NOTE: we could generalize the logic to allow CRUD of relation directly in the DB layer\r\nconst createComponents = async <\r\n  TUID extends UID.Schema,\r\n  TData extends Modules.EntityService.Params.Data.Input<TUID>,\r\n>(\r\n  uid: TUID,\r\n  data: TData\r\n) => {\r\n  const { attributes = {} } = strapi.getModel(uid);\r\n\r\n  const componentBody: ComponentBody = {};\r\n\r\n  const attributeNames = Object.keys(attributes);\r\n\r\n  for (const attributeName of attributeNames) {\r\n    const attribute = attributes[attributeName];\r\n\r\n    if (!has(attributeName, data) || !contentTypesUtils.isComponentAttribute(attribute)) {\r\n      continue;\r\n    }\r\n\r\n    if (attribute.type === 'component') {\r\n      const { component: componentUID, repeatable = false } = attribute;\r\n\r\n      const componentValue = data[attributeName as keyof TData];\r\n\r\n      if (componentValue === null) {\r\n        continue;\r\n      }\r\n\r\n      if (repeatable === true) {\r\n        if (!Array.isArray(componentValue)) {\r\n          throw new Error('Expected an array to create repeatable component');\r\n        }\r\n\r\n        // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\r\n        const components = (await async.map(\r\n          componentValue,\r\n          (value: any) => createComponent(componentUID, value),\r\n          { concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity }\r\n        )) as Schema.Attribute.Value<Schema.Attribute.Component<UID.Component, true>>;\r\n\r\n        componentBody[attributeName] = components.map(({ id }) => {\r\n          return {\r\n            id,\r\n            __pivot: {\r\n              field: attributeName,\r\n              component_type: componentUID,\r\n            },\r\n          };\r\n        });\r\n      } else {\r\n        const component = await createComponent(\r\n          componentUID,\r\n          componentValue as Modules.EntityService.Params.Data.Input<UID.Component>\r\n        );\r\n        componentBody[attributeName] = {\r\n          id: component.id,\r\n          __pivot: {\r\n            field: attributeName,\r\n            component_type: componentUID,\r\n          },\r\n        };\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    if (attribute.type === 'dynamiczone') {\r\n      const dynamiczoneValues = data[\r\n        attributeName as keyof TData\r\n      ] as Modules.EntityService.Params.Attribute.GetValue<Schema.Attribute.DynamicZone>;\r\n\r\n      if (!Array.isArray(dynamiczoneValues)) {\r\n        throw new Error('Expected an array to create repeatable component');\r\n      }\r\n\r\n      const createDynamicZoneComponents = async (\r\n        value: Utils.Array.Values<typeof dynamiczoneValues>\r\n      ) => {\r\n        const { id } = await createComponent(value.__component, value);\r\n        return {\r\n          id,\r\n          __component: value.__component,\r\n          __pivot: {\r\n            field: attributeName,\r\n          },\r\n        };\r\n      };\r\n\r\n      // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\r\n      componentBody[attributeName] = await async.map(\r\n        dynamiczoneValues,\r\n        createDynamicZoneComponents,\r\n        { concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity }\r\n      );\r\n\r\n      continue;\r\n    }\r\n  }\r\n\r\n  return componentBody;\r\n};\r\n\r\nconst getComponents = async <TUID extends UID.Schema>(\r\n  uid: TUID,\r\n  entity: { id: Modules.EntityService.Params.Attribute.ID }\r\n): Promise<LoadedComponents<TUID>> => {\r\n  const componentAttributes = contentTypesUtils.getComponentAttributes(strapi.getModel(uid));\r\n\r\n  if (_.isEmpty(componentAttributes)) {\r\n    return {} as LoadedComponents<TUID>;\r\n  }\r\n\r\n  return strapi.db.query(uid).load(entity, componentAttributes) as Promise<LoadedComponents<TUID>>;\r\n};\r\n\r\n/*\r\n  delete old components\r\n  create or update\r\n*/\r\nconst updateComponents = async <\r\n  TUID extends UID.Schema,\r\n  TData extends Partial<Modules.EntityService.Params.Data.Input<TUID>>,\r\n>(\r\n  uid: TUID,\r\n  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\r\n  data: TData\r\n) => {\r\n  const { attributes = {} } = strapi.getModel(uid);\r\n\r\n  const componentBody: ComponentBody = {};\r\n\r\n  for (const attributeName of Object.keys(attributes)) {\r\n    const attribute = attributes[attributeName];\r\n\r\n    if (!has(attributeName, data)) {\r\n      continue;\r\n    }\r\n\r\n    if (attribute.type === 'component') {\r\n      const { component: componentUID, repeatable = false } = attribute;\r\n\r\n      const componentValue = data[\r\n        attributeName as keyof TData\r\n      ] as Schema.Attribute.Value<Schema.Attribute.Component>;\r\n\r\n      await deleteOldComponents(uid, componentUID, entityToUpdate, attributeName, componentValue);\r\n\r\n      if (repeatable === true) {\r\n        if (!Array.isArray(componentValue)) {\r\n          throw new Error('Expected an array to create repeatable component');\r\n        }\r\n\r\n        // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\r\n        const components = (await async.map(\r\n          componentValue,\r\n          (value: any) => updateOrCreateComponent(componentUID, value),\r\n          { concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity }\r\n        )) as Schema.Attribute.Value<Schema.Attribute.Component<UID.Component, true>>;\r\n\r\n        componentBody[attributeName] = components.filter(_.negate(_.isNil)).map(({ id }) => {\r\n          return {\r\n            id,\r\n            __pivot: {\r\n              field: attributeName,\r\n              component_type: componentUID,\r\n            },\r\n          };\r\n        });\r\n      } else {\r\n        const component = await updateOrCreateComponent(componentUID, componentValue);\r\n        componentBody[attributeName] = component && {\r\n          id: component.id,\r\n          __pivot: {\r\n            field: attributeName,\r\n            component_type: componentUID,\r\n          },\r\n        };\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    if (attribute.type === 'dynamiczone') {\r\n      const dynamiczoneValues = data[\r\n        attributeName as keyof TData\r\n      ] as Schema.Attribute.Value<Schema.Attribute.DynamicZone>;\r\n\r\n      await deleteOldDZComponents(uid, entityToUpdate, attributeName, dynamiczoneValues);\r\n\r\n      if (!Array.isArray(dynamiczoneValues)) {\r\n        throw new Error('Expected an array to create repeatable component');\r\n      }\r\n\r\n      // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\r\n      componentBody[attributeName] = await async.map(\r\n        dynamiczoneValues,\r\n        async (value: any) => {\r\n          const { id } = await updateOrCreateComponent(value.__component, value);\r\n\r\n          return {\r\n            id,\r\n            __component: value.__component,\r\n            __pivot: {\r\n              field: attributeName,\r\n            },\r\n          };\r\n        },\r\n        { concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity }\r\n      );\r\n\r\n      continue;\r\n    }\r\n  }\r\n\r\n  return componentBody;\r\n};\r\n\r\nconst pickStringifiedId = ({\r\n  id,\r\n}: {\r\n  id: Modules.EntityService.Params.Attribute.ID;\r\n}): Modules.EntityService.Params.Attribute.ID & string => {\r\n  if (typeof id === 'string') {\r\n    return id;\r\n  }\r\n\r\n  return `${id}`;\r\n};\r\n\r\nconst deleteOldComponents = async <TUID extends UID.Schema>(\r\n  uid: TUID,\r\n  componentUID: UID.Component,\r\n  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\r\n  attributeName: string,\r\n  componentValue: Schema.Attribute.Value<Schema.Attribute.Component>\r\n) => {\r\n  const previousValue = (await strapi.db\r\n    .query(uid)\r\n    .load(entityToUpdate, attributeName)) as ComponentValue;\r\n\r\n  const idsToKeep = _.castArray(componentValue).filter(has('id')).map(pickStringifiedId);\r\n  const allIds = _.castArray(previousValue).filter(has('id')).map(pickStringifiedId);\r\n\r\n  idsToKeep.forEach((id) => {\r\n    if (!allIds.includes(id)) {\r\n      throw new errors.ApplicationError(\r\n        `Some of the provided components in ${attributeName} are not related to the entity`\r\n      );\r\n    }\r\n  });\r\n\r\n  const idsToDelete = _.difference(allIds, idsToKeep);\r\n\r\n  if (idsToDelete.length > 0) {\r\n    for (const idToDelete of idsToDelete) {\r\n      await deleteComponent(componentUID, { id: idToDelete });\r\n    }\r\n  }\r\n};\r\n\r\nconst deleteOldDZComponents = async <TUID extends UID.Schema>(\r\n  uid: TUID,\r\n  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\r\n  attributeName: string,\r\n  dynamiczoneValues: Schema.Attribute.Value<Schema.Attribute.DynamicZone>\r\n) => {\r\n  const previousValue = (await strapi.db\r\n    .query(uid)\r\n    .load(entityToUpdate, attributeName)) as Schema.Attribute.Value<Schema.Attribute.DynamicZone>;\r\n\r\n  const idsToKeep = _.castArray(dynamiczoneValues)\r\n    .filter(has('id'))\r\n    .map((v) => ({\r\n      id: pickStringifiedId(v),\r\n      __component: v.__component,\r\n    }));\r\n\r\n  const allIds = _.castArray(previousValue)\r\n    .filter(has('id'))\r\n    .map((v) => ({\r\n      id: pickStringifiedId(v),\r\n      __component: v.__component,\r\n    }));\r\n\r\n  idsToKeep.forEach(({ id, __component }) => {\r\n    if (!allIds.find((el) => el.id === id && el.__component === __component)) {\r\n      const err = new Error(\r\n        `Some of the provided components in ${attributeName} are not related to the entity`\r\n      );\r\n\r\n      Object.assign(err, { status: 400 });\r\n      throw err;\r\n    }\r\n  });\r\n\r\n  type IdsToDelete = Schema.Attribute.Value<Schema.Attribute.DynamicZone>;\r\n\r\n  const idsToDelete = allIds.reduce((acc, { id, __component }) => {\r\n    if (!idsToKeep.find((el) => el.id === id && el.__component === __component)) {\r\n      acc.push({ id, __component });\r\n    }\r\n\r\n    return acc;\r\n  }, [] as IdsToDelete);\r\n\r\n  if (idsToDelete.length > 0) {\r\n    for (const idToDelete of idsToDelete) {\r\n      const { id, __component } = idToDelete;\r\n      await deleteComponent(__component, { id });\r\n    }\r\n  }\r\n};\r\n\r\nconst deleteComponents = async <TUID extends UID.Schema, TEntity extends Data.Entity<TUID>>(\r\n  uid: TUID,\r\n  entityToDelete: TEntity,\r\n  { loadComponents = true } = {}\r\n) => {\r\n  const { attributes = {} } = strapi.getModel(uid);\r\n\r\n  const attributeNames = Object.keys(attributes);\r\n\r\n  for (const attributeName of attributeNames) {\r\n    const attribute = attributes[attributeName];\r\n\r\n    if (attribute.type === 'component' || attribute.type === 'dynamiczone') {\r\n      let value;\r\n      if (loadComponents) {\r\n        value = await strapi.db.query(uid).load(entityToDelete, attributeName);\r\n      } else {\r\n        value = entityToDelete[attributeName as keyof TEntity];\r\n      }\r\n\r\n      if (!value) {\r\n        continue;\r\n      }\r\n\r\n      if (attribute.type === 'component') {\r\n        const { component: componentUID } = attribute;\r\n        // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\r\n        await async.map(\r\n          _.castArray(value),\r\n          (subValue: any) => deleteComponent(componentUID, subValue),\r\n          {\r\n            concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity,\r\n          }\r\n        );\r\n      } else {\r\n        // delete dynamic zone components\r\n        // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\r\n        await async.map(\r\n          _.castArray(value),\r\n          (subValue: any) => deleteComponent(subValue.__component, subValue),\r\n          { concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity }\r\n        );\r\n      }\r\n\r\n      continue;\r\n    }\r\n  }\r\n};\r\n\r\n/** *************************\r\n    Component queries\r\n************************** */\r\n\r\n// components can have nested compos so this must be recursive\r\nconst createComponent = async <TUID extends UID.Component = UID.Component>(\r\n  uid: TUID,\r\n  data: Modules.EntityService.Params.Data.Input<TUID>\r\n) => {\r\n  const model = strapi.getModel(uid) as Schema.Component;\r\n\r\n  const componentData = await createComponents(uid, data);\r\n  const transform = pipe(\r\n    // Make sure we don't save the component with a pre-defined ID\r\n    omit('id'),\r\n    // Remove the component data from the original data object ...\r\n    (payload) => omitComponentData(model, payload),\r\n    // ... and assign the newly created component instead\r\n    assign(componentData)\r\n  );\r\n\r\n  return strapi.db.query(uid).create({ data: transform(data) });\r\n};\r\n\r\n// components can have nested compos so this must be recursive\r\nconst updateComponent = async <TUID extends UID.Component>(\r\n  uid: TUID,\r\n  componentToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\r\n  data: Modules.EntityService.Params.Data.Input<TUID>\r\n) => {\r\n  const model = strapi.getModel(uid) as Schema.Component;\r\n\r\n  const componentData = await updateComponents(uid, componentToUpdate, data);\r\n\r\n  return strapi.db.query(uid).update({\r\n    where: {\r\n      id: componentToUpdate.id,\r\n    },\r\n    data: Object.assign(omitComponentData(model, data), componentData),\r\n  });\r\n};\r\n\r\nconst updateOrCreateComponent = <TUID extends UID.Component>(\r\n  componentUID: TUID,\r\n  value: Modules.EntityService.Params.Data.Input<TUID>\r\n) => {\r\n  if (value === null) {\r\n    return null;\r\n  }\r\n\r\n  // update\r\n  if ('id' in value && typeof value.id !== 'undefined') {\r\n    // TODO: verify the compo is associated with the entity\r\n    return updateComponent(componentUID, { id: value.id }, value);\r\n  }\r\n\r\n  // create\r\n  return createComponent(componentUID, value);\r\n};\r\n\r\nconst deleteComponent = async <TUID extends UID.Component>(\r\n  uid: TUID,\r\n  componentToDelete: Data.Component<TUID>\r\n) => {\r\n  await deleteComponents(uid, componentToDelete);\r\n  await strapi.db.query(uid).delete({ where: { id: componentToDelete.id } });\r\n};\r\n\r\n/**\r\n * Resolve the component UID of an entity's attribute based\r\n * on a given path (components & dynamic zones only)\r\n */\r\nconst resolveComponentUID = ({\r\n  paths,\r\n  strapi,\r\n  data,\r\n  contentType,\r\n}: {\r\n  paths: string[];\r\n  strapi: Core.Strapi;\r\n  data: any;\r\n  contentType: Schema.ContentType;\r\n}): UID.Schema | undefined => {\r\n  let value: unknown = data;\r\n  let cType:\r\n    | Schema.ContentType\r\n    | Schema.Component\r\n    | ((...opts: any[]) => Schema.ContentType | Schema.Component) = contentType;\r\n  for (const path of paths) {\r\n    value = get(path, value);\r\n\r\n    // Needed when the value of cType should be computed\r\n    // based on the next value (eg: dynamic zones)\r\n    if (typeof cType === 'function') {\r\n      cType = cType(value);\r\n    }\r\n\r\n    if (path in cType.attributes) {\r\n      const attribute: Schema.Attribute.AnyAttribute = cType.attributes[path];\r\n\r\n      if (attribute.type === 'component') {\r\n        cType = strapi.getModel(attribute.component);\r\n      }\r\n\r\n      if (attribute.type === 'dynamiczone') {\r\n        cType = ({ __component }: { __component: UID.Component }) => strapi.getModel(__component);\r\n      }\r\n    }\r\n  }\r\n\r\n  if ('uid' in cType) {\r\n    return cType.uid;\r\n  }\r\n\r\n  return undefined;\r\n};\r\n\r\nexport {\r\n  omitComponentData,\r\n  getComponents,\r\n  createComponents,\r\n  updateComponents,\r\n  deleteComponents,\r\n  deleteComponent,\r\n  resolveComponentUID,\r\n};\r\n","import { assign, isArray, isEmpty, isObject, map, omit, size } from 'lodash/fp';\r\n\r\nimport type { Core, UID, Data, Struct } from '@strapi/types';\r\nimport * as componentsService from '../../utils/components';\r\n\r\nconst sanitizeComponentLikeAttributes = <T extends Struct.Schema>(\r\n  model: T,\r\n  data: Data.Entity<T['uid']>\r\n) => {\r\n  const { attributes } = model;\r\n\r\n  const componentLikeAttributesKey = Object.entries(attributes)\r\n    .filter(([, attribute]) => attribute.type === 'component' || attribute.type === 'dynamiczone')\r\n    .map(([key]) => key);\r\n\r\n  return omit(componentLikeAttributesKey, data);\r\n};\r\n\r\nconst omitInvalidCreationAttributes = omit(['id']);\r\n\r\nconst createEntityQuery = (strapi: Core.Strapi): any => {\r\n  const components = {\r\n    async assignToEntity(uid: UID.Schema, data: any) {\r\n      const model = strapi.getModel(uid);\r\n\r\n      const entityComponents = await componentsService.createComponents(uid, data);\r\n      const dataWithoutComponents = sanitizeComponentLikeAttributes(model, data);\r\n\r\n      return assign(entityComponents, dataWithoutComponents);\r\n    },\r\n\r\n    async get<T extends object>(uid: string, entity: T) {\r\n      return componentsService.getComponents(uid as UID.Schema, entity as any);\r\n    },\r\n\r\n    delete<T extends object>(uid: string, componentsToDelete: T) {\r\n      return componentsService.deleteComponents(uid as UID.Schema, componentsToDelete as any, {\r\n        loadComponents: false,\r\n      });\r\n    },\r\n  };\r\n\r\n  const query = (uid: UID.Schema) => {\r\n    const create = async <T extends { data: U }, U extends object>(params: T) => {\r\n      const dataWithComponents = await components.assignToEntity(uid, params.data);\r\n      const sanitizedData = omitInvalidCreationAttributes(dataWithComponents);\r\n\r\n      return strapi.db.query(uid).create({ ...params, data: sanitizedData });\r\n    };\r\n\r\n    const createMany = async <T extends { data: U[] }, U extends object>(params: T) => {\r\n      return (\r\n        Promise.resolve(params.data)\r\n          // Create components for each entity\r\n          .then(map((data) => components.assignToEntity(uid, data)))\r\n          // Remove unwanted attributes\r\n          .then(map(omitInvalidCreationAttributes))\r\n          // Execute a strapi db createMany query with all the entities + their created components\r\n          .then((data) => strapi.db.query(uid).createMany({ ...params, data }))\r\n      );\r\n    };\r\n\r\n    const deleteMany = async <T extends object>(params?: T) => {\r\n      const entitiesToDelete = await strapi.db.query(uid).findMany(params ?? {});\r\n\r\n      if (!entitiesToDelete.length) {\r\n        return null;\r\n      }\r\n\r\n      const componentsToDelete = await Promise.all(\r\n        entitiesToDelete.map((entityToDelete) => components.get(uid, entityToDelete))\r\n      );\r\n\r\n      const deletedEntities = await strapi.db.query(uid).deleteMany(params);\r\n      await Promise.all(componentsToDelete.map((compos) => components.delete(uid, compos)));\r\n\r\n      return deletedEntities;\r\n    };\r\n\r\n    const getDeepPopulateComponentLikeQuery = (\r\n      contentType: Struct.Schema,\r\n      params = { select: '*' }\r\n    ) => {\r\n      const { attributes } = contentType;\r\n\r\n      const populate: any = {};\r\n\r\n      const entries: [string, any][] = Object.entries(attributes);\r\n\r\n      for (const [key, attribute] of entries) {\r\n        if (attribute.type === 'component') {\r\n          const component = strapi.getModel(attribute.component);\r\n          const subPopulate = getDeepPopulateComponentLikeQuery(component, params);\r\n\r\n          if ((isArray(subPopulate) || isObject(subPopulate)) && size(subPopulate) > 0) {\r\n            populate[key] = { ...params, populate: subPopulate };\r\n          }\r\n\r\n          if (isArray(subPopulate) && isEmpty(subPopulate)) {\r\n            populate[key] = { ...params };\r\n          }\r\n        }\r\n\r\n        if (attribute.type === 'dynamiczone') {\r\n          const { components: componentsUID } = attribute;\r\n\r\n          const on: any = {};\r\n\r\n          for (const componentUID of componentsUID) {\r\n            const component = strapi.getModel(componentUID);\r\n            const subPopulate = getDeepPopulateComponentLikeQuery(component, params);\r\n\r\n            if ((isArray(subPopulate) || isObject(subPopulate)) && size(subPopulate) > 0) {\r\n              on[componentUID] = { ...params, populate: subPopulate };\r\n            }\r\n\r\n            if (isArray(subPopulate) && isEmpty(subPopulate)) {\r\n              on[componentUID] = { ...params };\r\n            }\r\n          }\r\n\r\n          populate[key] = size(on) > 0 ? { on } : true;\r\n        }\r\n      }\r\n\r\n      const values = Object.values(populate);\r\n\r\n      if (values.every((value) => value === true)) {\r\n        return Object.keys(populate);\r\n      }\r\n\r\n      return populate;\r\n    };\r\n\r\n    return {\r\n      create,\r\n      createMany,\r\n      deleteMany,\r\n      getDeepPopulateComponentLikeQuery,\r\n\r\n      get deepPopulateComponentLikeQuery() {\r\n        const contentType = strapi.getModel(uid);\r\n\r\n        return getDeepPopulateComponentLikeQuery(contentType);\r\n      },\r\n    };\r\n  };\r\n\r\n  return query;\r\n};\r\n\r\nexport { createEntityQuery };\r\n","import type { Knex } from 'knex';\r\nimport { clone, isNil } from 'lodash/fp';\r\nimport type { Core } from '@strapi/types';\r\n\r\nimport { ILink } from '../../../types';\r\n\r\n// TODO: Remove any types when we'll have types for DB metadata\r\n\r\nexport const createLinkQuery = (strapi: Core.Strapi, trx?: Knex.Transaction) => {\r\n  const query = () => {\r\n    const { connection } = strapi.db;\r\n\r\n    // TODO: Export utils from database and use the addSchema that is already written\r\n    const addSchema = (tableName: string) => {\r\n      const schemaName = connection.client.connectionSettings.schema;\r\n      return schemaName ? `${schemaName}.${tableName}` : tableName;\r\n    };\r\n\r\n    async function* generateAllForAttribute(uid: string, fieldName: string): AsyncGenerator<ILink> {\r\n      const metadata = strapi.db.metadata.get(uid);\r\n\r\n      if (!metadata) {\r\n        throw new Error(`No metadata found for ${uid}`);\r\n      }\r\n\r\n      const attributes = filterValidRelationalAttributes(metadata.attributes);\r\n\r\n      if (!(fieldName in attributes)) {\r\n        throw new Error(`${fieldName} is not a valid relational attribute name`);\r\n      }\r\n\r\n      const attribute = attributes[fieldName];\r\n\r\n      const kind = getLinkKind(attribute, uid);\r\n      const { relation, target } = attribute;\r\n\r\n      // The relation is stored in the same table\r\n      // TODO: handle manyToOne joinColumn\r\n      if (attribute.joinColumn) {\r\n        const joinColumnName: string = attribute.joinColumn.name;\r\n\r\n        const qb = connection\r\n          .queryBuilder()\r\n          .select('id', joinColumnName)\r\n          .from(addSchema(metadata.tableName));\r\n\r\n        if (trx) {\r\n          qb.transacting(trx);\r\n        }\r\n\r\n        // TODO: stream the query to improve performances\r\n        const entries = await qb;\r\n\r\n        for (const entry of entries) {\r\n          const ref = entry[joinColumnName];\r\n\r\n          if (ref !== null) {\r\n            yield {\r\n              kind,\r\n              relation,\r\n              left: { type: uid, ref: entry.id, field: fieldName },\r\n              right: { type: target, ref },\r\n            };\r\n          }\r\n        }\r\n      }\r\n\r\n      // The relation uses a join table\r\n      if (attribute.joinTable) {\r\n        const {\r\n          name,\r\n          joinColumn,\r\n          inverseJoinColumn,\r\n          orderColumnName,\r\n          morphColumn,\r\n          inverseOrderColumnName,\r\n        } = attribute.joinTable;\r\n\r\n        const qb = connection.queryBuilder().from(addSchema(name));\r\n\r\n        type Columns = {\r\n          left: { ref: string | null; order?: string };\r\n          right: { ref: string | null; order?: string; type?: string; field?: string };\r\n        };\r\n\r\n        const columns: Columns = {\r\n          left: { ref: null },\r\n          right: { ref: null },\r\n        };\r\n\r\n        const left: Partial<ILink['left']> = { type: uid, field: fieldName };\r\n        const right: Partial<ILink['right']> = {};\r\n\r\n        if (kind === 'relation.basic' || kind === 'relation.circular') {\r\n          right.type = attribute.target;\r\n          right.field = attribute.inversedBy;\r\n\r\n          columns.left.ref = joinColumn.name;\r\n          columns.right.ref = inverseJoinColumn.name;\r\n\r\n          if (orderColumnName) {\r\n            columns.left.order = orderColumnName as string;\r\n          }\r\n\r\n          if (inverseOrderColumnName) {\r\n            columns.right.order = inverseOrderColumnName as string;\r\n          }\r\n        }\r\n\r\n        if (kind === 'relation.morph') {\r\n          columns.left.ref = joinColumn.name;\r\n\r\n          columns.right.ref = morphColumn.idColumn.name;\r\n          columns.right.type = morphColumn.typeColumn.name;\r\n          columns.right.field = 'field';\r\n          columns.right.order = 'order';\r\n        }\r\n\r\n        const validColumns = [\r\n          // Left\r\n          columns.left.ref,\r\n          columns.left.order,\r\n          // Right\r\n          columns.right.ref,\r\n          columns.right.type,\r\n          columns.right.field,\r\n          columns.right.order,\r\n        ].filter((column: string | null | undefined) => !isNil(column));\r\n\r\n        qb.select(validColumns);\r\n\r\n        if (trx) {\r\n          qb.transacting(trx);\r\n        }\r\n\r\n        // TODO: stream the query to improve performances\r\n        const entries = await qb;\r\n\r\n        for (const entry of entries) {\r\n          if (columns.left.ref) {\r\n            left.ref = entry[columns.left.ref];\r\n          }\r\n\r\n          if (columns.right.ref) {\r\n            right.ref = entry[columns.right.ref];\r\n          }\r\n\r\n          if (columns.left.order) {\r\n            left.pos = entry[columns.left.order as string];\r\n          }\r\n\r\n          if (columns.right.order) {\r\n            right.pos = entry[columns.right.order as string];\r\n          }\r\n\r\n          if (columns.right.type) {\r\n            right.type = entry[columns.right.type as string];\r\n          }\r\n\r\n          if (columns.right.field) {\r\n            right.field = entry[columns.right.field as string];\r\n          }\r\n\r\n          const link: ILink = {\r\n            kind,\r\n            relation,\r\n            left: clone(left as ILink['left']),\r\n            right: clone(right as ILink['right']),\r\n          };\r\n\r\n          yield link;\r\n        }\r\n      }\r\n\r\n      if (attribute.morphColumn) {\r\n        const { typeColumn, idColumn } = attribute.morphColumn;\r\n\r\n        const qb = connection\r\n          .queryBuilder()\r\n          .select('id', typeColumn.name, idColumn.name)\r\n          .from(addSchema(metadata.tableName))\r\n          .whereNotNull(typeColumn.name)\r\n          .whereNotNull(idColumn.name);\r\n\r\n        if (trx) {\r\n          qb.transacting(trx);\r\n        }\r\n\r\n        const entries = await qb;\r\n\r\n        for (const entry of entries) {\r\n          const ref = entry[idColumn.name];\r\n\r\n          yield {\r\n            kind,\r\n            relation,\r\n            left: { type: uid, ref: entry.id, field: fieldName },\r\n            right: { type: entry[typeColumn.name], ref },\r\n          };\r\n        }\r\n      }\r\n    }\r\n\r\n    async function* generateAll(uid: string): AsyncGenerator<ILink> {\r\n      const metadata = strapi.db.metadata.get(uid);\r\n\r\n      if (!metadata) {\r\n        throw new Error(`No metadata found for ${uid}`);\r\n      }\r\n\r\n      const attributes = filterValidRelationalAttributes(metadata.attributes);\r\n\r\n      for (const fieldName of Object.keys(attributes)) {\r\n        for await (const link of generateAllForAttribute(uid, fieldName)) {\r\n          yield link;\r\n        }\r\n      }\r\n    }\r\n\r\n    const insert = async (link: ILink) => {\r\n      const { kind, left, right } = link;\r\n\r\n      const metadata = strapi.db.metadata.get(left.type);\r\n      const attribute = metadata.attributes[left.field];\r\n\r\n      const payload = {};\r\n\r\n      /**\r\n       * This _should_ only happen for attributes that are added dynamically e.g. review-workflow stages\r\n       * and a user is importing EE data into a CE project.\r\n       */\r\n      if (!attribute) {\r\n        return;\r\n      }\r\n\r\n      if (attribute.type !== 'relation') {\r\n        throw new Error(`Attribute ${left.field} is not a relation`);\r\n      }\r\n\r\n      if ('joinColumn' in attribute && attribute.joinColumn) {\r\n        const joinColumnName = attribute.joinColumn.name;\r\n\r\n        // Note: this addSchema may not be necessary, but is added for safety\r\n        const qb = connection(addSchema(metadata.tableName))\r\n          .where('id', left.ref)\r\n          .update({ [joinColumnName]: right.ref });\r\n        if (trx) {\r\n          qb.transacting(trx);\r\n        }\r\n        await qb;\r\n      }\r\n\r\n      if ('joinTable' in attribute && attribute.joinTable) {\r\n        const { joinTable } = attribute;\r\n\r\n        if (joinTable.joinColumn) {\r\n          Object.assign(payload, { [joinTable.joinColumn.name]: left.ref });\r\n        }\r\n\r\n        const assignInverseColumn = () => {\r\n          if ('inverseJoinColumn' in joinTable && joinTable.inverseJoinColumn) {\r\n            Object.assign(payload, {\r\n              [joinTable.inverseJoinColumn.name]: right.ref,\r\n            });\r\n          }\r\n        };\r\n\r\n        const assignOrderColumns = () => {\r\n          if ('orderColumnName' in joinTable && joinTable.orderColumnName) {\r\n            Object.assign(payload, { [joinTable.orderColumnName]: left.pos ?? null });\r\n          }\r\n\r\n          if ('inverseOrderColumnName' in joinTable && joinTable.inverseOrderColumnName) {\r\n            Object.assign(payload, { [joinTable.inverseOrderColumnName]: right.pos ?? null });\r\n          }\r\n        };\r\n\r\n        const assignMorphColumns = () => {\r\n          if ('morphColumn' in joinTable && joinTable.morphColumn) {\r\n            const { idColumn, typeColumn } = joinTable.morphColumn ?? {};\r\n\r\n            if (idColumn) {\r\n              Object.assign(payload, { [idColumn.name]: right.ref });\r\n            }\r\n\r\n            if (typeColumn) {\r\n              Object.assign(payload, { [typeColumn.name]: right.type });\r\n            }\r\n\r\n            Object.assign(payload, { order: right.pos ?? null, field: right.field ?? null });\r\n          }\r\n        };\r\n\r\n        if (kind === 'relation.basic' || kind === 'relation.circular') {\r\n          assignInverseColumn();\r\n        }\r\n\r\n        if (kind === 'relation.morph') {\r\n          assignMorphColumns();\r\n        }\r\n\r\n        assignOrderColumns();\r\n        const qb = connection.insert(payload).into(addSchema(joinTable.name));\r\n        if (trx) {\r\n          await trx.transaction(async (nestedTrx) => {\r\n            await qb.transacting(nestedTrx);\r\n          });\r\n        }\r\n      }\r\n\r\n      if ('morphColumn' in attribute && attribute.morphColumn) {\r\n        const { morphColumn } = attribute;\r\n\r\n        const qb = connection(addSchema(metadata.tableName))\r\n          .where('id', left.ref)\r\n          .update({\r\n            [morphColumn.idColumn.name]: right.ref,\r\n            [morphColumn.typeColumn.name]: right.type,\r\n          });\r\n\r\n        if (trx) {\r\n          qb.transacting(trx);\r\n        }\r\n\r\n        await qb;\r\n      }\r\n    };\r\n\r\n    return { generateAll, generateAllForAttribute, insert };\r\n  };\r\n\r\n  return query;\r\n};\r\n\r\nexport const filterValidRelationalAttributes = (attributes: Record<string, any>) => {\r\n  const isOwner = (attribute: any) => {\r\n    return attribute.owner || (!attribute.mappedBy && !attribute.morphBy);\r\n  };\r\n\r\n  const isComponentLike = (attribute: any) => attribute.joinTable?.name.endsWith('_cmps');\r\n\r\n  return Object.entries(attributes)\r\n    .filter(([, attribute]) => {\r\n      return attribute.type === 'relation' && isOwner(attribute) && !isComponentLike(attribute);\r\n    })\r\n    .reduce<Record<string, any>>((acc, [key, attribute]) => ({ ...acc, [key]: attribute }), {});\r\n};\r\n\r\nconst getLinkKind = (attribute: any, uid: string): ILink['kind'] => {\r\n  if (attribute.relation.startsWith('morph')) {\r\n    return 'relation.morph';\r\n  }\r\n\r\n  if (attribute.target === uid) {\r\n    return 'relation.circular';\r\n  }\r\n\r\n  return 'relation.basic';\r\n};\r\n","import { Writable } from 'stream';\r\nimport type { Core, UID } from '@strapi/types';\r\n\r\nimport { last } from 'lodash/fp';\r\n\r\nimport { ProviderTransferError } from '../../../../../errors/providers';\r\nimport type { IEntity, Transaction } from '../../../../../../types';\r\nimport { json } from '../../../../../utils';\r\nimport * as queries from '../../../../queries';\r\nimport { resolveComponentUID } from '../../../../../utils/components';\r\n\r\ninterface IEntitiesRestoreStreamOptions {\r\n  strapi: Core.Strapi;\r\n  updateMappingTable<TSchemaUID extends UID.Schema>(\r\n    type: TSchemaUID,\r\n    oldID: number,\r\n    newID: number\r\n  ): void;\r\n  transaction?: Transaction;\r\n}\r\n\r\nexport const createEntitiesWriteStream = (options: IEntitiesRestoreStreamOptions) => {\r\n  const { strapi, updateMappingTable, transaction } = options;\r\n  const query = queries.entity.createEntityQuery(strapi);\r\n\r\n  return new Writable({\r\n    objectMode: true,\r\n\r\n    async write(entity: IEntity, _encoding, callback) {\r\n      await transaction?.attach(async () => {\r\n        const { type, id, data } = entity;\r\n        const { create, getDeepPopulateComponentLikeQuery } = query(type);\r\n        const contentType = strapi.getModel(type);\r\n\r\n        try {\r\n          const created = await create({\r\n            data,\r\n            populate: getDeepPopulateComponentLikeQuery(contentType, { select: 'id' }),\r\n            select: 'id',\r\n          });\r\n\r\n          // Compute differences between original & new entities\r\n          const diffs = json.diff(data, created);\r\n\r\n          updateMappingTable(type, id, created.id);\r\n\r\n          // For each difference found on an ID attribute,\r\n          // update the mapping the table accordingly\r\n          diffs.forEach((diff) => {\r\n            if (diff.kind === 'modified' && last(diff.path) === 'id' && 'kind' in contentType) {\r\n              const target = resolveComponentUID({ paths: diff.path, data, contentType, strapi });\r\n\r\n              // If no type is found for the given path, then ignore the diff\r\n              if (!target) {\r\n                return;\r\n              }\r\n\r\n              const [oldID, newID] = diff.values as [number, number];\r\n\r\n              updateMappingTable(target, oldID, newID);\r\n            }\r\n          });\r\n        } catch (e) {\r\n          if (e instanceof Error) {\r\n            return callback(e);\r\n          }\r\n\r\n          return callback(new ProviderTransferError(`Failed to create \"${type}\" (${id})`));\r\n        }\r\n\r\n        return callback(null);\r\n      });\r\n    },\r\n  });\r\n};\r\n","import { Writable } from 'stream';\r\nimport { omit } from 'lodash/fp';\r\nimport chalk from 'chalk';\r\nimport type { Core } from '@strapi/types';\r\nimport { ProviderTransferError } from '../../../../../errors/providers';\r\nimport { IConfiguration, Transaction } from '../../../../../../types';\r\n\r\nconst omitInvalidCreationAttributes = omit(['id']);\r\n\r\nconst restoreCoreStore = async <T extends { value: unknown }>(strapi: Core.Strapi, values: T) => {\r\n  const data = omitInvalidCreationAttributes(values);\r\n  return strapi.db.query('strapi::core-store').create({\r\n    data: {\r\n      ...data,\r\n      value: JSON.stringify(data.value),\r\n    },\r\n  });\r\n};\r\n\r\nconst restoreWebhooks = async <T extends { value: unknown }>(strapi: Core.Strapi, values: T) => {\r\n  const data = omitInvalidCreationAttributes(values);\r\n  return strapi.db.query('strapi::webhook').create({ data });\r\n};\r\n\r\nexport const restoreConfigs = async (strapi: Core.Strapi, config: IConfiguration) => {\r\n  if (config.type === 'core-store') {\r\n    return restoreCoreStore(strapi, config.value as { value: unknown });\r\n  }\r\n\r\n  if (config.type === 'webhook') {\r\n    return restoreWebhooks(strapi, config.value as { value: unknown });\r\n  }\r\n};\r\n\r\nexport const createConfigurationWriteStream = async (\r\n  strapi: Core.Strapi,\r\n  transaction?: Transaction\r\n) => {\r\n  return new Writable({\r\n    objectMode: true,\r\n    async write<T extends { id: number }>(\r\n      config: IConfiguration<T>,\r\n      _encoding: BufferEncoding,\r\n      callback: (error?: Error | null) => void\r\n    ) {\r\n      await transaction?.attach(async () => {\r\n        try {\r\n          await restoreConfigs(strapi, config);\r\n        } catch (error) {\r\n          return callback(\r\n            new ProviderTransferError(\r\n              `Failed to import ${chalk.yellowBright(config.type)} (${chalk.greenBright(\r\n                config.value.id\r\n              )}`\r\n            )\r\n          );\r\n        }\r\n        callback();\r\n      });\r\n    },\r\n  });\r\n};\r\n","import { Writable } from 'stream';\r\nimport type { Core } from '@strapi/types';\r\nimport { ProviderTransferError } from '../../../../../errors/providers';\r\nimport { ILink, Transaction } from '../../../../../../types';\r\nimport { createLinkQuery } from '../../../../queries/link';\r\n\r\ninterface ErrorWithCode extends Error {\r\n  code: string;\r\n}\r\n\r\nconst isErrorWithCode = (error: any): error is ErrorWithCode => {\r\n  return error && typeof error.code === 'string';\r\n};\r\n\r\nconst isForeignKeyConstraintError = (e: Error) => {\r\n  const MYSQL_FK_ERROR_CODES = ['1452', '1557', '1216', '1217', '1451'];\r\n  const POSTGRES_FK_ERROR_CODE = '23503';\r\n  const SQLITE_FK_ERROR_CODE = 'SQLITE_CONSTRAINT_FOREIGNKEY';\r\n\r\n  if (isErrorWithCode(e) && e.code) {\r\n    return [SQLITE_FK_ERROR_CODE, POSTGRES_FK_ERROR_CODE, ...MYSQL_FK_ERROR_CODES].includes(e.code);\r\n  }\r\n\r\n  return e.message.toLowerCase().includes('foreign key constraint');\r\n};\r\n\r\nexport const createLinksWriteStream = (\r\n  mapID: (uid: string, id: number) => number | undefined,\r\n  strapi: Core.Strapi,\r\n  transaction?: Transaction,\r\n  onWarning?: (message: string) => void\r\n) => {\r\n  return new Writable({\r\n    objectMode: true,\r\n    async write(link: ILink, _encoding, callback) {\r\n      await transaction?.attach(async (trx) => {\r\n        const { left, right } = link;\r\n        const query = createLinkQuery(strapi, trx);\r\n\r\n        const originalLeftRef = left.ref;\r\n        const originalRightRef = right.ref;\r\n\r\n        // Map IDs if needed\r\n        left.ref = mapID(left.type, originalLeftRef) ?? originalLeftRef;\r\n        right.ref = mapID(right.type, originalRightRef) ?? originalRightRef;\r\n\r\n        try {\r\n          await query().insert(link);\r\n        } catch (e) {\r\n          if (e instanceof Error) {\r\n            if (isForeignKeyConstraintError(e)) {\r\n              onWarning?.(\r\n                `Skipping link ${left.type}:${originalLeftRef} -> ${right.type}:${originalRightRef} due to a foreign key constraint.`\r\n              );\r\n              return callback(null);\r\n            }\r\n            return callback(e);\r\n          }\r\n\r\n          return callback(\r\n            new ProviderTransferError(\r\n              `An error happened while trying to import a ${left.type} link.`\r\n            )\r\n          );\r\n        }\r\n\r\n        callback(null);\r\n      });\r\n    },\r\n  });\r\n};\r\n","import type { Core, UID, Struct } from '@strapi/types';\r\nimport type { Model } from '@strapi/database';\r\nimport { ProviderTransferError } from '../../../../../errors/providers';\r\nimport * as queries from '../../../../queries';\r\n\r\nexport interface IRestoreOptions {\r\n  assets?: boolean; // delete media library files before transfer\r\n  configuration?: {\r\n    webhook?: boolean; // delete webhooks before transfer\r\n    coreStore?: boolean; // delete core store before transfer\r\n  };\r\n  entities?: {\r\n    include?: string[]; // only delete these stage entities before transfer\r\n    exclude?: string[]; // exclude these stage entities from deletion\r\n    filters?: ((contentType: Struct.ContentTypeSchema) => boolean)[]; // custom filters to exclude a content type from deletion\r\n    params?: { [uid: string]: unknown }; // params object passed to deleteMany before transfer for custom deletions\r\n  };\r\n}\r\n\r\ninterface IDeleteResults {\r\n  count: number;\r\n  aggregate: { [uid: string]: { count: number } };\r\n}\r\n\r\nexport const deleteRecords = async (strapi: Core.Strapi, options: IRestoreOptions) => {\r\n  const entities = await deleteEntitiesRecords(strapi, options);\r\n  const configuration = await deleteConfigurationRecords(strapi, options);\r\n\r\n  return {\r\n    count: entities.count + configuration.count,\r\n    entities,\r\n    configuration,\r\n  };\r\n};\r\n\r\nconst deleteEntitiesRecords = async (\r\n  strapi: Core.Strapi,\r\n  options: IRestoreOptions = {}\r\n): Promise<IDeleteResults> => {\r\n  const { entities } = options;\r\n\r\n  const models = strapi.get('models').get() as Model[];\r\n  const contentTypes = Object.values(strapi.contentTypes) as Struct.ContentTypeSchema[];\r\n\r\n  const contentTypesToClear = contentTypes\r\n    .filter((contentType) => {\r\n      let removeThisContentType = true;\r\n\r\n      // include means \"only include these types\" so if it's not in here, it's not being included\r\n      if (entities?.include) {\r\n        removeThisContentType = entities.include.includes(contentType.uid);\r\n      }\r\n\r\n      // if something is excluded, remove it. But lack of being excluded doesn't mean it's kept\r\n      if (entities?.exclude && entities.exclude.includes(contentType.uid)) {\r\n        removeThisContentType = false;\r\n      }\r\n\r\n      if (entities?.filters) {\r\n        removeThisContentType = entities.filters.every((filter) => filter(contentType));\r\n      }\r\n\r\n      return removeThisContentType;\r\n    })\r\n    .map((contentType) => contentType.uid);\r\n\r\n  const modelsToClear = models\r\n    .filter((model) => {\r\n      if (contentTypesToClear.includes(model.uid as UID.ContentType)) {\r\n        return false;\r\n      }\r\n\r\n      let removeThisModel = true;\r\n\r\n      // include means \"only include these types\" so if it's not in here, it's not being included\r\n      if (entities?.include) {\r\n        removeThisModel = entities.include.includes(model.uid);\r\n      }\r\n\r\n      // if something is excluded, remove it. But lack of being excluded doesn't mean it's kept\r\n      if (entities?.exclude && entities.exclude.includes(model.uid)) {\r\n        removeThisModel = false;\r\n      }\r\n\r\n      return removeThisModel;\r\n    })\r\n    .map((model) => model.uid);\r\n\r\n  const [results, updateResults] = useResults([...contentTypesToClear, ...modelsToClear]);\r\n\r\n  const contentTypeQuery = queries.entity.createEntityQuery(strapi);\r\n\r\n  const contentTypePromises = contentTypesToClear.map(async (uid) => {\r\n    const result = await contentTypeQuery(uid).deleteMany(entities?.params);\r\n\r\n    if (result) {\r\n      updateResults(result.count || 0, uid);\r\n    }\r\n  });\r\n\r\n  const modelsPromises = modelsToClear.map(async (uid) => {\r\n    const result = await strapi.db.query(uid).deleteMany({});\r\n\r\n    if (result) {\r\n      updateResults(result.count || 0, uid);\r\n    }\r\n  });\r\n\r\n  await Promise.all([...contentTypePromises, ...modelsPromises]);\r\n\r\n  return results;\r\n};\r\n\r\nconst deleteConfigurationRecords = async (\r\n  strapi: Core.Strapi,\r\n  options: IRestoreOptions = {}\r\n): Promise<IDeleteResults> => {\r\n  const { coreStore = true, webhook = true } = options?.configuration ?? {};\r\n\r\n  const models: string[] = [];\r\n\r\n  if (coreStore) {\r\n    models.push('strapi::core-store');\r\n  }\r\n\r\n  if (webhook) {\r\n    models.push('strapi::webhook');\r\n  }\r\n\r\n  const [results, updateResults] = useResults(models);\r\n\r\n  const deletePromises = models.map(async (uid) => {\r\n    const result = await strapi.db.query(uid).deleteMany({});\r\n\r\n    if (result) {\r\n      updateResults(result.count, uid);\r\n    }\r\n  });\r\n\r\n  await Promise.all(deletePromises);\r\n\r\n  return results;\r\n};\r\n\r\nconst useResults = (\r\n  keys: string[]\r\n): [IDeleteResults, (count: number, key?: string) => void | never] => {\r\n  const results: IDeleteResults = {\r\n    count: 0,\r\n    aggregate: keys.reduce((acc, key) => ({ ...acc, [key]: { count: 0 } }), {}),\r\n  };\r\n\r\n  const update = (count: number, key?: string) => {\r\n    if (key) {\r\n      if (!(key in results.aggregate)) {\r\n        throw new ProviderTransferError(`Unknown key \"${key}\" provided in results update`);\r\n      }\r\n\r\n      results.aggregate[key].count += count;\r\n    }\r\n\r\n    results.count += count;\r\n  };\r\n\r\n  return [results, update];\r\n};\r\n\r\nexport * from './entities';\r\nexport * from './configuration';\r\nexport * from './links';\r\n","import type { Core } from '@strapi/types';\r\n\r\nimport { ProviderInitializationError } from '../errors/providers';\r\n\r\nexport type ValidStrapiAssertion = (strapi: unknown, msg?: string) => asserts strapi is Core.Strapi;\r\n\r\nexport const assertValidStrapi: ValidStrapiAssertion = (strapi?: unknown, msg = '') => {\r\n  if (!strapi) {\r\n    throw new ProviderInitializationError(`${msg}. Strapi instance not found.`);\r\n  }\r\n};\r\n","import { Writable, Readable } from 'stream';\r\nimport path from 'path';\r\nimport * as fse from 'fs-extra';\r\nimport type { Knex } from 'knex';\r\nimport type { Core, Struct } from '@strapi/types';\r\nimport type {\r\n  IAsset,\r\n  IDestinationProvider,\r\n  IFile,\r\n  IMetadata,\r\n  ProviderType,\r\n  Transaction,\r\n} from '../../../../types';\r\nimport type { IDiagnosticReporter } from '../../../utils/diagnostic';\r\n\r\nimport { restore } from './strategies';\r\nimport * as utils from '../../../utils';\r\nimport {\r\n  ProviderInitializationError,\r\n  ProviderTransferError,\r\n  ProviderValidationError,\r\n} from '../../../errors/providers';\r\nimport { assertValidStrapi } from '../../../utils/providers';\r\n\r\nexport const VALID_CONFLICT_STRATEGIES = ['restore'];\r\nexport const DEFAULT_CONFLICT_STRATEGY = 'restore';\r\n\r\nexport interface ILocalStrapiDestinationProviderOptions {\r\n  getStrapi(): Core.Strapi | Promise<Core.Strapi>; // return an initialized instance of Strapi\r\n\r\n  autoDestroy?: boolean; // shut down the instance returned by getStrapi() at the end of the transfer\r\n  restore?: restore.IRestoreOptions; // erase data in strapi database before transfer; required if strategy is 'restore'\r\n  strategy: 'restore'; // conflict management strategy; only the restore strategy is available at this time\r\n}\r\n\r\nclass LocalStrapiDestinationProvider implements IDestinationProvider {\r\n  name = 'destination::local-strapi';\r\n\r\n  type: ProviderType = 'destination';\r\n\r\n  options: ILocalStrapiDestinationProviderOptions;\r\n\r\n  strapi?: Core.Strapi;\r\n\r\n  transaction?: Transaction;\r\n\r\n  uploadsBackupDirectoryName: string;\r\n\r\n  onWarning?: ((message: string) => void) | undefined;\r\n\r\n  #diagnostics?: IDiagnosticReporter;\r\n\r\n  /**\r\n   * The entities mapper is used to map old entities to their new IDs\r\n   */\r\n  #entitiesMapper: { [type: string]: { [id: number]: number } };\r\n\r\n  constructor(options: ILocalStrapiDestinationProviderOptions) {\r\n    this.options = options;\r\n    this.#entitiesMapper = {};\r\n    this.uploadsBackupDirectoryName = `uploads_backup_${Date.now()}`;\r\n  }\r\n\r\n  async bootstrap(diagnostics?: IDiagnosticReporter): Promise<void> {\r\n    this.#diagnostics = diagnostics;\r\n    this.#validateOptions();\r\n    this.strapi = await this.options.getStrapi();\r\n    if (!this.strapi) {\r\n      throw new ProviderInitializationError('Could not access local strapi');\r\n    }\r\n\r\n    this.transaction = utils.transaction.createTransaction(this.strapi);\r\n  }\r\n\r\n  // TODO: either move this to restore strategy, or restore strategy should given access to these instead of repeating the logic possibly in a different way\r\n  #areAssetsIncluded = () => {\r\n    return this.options.restore?.assets;\r\n  };\r\n\r\n  #isContentTypeIncluded = (type: string) => {\r\n    const notIncluded =\r\n      this.options.restore?.entities?.include &&\r\n      !this.options.restore?.entities?.include?.includes(type);\r\n    const excluded =\r\n      this.options.restore?.entities?.exclude &&\r\n      this.options.restore?.entities.exclude.includes(type);\r\n\r\n    return !excluded && !notIncluded;\r\n  };\r\n\r\n  #reportInfo(message: string) {\r\n    this.#diagnostics?.report({\r\n      details: {\r\n        createdAt: new Date(),\r\n        message,\r\n        origin: 'local-destination-provider',\r\n      },\r\n      kind: 'info',\r\n    });\r\n  }\r\n\r\n  async close(): Promise<void> {\r\n    const { autoDestroy } = this.options;\r\n    this.transaction?.end();\r\n\r\n    // Basically `!== false` but more deterministic\r\n    if (autoDestroy === undefined || autoDestroy === true) {\r\n      await this.strapi?.destroy();\r\n    }\r\n  }\r\n\r\n  #validateOptions() {\r\n    this.#reportInfo('validating options');\r\n    if (!VALID_CONFLICT_STRATEGIES.includes(this.options.strategy)) {\r\n      throw new ProviderValidationError(`Invalid strategy ${this.options.strategy}`, {\r\n        check: 'strategy',\r\n        strategy: this.options.strategy,\r\n        validStrategies: VALID_CONFLICT_STRATEGIES,\r\n      });\r\n    }\r\n\r\n    // require restore options when using restore\r\n    if (this.options.strategy === 'restore' && !this.options.restore) {\r\n      throw new ProviderValidationError('Missing restore options');\r\n    }\r\n  }\r\n\r\n  async #deleteFromRestoreOptions() {\r\n    assertValidStrapi(this.strapi);\r\n    if (!this.options.restore) {\r\n      throw new ProviderValidationError('Missing restore options');\r\n    }\r\n    this.#reportInfo('deleting record ');\r\n    return restore.deleteRecords(this.strapi, this.options.restore);\r\n  }\r\n\r\n  async #deleteAllAssets(trx?: Knex.Transaction) {\r\n    assertValidStrapi(this.strapi);\r\n    this.#reportInfo('deleting all assets');\r\n    // if we're not restoring files, don't touch the files\r\n    if (!this.#areAssetsIncluded()) {\r\n      return;\r\n    }\r\n\r\n    const stream: Readable = this.strapi.db\r\n      // Create a query builder instance (default type is 'select')\r\n      .queryBuilder('plugin::upload.file')\r\n      // Fetch all columns\r\n      .select('*')\r\n      // Attach the transaction\r\n      .transacting(trx)\r\n      // Get a readable stream\r\n      .stream();\r\n\r\n    // TODO use bulk delete when exists in providers\r\n    for await (const file of stream) {\r\n      await this.strapi.plugin('upload').provider.delete(file);\r\n      if (file.formats) {\r\n        for (const fileFormat of Object.values(file.formats)) {\r\n          await this.strapi.plugin('upload').provider.delete(fileFormat);\r\n        }\r\n      }\r\n    }\r\n\r\n    this.#reportInfo('deleted all assets');\r\n  }\r\n\r\n  async rollback() {\r\n    this.#reportInfo('Rolling back transaction');\r\n    await this.transaction?.rollback();\r\n    this.#reportInfo('Rolled back transaction');\r\n  }\r\n\r\n  async beforeTransfer() {\r\n    if (!this.strapi) {\r\n      throw new Error('Strapi instance not found');\r\n    }\r\n\r\n    await this.transaction?.attach(async (trx) => {\r\n      try {\r\n        if (this.options.strategy === 'restore') {\r\n          await this.#handleAssetsBackup();\r\n          await this.#deleteAllAssets(trx);\r\n          await this.#deleteFromRestoreOptions();\r\n        }\r\n      } catch (error) {\r\n        throw new Error(`restore failed ${error}`);\r\n      }\r\n    });\r\n  }\r\n\r\n  getMetadata(): IMetadata {\r\n    this.#reportInfo('getting metadata');\r\n    assertValidStrapi(this.strapi, 'Not able to get Schemas');\r\n    const strapiVersion = this.strapi.config.get<string>('info.strapi');\r\n    const createdAt = new Date().toISOString();\r\n\r\n    return {\r\n      createdAt,\r\n      strapi: {\r\n        version: strapiVersion,\r\n      },\r\n    };\r\n  }\r\n\r\n  getSchemas(): Record<string, Struct.Schema> {\r\n    this.#reportInfo('getting schema');\r\n    assertValidStrapi(this.strapi, 'Not able to get Schemas');\r\n\r\n    const schemas = utils.schema.schemasToValidJSON({\r\n      ...this.strapi.contentTypes,\r\n      ...this.strapi.components,\r\n    });\r\n\r\n    return utils.schema.mapSchemasValues(schemas);\r\n  }\r\n\r\n  createEntitiesWriteStream(): Writable {\r\n    assertValidStrapi(this.strapi, 'Not able to import entities');\r\n    this.#reportInfo('creating entities stream');\r\n    const { strategy } = this.options;\r\n\r\n    const updateMappingTable = (type: string, oldID: number, newID: number) => {\r\n      if (!this.#entitiesMapper[type]) {\r\n        this.#entitiesMapper[type] = {};\r\n      }\r\n\r\n      Object.assign(this.#entitiesMapper[type], { [oldID]: newID });\r\n    };\r\n\r\n    if (strategy === 'restore') {\r\n      return restore.createEntitiesWriteStream({\r\n        strapi: this.strapi,\r\n        updateMappingTable,\r\n        transaction: this.transaction,\r\n      });\r\n    }\r\n\r\n    throw new ProviderValidationError(`Invalid strategy ${this.options.strategy}`, {\r\n      check: 'strategy',\r\n      strategy: this.options.strategy,\r\n      validStrategies: VALID_CONFLICT_STRATEGIES,\r\n    });\r\n  }\r\n\r\n  async #handleAssetsBackup() {\r\n    assertValidStrapi(this.strapi, 'Not able to create the assets backup');\r\n\r\n    // if we're not restoring assets, don't back them up because they won't be touched\r\n    if (!this.#areAssetsIncluded()) {\r\n      return;\r\n    }\r\n\r\n    if (this.strapi.config.get<{ provider: string }>('plugin::upload').provider === 'local') {\r\n      this.#reportInfo('creating assets backup directory');\r\n      const assetsDirectory = path.join(this.strapi.dirs.static.public, 'uploads');\r\n      const backupDirectory = path.join(\r\n        this.strapi.dirs.static.public,\r\n        this.uploadsBackupDirectoryName\r\n      );\r\n\r\n      try {\r\n        // Check access before attempting to do anything\r\n        await fse.access(\r\n          assetsDirectory,\r\n          // eslint-disable-next-line no-bitwise\r\n          fse.constants.W_OK | fse.constants.R_OK | fse.constants.F_OK\r\n        );\r\n        // eslint-disable-next-line no-bitwise\r\n        await fse.access(path.join(assetsDirectory, '..'), fse.constants.W_OK | fse.constants.R_OK);\r\n\r\n        await fse.move(assetsDirectory, backupDirectory);\r\n        await fse.mkdir(assetsDirectory);\r\n        // Create a .gitkeep file to ensure the directory is not empty\r\n        await fse.outputFile(path.join(assetsDirectory, '.gitkeep'), '');\r\n        this.#reportInfo(`created assets backup directory ${backupDirectory}`);\r\n      } catch (err) {\r\n        throw new ProviderTransferError(\r\n          'The backup folder for the assets could not be created inside the public folder. Please ensure Strapi has write permissions on the public directory',\r\n          {\r\n            code: 'ASSETS_DIRECTORY_ERR',\r\n          }\r\n        );\r\n      }\r\n      return backupDirectory;\r\n    }\r\n  }\r\n\r\n  async #removeAssetsBackup() {\r\n    assertValidStrapi(this.strapi, 'Not able to remove Assets');\r\n    // if we're not restoring assets, don't back them up because they won't be touched\r\n    if (!this.#areAssetsIncluded()) {\r\n      return;\r\n    }\r\n    // TODO: this should catch all thrown errors and bubble it up to engine so it can be reported as a non-fatal diagnostic message telling the user they may need to manually delete assets\r\n    if (this.strapi.config.get<{ provider: string }>('plugin::upload').provider === 'local') {\r\n      this.#reportInfo('removing assets backup');\r\n      assertValidStrapi(this.strapi);\r\n      const backupDirectory = path.join(\r\n        this.strapi.dirs.static.public,\r\n        this.uploadsBackupDirectoryName\r\n      );\r\n      await fse.rm(backupDirectory, { recursive: true, force: true });\r\n      this.#reportInfo('successfully removed assets backup');\r\n    }\r\n  }\r\n\r\n  // TODO: Move this logic to the restore strategy\r\n  async createAssetsWriteStream(): Promise<Writable> {\r\n    assertValidStrapi(this.strapi, 'Not able to stream Assets');\r\n    this.#reportInfo('creating assets write stream');\r\n    if (!this.#areAssetsIncluded()) {\r\n      throw new ProviderTransferError(\r\n        'Attempting to transfer assets when `assets` is not set in restore options'\r\n      );\r\n    }\r\n\r\n    const removeAssetsBackup = this.#removeAssetsBackup.bind(this);\r\n    const strapi = this.strapi;\r\n    const transaction = this.transaction;\r\n    const fileEntitiesMapper = this.#entitiesMapper['plugin::upload.file'];\r\n\r\n    const restoreMediaEntitiesContent = this.#isContentTypeIncluded('plugin::upload.file');\r\n\r\n    return new Writable({\r\n      objectMode: true,\r\n      async final(next) {\r\n        // Delete the backup folder\r\n        await removeAssetsBackup();\r\n        next();\r\n      },\r\n      async write(chunk: IAsset, _encoding, callback) {\r\n        await transaction?.attach(async () => {\r\n          const uploadData = {\r\n            ...chunk.metadata,\r\n            stream: Readable.from(chunk.stream),\r\n            buffer: chunk?.buffer,\r\n          };\r\n\r\n          const provider = strapi.config.get<{ provider: string }>('plugin::upload').provider;\r\n\r\n          const fileId = fileEntitiesMapper?.[uploadData.id];\r\n          if (!fileId) {\r\n            callback(new Error(`File ID not found for ID: ${uploadData.id}`));\r\n          }\r\n\r\n          try {\r\n            await strapi.plugin('upload').provider.uploadStream(uploadData);\r\n\r\n            // if we're not supposed to transfer the associated entities, stop here\r\n            if (!restoreMediaEntitiesContent) {\r\n              return callback();\r\n            }\r\n\r\n            // Files formats are stored within the parent file entity\r\n            if (uploadData?.type) {\r\n              const entry: IFile = await strapi.db.query('plugin::upload.file').findOne({\r\n                where: { id: fileId },\r\n              });\r\n              if (!entry) {\r\n                throw new Error('file not found');\r\n              }\r\n              const specificFormat = entry?.formats?.[uploadData.type];\r\n              if (specificFormat) {\r\n                specificFormat.url = uploadData.url;\r\n              }\r\n              await strapi.db.query('plugin::upload.file').update({\r\n                where: { id: entry.id },\r\n                data: {\r\n                  formats: entry.formats,\r\n                  provider,\r\n                },\r\n              });\r\n              return callback();\r\n            }\r\n\r\n            const entry: IFile = await strapi.db.query('plugin::upload.file').findOne({\r\n              where: { id: fileId },\r\n            });\r\n            if (!entry) {\r\n              throw new Error('file not found');\r\n            }\r\n            entry.url = uploadData.url;\r\n            await strapi.db.query('plugin::upload.file').update({\r\n              where: { id: entry.id },\r\n              data: {\r\n                url: entry.url,\r\n                provider,\r\n              },\r\n            });\r\n            callback();\r\n          } catch (error) {\r\n            callback(new Error(`Error while uploading asset ${chunk.filename} ${error}`));\r\n          }\r\n        });\r\n      },\r\n    });\r\n  }\r\n\r\n  async createConfigurationWriteStream(): Promise<Writable> {\r\n    assertValidStrapi(this.strapi, 'Not able to stream Configurations');\r\n    this.#reportInfo('creating configuration write stream');\r\n    const { strategy } = this.options;\r\n\r\n    if (strategy === 'restore') {\r\n      return restore.createConfigurationWriteStream(this.strapi, this.transaction);\r\n    }\r\n\r\n    throw new ProviderValidationError(`Invalid strategy ${strategy}`, {\r\n      check: 'strategy',\r\n      strategy,\r\n      validStrategies: VALID_CONFLICT_STRATEGIES,\r\n    });\r\n  }\r\n\r\n  async createLinksWriteStream(): Promise<Writable> {\r\n    this.#reportInfo('creating links write stream');\r\n    if (!this.strapi) {\r\n      throw new Error('Not able to stream links. Strapi instance not found');\r\n    }\r\n\r\n    const { strategy } = this.options;\r\n    const mapID = (uid: string, id: number): number | undefined => this.#entitiesMapper[uid]?.[id];\r\n\r\n    if (strategy === 'restore') {\r\n      return restore.createLinksWriteStream(mapID, this.strapi, this.transaction, this.onWarning);\r\n    }\r\n\r\n    throw new ProviderValidationError(`Invalid strategy ${strategy}`, {\r\n      check: 'strategy',\r\n      strategy,\r\n      validStrategies: VALID_CONFLICT_STRATEGIES,\r\n    });\r\n  }\r\n}\r\n\r\nexport const createLocalStrapiDestinationProvider = (\r\n  options: ILocalStrapiDestinationProviderOptions\r\n) => {\r\n  return new LocalStrapiDestinationProvider(options);\r\n};\r\n","import { Readable, Transform } from 'stream';\r\nimport type { Core, Struct } from '@strapi/types';\r\n\r\nimport * as shared from '../../queries';\r\nimport { IEntity } from '../../../../types';\r\n\r\n/**\r\n * Generate and consume content-types streams in order to stream each entity individually\r\n */\r\nexport const createEntitiesStream = (strapi: Core.Strapi): Readable => {\r\n  const contentTypes: Struct.ContentTypeSchema[] = Object.values(strapi.contentTypes);\r\n\r\n  async function* contentTypeStreamGenerator() {\r\n    for (const contentType of contentTypes) {\r\n      const query = shared.entity.createEntityQuery(strapi).call(null, contentType.uid);\r\n\r\n      const stream: Readable = strapi.db\r\n        // Create a query builder instance (default type is 'select')\r\n        .queryBuilder(contentType.uid)\r\n        // Fetch all columns\r\n        .select('*')\r\n        // Apply the populate\r\n        .populate(query.deepPopulateComponentLikeQuery)\r\n        // Get a readable stream\r\n        .stream();\r\n\r\n      yield { contentType, stream };\r\n    }\r\n  }\r\n\r\n  return Readable.from(\r\n    (async function* entitiesGenerator(): AsyncGenerator<{\r\n      entity: IEntity;\r\n      contentType: Struct.ContentTypeSchema;\r\n    }> {\r\n      for await (const { stream, contentType } of contentTypeStreamGenerator()) {\r\n        try {\r\n          for await (const entity of stream) {\r\n            yield { entity, contentType };\r\n          }\r\n        } catch {\r\n          // ignore\r\n        } finally {\r\n          stream.destroy();\r\n        }\r\n      }\r\n    })()\r\n  );\r\n};\r\n\r\n/**\r\n * Create an entity transform stream which convert the output of\r\n * the multi-content-types stream to the transfer entity format\r\n */\r\nexport const createEntitiesTransformStream = (): Transform => {\r\n  return new Transform({\r\n    objectMode: true,\r\n    transform(data, _encoding, callback) {\r\n      const { entity, contentType } = data;\r\n      const { id, ...attributes } = entity;\r\n\r\n      callback(null, {\r\n        type: contentType.uid,\r\n        id,\r\n        data: attributes,\r\n      });\r\n    },\r\n  });\r\n};\r\n","import { Readable } from 'stream';\r\nimport type { Core } from '@strapi/types';\r\n\r\nimport type { ILink } from '../../../../types';\r\nimport { createLinkQuery } from '../../queries/link';\r\n\r\n/**\r\n * Create a Readable which will stream all the links from a Strapi instance\r\n */\r\nexport const createLinksStream = (strapi: Core.Strapi): Readable => {\r\n  const uids = [...Object.keys(strapi.contentTypes), ...Object.keys(strapi.components)] as string[];\r\n\r\n  // Async generator stream that returns every link from a Strapi instance\r\n  return Readable.from(\r\n    (async function* linkGenerator(): AsyncGenerator<ILink> {\r\n      const query = createLinkQuery(strapi);\r\n\r\n      for (const uid of uids) {\r\n        const generator = query().generateAll(uid);\r\n\r\n        for await (const link of generator) {\r\n          yield link;\r\n        }\r\n      }\r\n    })()\r\n  );\r\n};\r\n","import { Readable } from 'stream';\r\nimport { chain } from 'stream-chain';\r\nimport { set } from 'lodash/fp';\r\nimport type { Core } from '@strapi/types';\r\n\r\nimport type { IConfiguration } from '../../../../types';\r\n\r\n/**\r\n * Create a readable stream that export the Strapi app configuration\r\n */\r\nexport const createConfigurationStream = (strapi: Core.Strapi): Readable => {\r\n  return Readable.from(\r\n    (async function* configurationGenerator(): AsyncGenerator<IConfiguration> {\r\n      // Core Store\r\n      const coreStoreStream = chain([\r\n        strapi.db.queryBuilder('strapi::core-store').stream(),\r\n        (data) => set('value', JSON.parse(data.value), data),\r\n        wrapConfigurationItem('core-store'),\r\n      ]);\r\n\r\n      // Webhook\r\n      const webhooksStream = chain([\r\n        strapi.db.queryBuilder('strapi::webhook').stream(),\r\n        wrapConfigurationItem('webhook'),\r\n      ]);\r\n\r\n      const streams = [coreStoreStream, webhooksStream];\r\n\r\n      for (const stream of streams) {\r\n        for await (const item of stream) {\r\n          yield item;\r\n        }\r\n      }\r\n    })()\r\n  );\r\n};\r\n\r\nconst wrapConfigurationItem = (type: 'core-store' | 'webhook') => (value: unknown) => ({\r\n  type,\r\n  value,\r\n});\r\n","import { join } from 'path';\r\nimport { Duplex, PassThrough, Readable } from 'stream';\r\nimport * as webStream from 'stream/web';\r\nimport { stat, createReadStream, ReadStream } from 'fs-extra';\r\nimport type { Core } from '@strapi/types';\r\n\r\nimport type { IAsset, IFile } from '../../../../types';\r\n\r\nfunction getFileStream(\r\n  filepath: string,\r\n  strapi: Core.Strapi,\r\n  isLocal = false\r\n): PassThrough | ReadStream {\r\n  if (isLocal) {\r\n    // Todo: handle errors\r\n    return createReadStream(filepath);\r\n  }\r\n\r\n  const readableStream = new PassThrough();\r\n\r\n  // fetch the image from remote url and stream it\r\n  strapi\r\n    .fetch(filepath)\r\n    .then((res: Response) => {\r\n      if (res.status !== 200) {\r\n        readableStream.emit('error', new Error(`Request failed with status code ${res.status}`));\r\n        return;\r\n      }\r\n\r\n      if (res.body) {\r\n        // pipe the image data\r\n        Readable.fromWeb(new webStream.ReadableStream(res.body)).pipe(readableStream);\r\n      } else {\r\n        readableStream.emit('error', new Error('Empty data found for file'));\r\n      }\r\n    })\r\n    .catch((error: unknown) => {\r\n      readableStream.emit('error', error);\r\n    });\r\n\r\n  return readableStream;\r\n}\r\n\r\nfunction getFileStats(\r\n  filepath: string,\r\n  strapi: Core.Strapi,\r\n  isLocal = false\r\n): Promise<{ size: number }> {\r\n  if (isLocal) {\r\n    return stat(filepath);\r\n  }\r\n  return new Promise((resolve, reject) => {\r\n    strapi\r\n      .fetch(filepath)\r\n      .then((res: Response) => {\r\n        if (res.status !== 200) {\r\n          reject(new Error(`Request failed with status code ${res.status}`));\r\n          return;\r\n        }\r\n\r\n        const contentLength = res.headers.get('content-length');\r\n        const stats = {\r\n          size: contentLength ? parseInt(contentLength, 10) : 0,\r\n        };\r\n\r\n        resolve(stats);\r\n      })\r\n      .catch((error: unknown) => {\r\n        reject(error);\r\n      });\r\n  });\r\n}\r\n\r\nasync function signFile(file: IFile) {\r\n  const { provider } = strapi.plugins.upload;\r\n  const { provider: providerName } = strapi.config.get('plugin.upload') as { provider: string };\r\n  const isPrivate = await provider.isPrivate();\r\n  if (file?.provider === providerName && isPrivate) {\r\n    const signUrl = async (file: IFile) => {\r\n      const signedUrl = await provider.getSignedUrl(file);\r\n      file.url = signedUrl.url;\r\n    };\r\n\r\n    // Sign the original file\r\n    await signUrl(file);\r\n    // Sign each file format\r\n    if (file.formats) {\r\n      for (const format of Object.keys(file.formats)) {\r\n        await signUrl(file.formats[format]);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Generate and consume assets streams in order to stream each file individually\r\n */\r\nexport const createAssetsStream = (strapi: Core.Strapi): Duplex => {\r\n  const generator: () => AsyncGenerator<IAsset, void> = async function* () {\r\n    const stream: Readable = strapi.db\r\n      .queryBuilder('plugin::upload.file')\r\n      // Create a query builder instance (default type is 'select')\r\n      // Fetch all columns\r\n      .select('*')\r\n      // Get a readable stream\r\n      .stream();\r\n\r\n    for await (const file of stream) {\r\n      const isLocalProvider = file.provider === 'local';\r\n      if (!isLocalProvider) {\r\n        await signFile(file);\r\n      }\r\n      const filepath = isLocalProvider ? join(strapi.dirs.static.public, file.url) : file.url;\r\n      const stats = await getFileStats(filepath, strapi, isLocalProvider);\r\n      const stream = getFileStream(filepath, strapi, isLocalProvider);\r\n\r\n      yield {\r\n        metadata: file,\r\n        filepath,\r\n        filename: file.hash + file.ext,\r\n        stream,\r\n        stats: { size: stats.size },\r\n      };\r\n\r\n      if (file.formats) {\r\n        for (const format of Object.keys(file.formats)) {\r\n          const fileFormat = file.formats[format];\r\n          const fileFormatFilepath = isLocalProvider\r\n            ? join(strapi.dirs.static.public, fileFormat.url)\r\n            : fileFormat.url;\r\n          const fileFormatStats = await getFileStats(fileFormatFilepath, strapi, isLocalProvider);\r\n          const fileFormatStream = getFileStream(fileFormatFilepath, strapi, isLocalProvider);\r\n          const metadata = { ...fileFormat, type: format, id: file.id, mainHash: file.hash };\r\n          yield {\r\n            metadata,\r\n            filepath: fileFormatFilepath,\r\n            filename: fileFormat.hash + fileFormat.ext,\r\n            stream: fileFormatStream,\r\n            stats: { size: fileFormatStats.size },\r\n          };\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  return Duplex.from(generator());\r\n};\r\n","import { Readable } from 'stream';\r\nimport { chain } from 'stream-chain';\r\nimport type { Core, Struct } from '@strapi/types';\r\n\r\nimport type { IMetadata, ISourceProvider, ProviderType } from '../../../../types';\r\nimport type { IDiagnosticReporter } from '../../../utils/diagnostic';\r\nimport { createEntitiesStream, createEntitiesTransformStream } from './entities';\r\nimport { createLinksStream } from './links';\r\nimport { createConfigurationStream } from './configuration';\r\nimport { createAssetsStream } from './assets';\r\nimport * as utils from '../../../utils';\r\nimport { assertValidStrapi } from '../../../utils/providers';\r\n\r\nexport interface ILocalStrapiSourceProviderOptions {\r\n  getStrapi(): Core.Strapi | Promise<Core.Strapi>; // return an initialized instance of Strapi\r\n\r\n  autoDestroy?: boolean; // shut down the instance returned by getStrapi() at the end of the transfer\r\n}\r\n\r\nexport const createLocalStrapiSourceProvider = (options: ILocalStrapiSourceProviderOptions) => {\r\n  return new LocalStrapiSourceProvider(options);\r\n};\r\n\r\nclass LocalStrapiSourceProvider implements ISourceProvider {\r\n  name = 'source::local-strapi';\r\n\r\n  type: ProviderType = 'source';\r\n\r\n  options: ILocalStrapiSourceProviderOptions;\r\n\r\n  strapi?: Core.Strapi;\r\n\r\n  #diagnostics?: IDiagnosticReporter;\r\n\r\n  constructor(options: ILocalStrapiSourceProviderOptions) {\r\n    this.options = options;\r\n  }\r\n\r\n  async bootstrap(diagnostics?: IDiagnosticReporter): Promise<void> {\r\n    this.#diagnostics = diagnostics;\r\n    this.strapi = await this.options.getStrapi();\r\n  }\r\n\r\n  #reportInfo(message: string) {\r\n    this.#diagnostics?.report({\r\n      details: {\r\n        createdAt: new Date(),\r\n        message,\r\n        origin: 'local-source-provider',\r\n      },\r\n      kind: 'info',\r\n    });\r\n  }\r\n\r\n  async close(): Promise<void> {\r\n    const { autoDestroy } = this.options;\r\n\r\n    // Basically `!== false` but more deterministic\r\n    if (autoDestroy === undefined || autoDestroy === true) {\r\n      await this.strapi?.destroy();\r\n    }\r\n  }\r\n\r\n  getMetadata(): IMetadata {\r\n    this.#reportInfo('getting metadata');\r\n    const strapiVersion = strapi.config.get<string>('info.strapi');\r\n    const createdAt = new Date().toISOString();\r\n\r\n    return {\r\n      createdAt,\r\n      strapi: {\r\n        version: strapiVersion,\r\n      },\r\n    };\r\n  }\r\n\r\n  async createEntitiesReadStream(): Promise<Readable> {\r\n    assertValidStrapi(this.strapi, 'Not able to stream entities');\r\n    this.#reportInfo('creating entities read stream');\r\n    return chain([\r\n      // Entities stream\r\n      createEntitiesStream(this.strapi),\r\n\r\n      // Transform stream\r\n      createEntitiesTransformStream(),\r\n    ]);\r\n  }\r\n\r\n  createLinksReadStream(): Readable {\r\n    assertValidStrapi(this.strapi, 'Not able to stream links');\r\n    this.#reportInfo('creating links read stream');\r\n\r\n    return createLinksStream(this.strapi);\r\n  }\r\n\r\n  createConfigurationReadStream(): Readable {\r\n    assertValidStrapi(this.strapi, 'Not able to stream configuration');\r\n    this.#reportInfo('creating configuration read stream');\r\n    return createConfigurationStream(this.strapi);\r\n  }\r\n\r\n  getSchemas(): Record<string, Struct.Schema> {\r\n    assertValidStrapi(this.strapi, 'Not able to get Schemas');\r\n    this.#reportInfo('getting schemas');\r\n    const schemas = utils.schema.schemasToValidJSON({\r\n      ...this.strapi.contentTypes,\r\n      ...this.strapi.components,\r\n    });\r\n\r\n    return utils.schema.mapSchemasValues(schemas);\r\n  }\r\n\r\n  createSchemasReadStream(): Readable {\r\n    return Readable.from(Object.values(this.getSchemas()));\r\n  }\r\n\r\n  createAssetsReadStream(): Readable {\r\n    assertValidStrapi(this.strapi, 'Not able to stream assets');\r\n    this.#reportInfo('creating assets read stream');\r\n    return createAssetsStream(this.strapi);\r\n  }\r\n}\r\n\r\nexport type ILocalStrapiSourceProvider = InstanceType<typeof LocalStrapiSourceProvider>;\r\n","import { randomUUID } from 'crypto';\r\nimport { RawData, WebSocket } from 'ws';\r\n\r\nimport type { Client, Server } from '../../../types/remote/protocol';\r\n\r\nimport {\r\n  ProviderError,\r\n  ProviderTransferError,\r\n  ProviderInitializationError,\r\n  ProviderValidationError,\r\n  ProviderErrorDetails,\r\n} from '../../errors/providers';\r\nimport { IDiagnosticReporter } from '../../utils/diagnostic';\r\n\r\ninterface IDispatcherState {\r\n  transfer?: { kind: Client.TransferKind; id: string };\r\n}\r\n\r\ninterface IDispatchOptions {\r\n  attachTransfer?: boolean;\r\n}\r\n\r\ntype Dispatch<T> = Omit<T, 'transferID' | 'uuid'>;\r\n\r\nexport const createDispatcher = (\r\n  ws: WebSocket,\r\n  retryMessageOptions = {\r\n    retryMessageMaxRetries: 5,\r\n    retryMessageTimeout: 30000,\r\n  },\r\n  reportInfo?: (message: string) => void\r\n) => {\r\n  const state: IDispatcherState = {};\r\n\r\n  type DispatchMessage = Dispatch<Client.Message>;\r\n\r\n  const dispatch = async <U = null>(\r\n    message: DispatchMessage,\r\n    options: IDispatchOptions = {}\r\n  ): Promise<U | null> => {\r\n    if (!ws) {\r\n      throw new Error('No websocket connection found');\r\n    }\r\n\r\n    return new Promise<U | null>((resolve, reject) => {\r\n      const uuid = randomUUID();\r\n      const payload = { ...message, uuid };\r\n      let numberOfTimesMessageWasSent = 0;\r\n\r\n      if (options.attachTransfer) {\r\n        Object.assign(payload, { transferID: state.transfer?.id });\r\n      }\r\n\r\n      if (message.type === 'command') {\r\n        reportInfo?.(\r\n          `dispatching message command:${(message as Client.CommandMessage).command} uuid:${uuid} sent:${numberOfTimesMessageWasSent}`\r\n        );\r\n      } else if (message.type === 'transfer') {\r\n        const messageToSend = message as Client.TransferMessage;\r\n        reportInfo?.(\r\n          `dispatching message action:${messageToSend.action} ${messageToSend.kind === 'step' ? `step:${messageToSend.step}` : ''} uuid:${uuid} sent:${numberOfTimesMessageWasSent}`\r\n        );\r\n      }\r\n      const stringifiedPayload = JSON.stringify(payload);\r\n      ws.send(stringifiedPayload, (error) => {\r\n        if (error) {\r\n          reject(error);\r\n        }\r\n      });\r\n      const { retryMessageMaxRetries, retryMessageTimeout } = retryMessageOptions;\r\n      const sendPeriodically = () => {\r\n        if (numberOfTimesMessageWasSent <= retryMessageMaxRetries) {\r\n          numberOfTimesMessageWasSent += 1;\r\n          ws.send(stringifiedPayload, (error) => {\r\n            if (error) {\r\n              reject(error);\r\n            }\r\n          });\r\n        } else {\r\n          reject(new ProviderError('error', 'Request timed out'));\r\n        }\r\n      };\r\n      const interval = setInterval(sendPeriodically, retryMessageTimeout);\r\n\r\n      const onResponse = (raw: RawData) => {\r\n        const response: Server.Message<U> = JSON.parse(raw.toString());\r\n        if (message.type === 'command') {\r\n          reportInfo?.(\r\n            `received response to message command: ${(message as Client.CommandMessage).command} uuid: ${uuid} sent: ${numberOfTimesMessageWasSent}`\r\n          );\r\n        } else if (message.type === 'transfer') {\r\n          const messageToSend = message as Client.TransferMessage;\r\n          reportInfo?.(\r\n            `received response to message action:${messageToSend.action} ${messageToSend.kind === 'step' ? `step:${messageToSend.step}` : ''} uuid:${uuid} sent:${numberOfTimesMessageWasSent}`\r\n          );\r\n        }\r\n        if (response.uuid === uuid) {\r\n          clearInterval(interval);\r\n          if (response.error) {\r\n            const message = response.error.message;\r\n            const details = response.error.details?.details as ProviderErrorDetails;\r\n            const step = response.error.details?.step;\r\n            let error = new ProviderError('error', message, details);\r\n            if (step === 'transfer') {\r\n              error = new ProviderTransferError(message, details);\r\n            } else if (step === 'validation') {\r\n              error = new ProviderValidationError(message, details);\r\n            } else if (step === 'initialization') {\r\n              error = new ProviderInitializationError(message);\r\n            }\r\n            return reject(error);\r\n          }\r\n          resolve(response.data ?? null);\r\n        } else {\r\n          ws.once('message', onResponse);\r\n        }\r\n      };\r\n\r\n      ws.once('message', onResponse);\r\n    });\r\n  };\r\n\r\n  const dispatchCommand = <U extends Client.Command>(\r\n    payload: {\r\n      command: U;\r\n    } & ([Client.GetCommandParams<U>] extends [never]\r\n      ? unknown\r\n      : { params?: Client.GetCommandParams<U> })\r\n  ) => {\r\n    return dispatch({ type: 'command', ...payload } as Client.CommandMessage);\r\n  };\r\n\r\n  const dispatchTransferAction = async <T>(action: Client.Action['action']) => {\r\n    const payload: Dispatch<Client.Action> = { type: 'transfer', kind: 'action', action };\r\n\r\n    return dispatch<T>(payload, { attachTransfer: true }) ?? Promise.resolve(null);\r\n  };\r\n\r\n  const dispatchTransferStep = async <\r\n    T,\r\n    A extends Client.TransferPushMessage['action'] = Client.TransferPushMessage['action'],\r\n    S extends Client.TransferPushStep = Client.TransferPushStep,\r\n  >(\r\n    payload: {\r\n      step: S;\r\n      action: A;\r\n    } & (A extends 'stream' ? { data: Client.GetTransferPushStreamData<S> } : unknown)\r\n  ) => {\r\n    const message: Dispatch<Client.TransferPushMessage> = {\r\n      type: 'transfer',\r\n      kind: 'step',\r\n      ...payload,\r\n    };\r\n\r\n    return dispatch<T>(message, { attachTransfer: true }) ?? Promise.resolve(null);\r\n  };\r\n\r\n  const setTransferProperties = (\r\n    properties: Exclude<IDispatcherState['transfer'], undefined>\r\n  ): void => {\r\n    state.transfer = { ...properties };\r\n  };\r\n\r\n  return {\r\n    get transferID() {\r\n      return state.transfer?.id;\r\n    },\r\n\r\n    get transferKind() {\r\n      return state.transfer?.kind;\r\n    },\r\n\r\n    setTransferProperties,\r\n\r\n    dispatch,\r\n    dispatchCommand,\r\n    dispatchTransferAction,\r\n    dispatchTransferStep,\r\n  };\r\n};\r\n\r\ntype WebsocketParams = ConstructorParameters<typeof WebSocket>;\r\ntype Address = WebsocketParams[0];\r\ntype Options = WebsocketParams[2];\r\n\r\nexport const connectToWebsocket = (\r\n  address: Address,\r\n  options?: Options,\r\n  diagnostics?: IDiagnosticReporter\r\n): Promise<WebSocket> => {\r\n  return new Promise((resolve, reject) => {\r\n    const server = new WebSocket(address, options);\r\n    server.once('open', () => {\r\n      resolve(server);\r\n    });\r\n\r\n    server.on('unexpected-response', (_req, res) => {\r\n      if (res.statusCode === 401) {\r\n        return reject(\r\n          new ProviderInitializationError(\r\n            'Failed to initialize the connection: Authentication Error'\r\n          )\r\n        );\r\n      }\r\n\r\n      if (res.statusCode === 403) {\r\n        return reject(\r\n          new ProviderInitializationError(\r\n            'Failed to initialize the connection: Authorization Error'\r\n          )\r\n        );\r\n      }\r\n\r\n      if (res.statusCode === 404) {\r\n        return reject(\r\n          new ProviderInitializationError(\r\n            'Failed to initialize the connection: Data transfer is not enabled on the remote host'\r\n          )\r\n        );\r\n      }\r\n\r\n      return reject(\r\n        new ProviderInitializationError(\r\n          `Failed to initialize the connection: Unexpected server response ${res.statusCode}`\r\n        )\r\n      );\r\n    });\r\n\r\n    server.on('message', (raw: RawData) => {\r\n      const response: Server.Message = JSON.parse(raw.toString());\r\n      if (response.diagnostic) {\r\n        diagnostics?.report({\r\n          ...response.diagnostic,\r\n        });\r\n      }\r\n    });\r\n\r\n    server.once('error', (err) => {\r\n      reject(\r\n        new ProviderTransferError(err.message, {\r\n          details: {\r\n            error: err.message,\r\n          },\r\n        })\r\n      );\r\n    });\r\n  });\r\n};\r\n\r\nexport const trimTrailingSlash = (input: string): string => {\r\n  return input.replace(/\\/$/, '');\r\n};\r\n\r\nexport const wait = (ms: number) => {\r\n  return new Promise<void>((resolve) => {\r\n    setTimeout(resolve, ms);\r\n  });\r\n};\r\n\r\nexport const waitUntil = async (test: () => boolean, interval: number): Promise<void> => {\r\n  while (!test()) {\r\n    await wait(interval);\r\n  }\r\n\r\n  return Promise.resolve();\r\n};\r\n","export const TRANSFER_PATH = '/transfer/runner' as const;\r\nexport const TRANSFER_METHODS = ['push', 'pull'] as const;\r\n\r\nexport type TransferPath = typeof TRANSFER_PATH;\r\nexport type TransferMethod = (typeof TRANSFER_METHODS)[number];\r\n","import { randomUUID } from 'crypto';\r\nimport { Writable } from 'stream';\r\nimport { WebSocket } from 'ws';\r\nimport { once } from 'lodash/fp';\r\nimport type { Struct, Utils } from '@strapi/types';\r\n\r\nimport { createDispatcher, connectToWebsocket, trimTrailingSlash } from '../utils';\r\n\r\nimport type {\r\n  IDestinationProvider,\r\n  IMetadata,\r\n  ProviderType,\r\n  IAsset,\r\n  TransferStage,\r\n  Protocol,\r\n} from '../../../../types';\r\nimport type { IDiagnosticReporter } from '../../../utils/diagnostic';\r\nimport type { Client, Server, Auth } from '../../../../types/remote/protocol';\r\nimport type { ILocalStrapiDestinationProviderOptions } from '../local-destination';\r\nimport { TRANSFER_PATH } from '../../remote/constants';\r\nimport { ProviderTransferError, ProviderValidationError } from '../../../errors/providers';\r\n\r\nexport interface IRemoteStrapiDestinationProviderOptions\r\n  extends Pick<ILocalStrapiDestinationProviderOptions, 'restore' | 'strategy'> {\r\n  url: URL; // the url of the remote Strapi admin\r\n  auth?: Auth.ITransferTokenAuth;\r\n  retryMessageOptions?: {\r\n    retryMessageTimeout: number; // milliseconds to wait for a response from a message\r\n    retryMessageMaxRetries: number; // max number of retries for a message before aborting transfer\r\n  };\r\n}\r\n\r\nconst jsonLength = (obj: object) => Buffer.byteLength(JSON.stringify(obj));\r\n\r\nclass RemoteStrapiDestinationProvider implements IDestinationProvider {\r\n  name = 'destination::remote-strapi';\r\n\r\n  type: ProviderType = 'destination';\r\n\r\n  options: IRemoteStrapiDestinationProviderOptions;\r\n\r\n  ws: WebSocket | null;\r\n\r\n  dispatcher: ReturnType<typeof createDispatcher> | null;\r\n\r\n  transferID: string | null;\r\n\r\n  stats!: { [TStage in Exclude<TransferStage, 'schemas'>]: { count: number } };\r\n\r\n  #diagnostics?: IDiagnosticReporter;\r\n\r\n  constructor(options: IRemoteStrapiDestinationProviderOptions) {\r\n    this.options = options;\r\n    this.ws = null;\r\n    this.dispatcher = null;\r\n    this.transferID = null;\r\n\r\n    this.resetStats();\r\n  }\r\n\r\n  private resetStats() {\r\n    this.stats = {\r\n      assets: { count: 0 },\r\n      entities: { count: 0 },\r\n      links: { count: 0 },\r\n      configuration: { count: 0 },\r\n    };\r\n  }\r\n\r\n  async initTransfer(): Promise<string> {\r\n    const { strategy, restore } = this.options;\r\n\r\n    const query = this.dispatcher?.dispatchCommand({\r\n      command: 'init',\r\n      params: { options: { strategy, restore }, transfer: 'push' },\r\n    });\r\n\r\n    const res = (await query) as Server.Payload<Server.InitMessage>;\r\n    if (!res?.transferID) {\r\n      throw new ProviderTransferError('Init failed, invalid response from the server');\r\n    }\r\n\r\n    this.resetStats();\r\n\r\n    return res.transferID;\r\n  }\r\n\r\n  #startStepOnce(stage: Client.TransferPushStep) {\r\n    return once(() => this.#startStep(stage));\r\n  }\r\n\r\n  async #startStep<T extends Client.TransferPushStep>(step: T) {\r\n    try {\r\n      await this.dispatcher?.dispatchTransferStep({ action: 'start', step });\r\n    } catch (e) {\r\n      if (e instanceof Error) {\r\n        return e;\r\n      }\r\n\r\n      if (typeof e === 'string') {\r\n        return new ProviderTransferError(e);\r\n      }\r\n\r\n      return new ProviderTransferError('Unexpected error');\r\n    }\r\n\r\n    this.stats[step] = { count: 0 };\r\n\r\n    return null;\r\n  }\r\n\r\n  async #endStep<T extends Client.TransferPushStep>(step: T) {\r\n    try {\r\n      const res = await this.dispatcher?.dispatchTransferStep<{\r\n        ok: boolean;\r\n        stats: Protocol.Client.Stats;\r\n      }>({\r\n        action: 'end',\r\n        step,\r\n      });\r\n\r\n      return { stats: res?.stats ?? null, error: null };\r\n    } catch (e) {\r\n      if (e instanceof Error) {\r\n        return { stats: null, error: e };\r\n      }\r\n\r\n      if (typeof e === 'string') {\r\n        return { stats: null, error: new ProviderTransferError(e) };\r\n      }\r\n\r\n      return { stats: null, error: new ProviderTransferError('Unexpected error') };\r\n    }\r\n  }\r\n\r\n  async #streamStep<T extends Client.TransferPushStep>(\r\n    step: T,\r\n    message: Client.GetTransferPushStreamData<T>\r\n  ) {\r\n    try {\r\n      if (step === 'assets') {\r\n        const assetMessage = message as Protocol.Client.TransferAssetFlow[];\r\n        this.stats[step].count += assetMessage.filter((data) => data.action === 'start').length;\r\n      } else {\r\n        this.stats[step].count += message.length;\r\n      }\r\n\r\n      await this.dispatcher?.dispatchTransferStep({ action: 'stream', step, data: message });\r\n    } catch (e) {\r\n      if (e instanceof Error) {\r\n        return e;\r\n      }\r\n\r\n      if (typeof e === 'string') {\r\n        return new ProviderTransferError(e);\r\n      }\r\n\r\n      return new ProviderTransferError('Unexpected error');\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  #writeStream(step: Exclude<Client.TransferPushStep, 'assets'>): Writable {\r\n    type Step = typeof step;\r\n\r\n    const batchSize = 1024 * 1024; // 1MB;\r\n    const startTransferOnce = this.#startStepOnce(step);\r\n\r\n    let batch = [] as Client.GetTransferPushStreamData<Step>;\r\n\r\n    const batchLength = () => jsonLength(batch);\r\n\r\n    return new Writable({\r\n      objectMode: true,\r\n\r\n      final: async (callback) => {\r\n        if (batch.length > 0) {\r\n          const streamError = await this.#streamStep(step, batch);\r\n\r\n          batch = [];\r\n\r\n          if (streamError) {\r\n            return callback(streamError);\r\n          }\r\n        }\r\n        const { error, stats } = await this.#endStep(step);\r\n\r\n        const { count } = this.stats[step];\r\n\r\n        if (stats && (stats.started !== count || stats.finished !== count)) {\r\n          callback(\r\n            new Error(\r\n              `Data missing: sent ${this.stats[step].count} ${step}, recieved ${stats.started} and saved ${stats.finished} ${step}`\r\n            )\r\n          );\r\n        }\r\n\r\n        callback(error);\r\n      },\r\n\r\n      write: async (chunk, _encoding, callback) => {\r\n        const startError = await startTransferOnce();\r\n        if (startError) {\r\n          return callback(startError);\r\n        }\r\n\r\n        batch.push(chunk);\r\n\r\n        if (batchLength() >= batchSize) {\r\n          const streamError = await this.#streamStep(step, batch);\r\n\r\n          batch = [];\r\n\r\n          if (streamError) {\r\n            return callback(streamError);\r\n          }\r\n        }\r\n\r\n        callback();\r\n      },\r\n    });\r\n  }\r\n\r\n  #reportInfo(message: string) {\r\n    this.#diagnostics?.report({\r\n      details: {\r\n        createdAt: new Date(),\r\n        message,\r\n        origin: 'remote-destination-provider',\r\n      },\r\n      kind: 'info',\r\n    });\r\n  }\r\n\r\n  async bootstrap(diagnostics?: IDiagnosticReporter): Promise<void> {\r\n    this.#diagnostics = diagnostics;\r\n    const { url, auth } = this.options;\r\n    const validProtocols = ['https:', 'http:'];\r\n\r\n    let ws: WebSocket;\r\n\r\n    if (!validProtocols.includes(url.protocol)) {\r\n      throw new ProviderValidationError(`Invalid protocol \"${url.protocol}\"`, {\r\n        check: 'url',\r\n        details: {\r\n          protocol: url.protocol,\r\n          validProtocols,\r\n        },\r\n      });\r\n    }\r\n    const wsProtocol = url.protocol === 'https:' ? 'wss:' : 'ws:';\r\n    const wsUrl = `${wsProtocol}//${url.host}${trimTrailingSlash(\r\n      url.pathname\r\n    )}${TRANSFER_PATH}/push`;\r\n\r\n    this.#reportInfo('establishing websocket connection');\r\n    // No auth defined, trying public access for transfer\r\n    if (!auth) {\r\n      ws = await connectToWebsocket(wsUrl, undefined, this.#diagnostics);\r\n    }\r\n\r\n    // Common token auth, this should be the main auth method\r\n    else if (auth.type === 'token') {\r\n      const headers = { Authorization: `Bearer ${auth.token}` };\r\n      ws = await connectToWebsocket(wsUrl, { headers }, this.#diagnostics);\r\n    }\r\n\r\n    // Invalid auth method provided\r\n    else {\r\n      throw new ProviderValidationError('Auth method not available', {\r\n        check: 'auth.type',\r\n        details: {\r\n          auth: auth.type,\r\n        },\r\n      });\r\n    }\r\n\r\n    this.#reportInfo('established websocket connection');\r\n\r\n    this.ws = ws;\r\n    const { retryMessageOptions } = this.options;\r\n\r\n    this.#reportInfo('creating dispatcher');\r\n    this.dispatcher = createDispatcher(this.ws, retryMessageOptions, (message: string) =>\r\n      this.#reportInfo(message)\r\n    );\r\n    this.#reportInfo('created dispatcher');\r\n\r\n    this.#reportInfo('initialize transfer');\r\n    this.transferID = await this.initTransfer();\r\n    this.#reportInfo(`initialized transfer ${this.transferID}`);\r\n\r\n    this.dispatcher.setTransferProperties({ id: this.transferID, kind: 'push' });\r\n\r\n    await this.dispatcher.dispatchTransferAction('bootstrap');\r\n  }\r\n\r\n  async close() {\r\n    // Gracefully close the remote transfer process\r\n    if (this.transferID && this.dispatcher) {\r\n      await this.dispatcher.dispatchTransferAction('close');\r\n\r\n      await this.dispatcher.dispatchCommand({\r\n        command: 'end',\r\n        params: { transferID: this.transferID },\r\n      });\r\n    }\r\n\r\n    await new Promise<void>((resolve) => {\r\n      const { ws } = this;\r\n\r\n      if (!ws || ws.CLOSED) {\r\n        resolve();\r\n        return;\r\n      }\r\n\r\n      ws.on('close', () => resolve()).close();\r\n    });\r\n  }\r\n\r\n  getMetadata() {\r\n    return this.dispatcher?.dispatchTransferAction<IMetadata>('getMetadata') ?? null;\r\n  }\r\n\r\n  async beforeTransfer() {\r\n    await this.dispatcher?.dispatchTransferAction('beforeTransfer');\r\n  }\r\n\r\n  async rollback() {\r\n    await this.dispatcher?.dispatchTransferAction('rollback');\r\n  }\r\n\r\n  getSchemas() {\r\n    if (!this.dispatcher) {\r\n      return Promise.resolve(null);\r\n    }\r\n\r\n    return this.dispatcher.dispatchTransferAction<Utils.String.Dict<Struct.Schema>>('getSchemas');\r\n  }\r\n\r\n  createEntitiesWriteStream(): Writable {\r\n    return this.#writeStream('entities');\r\n  }\r\n\r\n  createLinksWriteStream(): Writable {\r\n    return this.#writeStream('links');\r\n  }\r\n\r\n  createConfigurationWriteStream(): Writable {\r\n    return this.#writeStream('configuration');\r\n  }\r\n\r\n  createAssetsWriteStream(): Writable | Promise<Writable> {\r\n    let batch: Client.TransferAssetFlow[] = [];\r\n    let hasStarted = false;\r\n\r\n    const batchSize = 1024 * 1024; // 1MB;\r\n    const batchLength = () => {\r\n      return batch.reduce(\r\n        (acc, chunk) => (chunk.action === 'stream' ? acc + chunk.data.byteLength : acc),\r\n        0\r\n      );\r\n    };\r\n    const startAssetsTransferOnce = this.#startStepOnce('assets');\r\n\r\n    const flush = async () => {\r\n      const streamError = await this.#streamStep('assets', batch);\r\n      batch = [];\r\n      return streamError;\r\n    };\r\n\r\n    const safePush = async (chunk: Client.TransferAssetFlow) => {\r\n      batch.push(chunk);\r\n\r\n      if (batchLength() >= batchSize) {\r\n        const streamError = await flush();\r\n        if (streamError) {\r\n          throw streamError;\r\n        }\r\n      }\r\n    };\r\n\r\n    return new Writable({\r\n      objectMode: true,\r\n      final: async (callback) => {\r\n        if (batch.length > 0) {\r\n          await flush();\r\n        }\r\n\r\n        if (hasStarted) {\r\n          const { error: endStepError } = await this.#endStep('assets');\r\n\r\n          if (endStepError) {\r\n            return callback(endStepError);\r\n          }\r\n        }\r\n\r\n        return callback(null);\r\n      },\r\n\r\n      async write(asset: IAsset, _encoding, callback) {\r\n        const startError = await startAssetsTransferOnce();\r\n        if (startError) {\r\n          return callback(startError);\r\n        }\r\n\r\n        hasStarted = true;\r\n\r\n        const assetID = randomUUID();\r\n        const { filename, filepath, stats, stream, metadata } = asset;\r\n\r\n        try {\r\n          await safePush({\r\n            action: 'start',\r\n            assetID,\r\n            data: { filename, filepath, stats, metadata },\r\n          });\r\n\r\n          for await (const chunk of stream) {\r\n            await safePush({ action: 'stream', assetID, data: chunk });\r\n          }\r\n\r\n          await safePush({ action: 'end', assetID });\r\n\r\n          callback();\r\n        } catch (error) {\r\n          if (error instanceof Error) {\r\n            callback(error);\r\n          }\r\n        }\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nexport const createRemoteStrapiDestinationProvider = (\r\n  options: IRemoteStrapiDestinationProviderOptions\r\n) => {\r\n  return new RemoteStrapiDestinationProvider(options);\r\n};\r\n","import { PassThrough, Readable, Writable } from 'stream';\r\nimport type { Struct, Utils } from '@strapi/types';\r\nimport { WebSocket } from 'ws';\r\nimport { castArray } from 'lodash/fp';\r\n\r\nimport type {\r\n  IAsset,\r\n  IMetadata,\r\n  ISourceProvider,\r\n  ISourceProviderTransferResults,\r\n  MaybePromise,\r\n  Protocol,\r\n  ProviderType,\r\n  TransferStage,\r\n} from '../../../../types';\r\nimport type { IDiagnosticReporter } from '../../../utils/diagnostic';\r\nimport { Client, Server, Auth } from '../../../../types/remote/protocol';\r\nimport { ProviderTransferError, ProviderValidationError } from '../../../errors/providers';\r\nimport { TRANSFER_PATH } from '../../remote/constants';\r\nimport { ILocalStrapiSourceProviderOptions } from '../local-source';\r\nimport { createDispatcher, connectToWebsocket, trimTrailingSlash, wait, waitUntil } from '../utils';\r\n\r\nexport interface IRemoteStrapiSourceProviderOptions extends ILocalStrapiSourceProviderOptions {\r\n  url: URL; // the url of the remote Strapi admin\r\n  auth?: Auth.ITransferTokenAuth;\r\n  retryMessageOptions?: {\r\n    retryMessageTimeout: number; // milliseconds to wait for a response from a message\r\n    retryMessageMaxRetries: number; // max number of retries for a message before aborting transfer\r\n  };\r\n}\r\n\r\nclass RemoteStrapiSourceProvider implements ISourceProvider {\r\n  name = 'source::remote-strapi';\r\n\r\n  type: ProviderType = 'source';\r\n\r\n  options: IRemoteStrapiSourceProviderOptions;\r\n\r\n  ws: WebSocket | null;\r\n\r\n  dispatcher: ReturnType<typeof createDispatcher> | null;\r\n\r\n  constructor(options: IRemoteStrapiSourceProviderOptions) {\r\n    this.options = options;\r\n    this.ws = null;\r\n    this.dispatcher = null;\r\n  }\r\n\r\n  results?: ISourceProviderTransferResults | undefined;\r\n\r\n  #diagnostics?: IDiagnosticReporter;\r\n\r\n  async #createStageReadStream(stage: Exclude<TransferStage, 'schemas'>) {\r\n    const startResult = await this.#startStep(stage);\r\n\r\n    if (startResult instanceof Error) {\r\n      throw startResult;\r\n    }\r\n\r\n    const { id: processID } = startResult as { id: string };\r\n\r\n    const stream = new PassThrough({ objectMode: true });\r\n\r\n    const listener = async (raw: Buffer) => {\r\n      const parsed = JSON.parse(raw.toString());\r\n      // If not a message related to our transfer process, ignore it\r\n      if (!parsed.uuid || parsed?.data?.type !== 'transfer' || parsed?.data?.id !== processID) {\r\n        this.ws?.once('message', listener);\r\n        return;\r\n      }\r\n\r\n      const { uuid, data: message } = parsed;\r\n      const { ended, error, data } = message;\r\n\r\n      if (error) {\r\n        await this.#respond(uuid);\r\n        stream.destroy(error);\r\n        return;\r\n      }\r\n\r\n      if (ended) {\r\n        await this.#respond(uuid);\r\n        await this.#endStep(stage);\r\n\r\n        stream.end();\r\n        return;\r\n      }\r\n\r\n      // if we get a single items instead of a batch\r\n      for (const item of castArray(data)) {\r\n        stream.push(item);\r\n      }\r\n\r\n      this.ws?.once('message', listener);\r\n\r\n      await this.#respond(uuid);\r\n    };\r\n\r\n    this.ws?.once('message', listener);\r\n\r\n    return stream;\r\n  }\r\n\r\n  createEntitiesReadStream(): MaybePromise<Readable> {\r\n    return this.#createStageReadStream('entities');\r\n  }\r\n\r\n  createLinksReadStream(): MaybePromise<Readable> {\r\n    return this.#createStageReadStream('links');\r\n  }\r\n\r\n  writeAsync = <T>(stream: Writable, data: T) => {\r\n    return new Promise<void>((resolve, reject) => {\r\n      stream.write(data, (error) => {\r\n        if (error) {\r\n          reject(error);\r\n        }\r\n\r\n        resolve();\r\n      });\r\n    });\r\n  };\r\n\r\n  async createAssetsReadStream(): Promise<Readable> {\r\n    // Create the streams used to transfer the assets\r\n    const stream = await this.#createStageReadStream('assets');\r\n    const pass = new PassThrough({ objectMode: true });\r\n\r\n    // Init the asset map\r\n    const assets: {\r\n      [filename: string]: IAsset & {\r\n        stream: PassThrough;\r\n        queue: Array<Protocol.Client.TransferAssetFlow & { action: 'stream' }>;\r\n        status: 'idle' | 'busy' | 'closed' | 'errored';\r\n      };\r\n    } = {};\r\n\r\n    stream\r\n      /**\r\n       * Process a payload of many transfer assets and performs the following tasks:\r\n       * - Start: creates a stream for new assets.\r\n       * - Stream: writes asset chunks to the asset's stream.\r\n       * - End: closes the stream after the asset s transferred and cleanup related resources.\r\n       */\r\n      .on('data', async (payload: Protocol.Client.TransferAssetFlow[]) => {\r\n        for (const item of payload) {\r\n          const { action, assetID } = item;\r\n\r\n          // Creates the stream to send the incoming asset through\r\n          if (action === 'start') {\r\n            // Ignore the item if a transfer has already been started for the same asset ID\r\n            if (assets[assetID]) {\r\n              continue;\r\n            }\r\n\r\n            // Register the asset\r\n            assets[assetID] = {\r\n              ...item.data,\r\n              stream: new PassThrough(),\r\n              status: 'idle',\r\n              queue: [],\r\n            };\r\n\r\n            // Connect the individual asset stream to the main asset stage stream\r\n            // Note: nothing is transferred until data chunks are fed to the asset stream\r\n            await this.writeAsync(pass, assets[assetID]);\r\n          }\r\n\r\n          // Writes the asset's data chunks to their corresponding stream\r\n          else if (action === 'stream') {\r\n            // If the asset hasn't been registered, or if it's been closed already, then ignore the message\r\n            if (!assets[assetID]) {\r\n              continue;\r\n            }\r\n\r\n            switch (assets[assetID].status) {\r\n              // The asset is ready to accept a new chunk, write it now\r\n              case 'idle':\r\n                await writeAssetChunk(assetID, item.data);\r\n                break;\r\n              // The resource is busy, queue the current chunk so that it gets transferred as soon as possible\r\n              case 'busy':\r\n                assets[assetID].queue.push(item);\r\n                break;\r\n              // Ignore asset chunks for assets with a closed/errored status\r\n              case 'closed':\r\n              case 'errored':\r\n              default:\r\n                break;\r\n            }\r\n          }\r\n\r\n          // All the asset chunks have been transferred\r\n          else if (action === 'end') {\r\n            // If the asset has already been closed, or if it was never registered, ignore the command\r\n            if (!assets[assetID]) {\r\n              continue;\r\n            }\r\n\r\n            switch (assets[assetID].status) {\r\n              // There's no ongoing activity, the asset is ready to be closed\r\n              case 'idle':\r\n              case 'errored':\r\n                await closeAssetStream(assetID);\r\n                break;\r\n              // The resource is busy, wait for a different state and close the stream.\r\n              case 'busy':\r\n                await Promise.race([\r\n                  // Either: wait for the asset to be ready to be closed\r\n                  waitUntil(() => assets[assetID].status !== 'busy', 100),\r\n                  // Or: if the last chunks are still not processed after ten seconds\r\n                  wait(10000),\r\n                ]);\r\n\r\n                await closeAssetStream(assetID);\r\n                break;\r\n              // Ignore commands for assets being currently closed\r\n              case 'closed':\r\n              default:\r\n                break;\r\n            }\r\n          }\r\n        }\r\n      })\r\n      .on('close', () => {\r\n        pass.end();\r\n      });\r\n\r\n    /**\r\n     * Writes a chunk of data for the specified asset with the given id.\r\n     */\r\n    const writeAssetChunk = async (id: string, data: unknown) => {\r\n      if (!assets[id]) {\r\n        throw new Error(`Failed to write asset chunk for \"${id}\". Asset not found.`);\r\n      }\r\n\r\n      const { status: currentStatus } = assets[id];\r\n\r\n      if (currentStatus !== 'idle') {\r\n        throw new Error(\r\n          `Failed to write asset chunk for \"${id}\". The asset is currently \"${currentStatus}\"`\r\n        );\r\n      }\r\n\r\n      const nextItemInQueue = () => assets[id].queue.shift();\r\n\r\n      try {\r\n        // Lock the asset\r\n        assets[id].status = 'busy';\r\n\r\n        // Save the current chunk\r\n        await unsafe_writeAssetChunk(id, data);\r\n\r\n        // Empty the queue if needed\r\n        let item = nextItemInQueue();\r\n\r\n        while (item) {\r\n          await unsafe_writeAssetChunk(id, item.data);\r\n          item = nextItemInQueue();\r\n        }\r\n\r\n        // Unlock the asset\r\n        assets[id].status = 'idle';\r\n      } catch {\r\n        assets[id].status = 'errored';\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Writes a chunk of data to the asset's stream.\r\n     *\r\n     * Only check if the targeted asset exists, no other validation is done.\r\n     */\r\n    const unsafe_writeAssetChunk = async (id: string, data: unknown) => {\r\n      const asset = assets[id];\r\n\r\n      if (!asset) {\r\n        throw new Error(`Failed to write asset chunk for \"${id}\". Asset not found.`);\r\n      }\r\n\r\n      const rawBuffer = data as { type: 'Buffer'; data: Uint8Array };\r\n      const chunk = Buffer.from(rawBuffer.data);\r\n\r\n      await this.writeAsync(asset.stream, chunk);\r\n    };\r\n\r\n    /**\r\n     * Closes the asset stream associated with the given ID.\r\n     *\r\n     * It deletes the stream for the asset upon successful closure.\r\n     */\r\n    const closeAssetStream = async (id: string) => {\r\n      if (!assets[id]) {\r\n        throw new Error(`Failed to close asset \"${id}\". Asset not found.`);\r\n      }\r\n\r\n      assets[id].status = 'closed';\r\n\r\n      await new Promise<void>((resolve, reject) => {\r\n        const { stream } = assets[id];\r\n\r\n        stream\r\n          .on('close', () => {\r\n            delete assets[id];\r\n\r\n            resolve();\r\n          })\r\n          .on('error', reject)\r\n          .end();\r\n      });\r\n    };\r\n\r\n    return pass;\r\n  }\r\n\r\n  createConfigurationReadStream(): MaybePromise<Readable> {\r\n    return this.#createStageReadStream('configuration');\r\n  }\r\n\r\n  async getMetadata(): Promise<IMetadata | null> {\r\n    const metadata = await this.dispatcher?.dispatchTransferAction<IMetadata>('getMetadata');\r\n\r\n    return metadata ?? null;\r\n  }\r\n\r\n  assertValidProtocol(url: URL) {\r\n    const validProtocols = ['https:', 'http:'];\r\n\r\n    if (!validProtocols.includes(url.protocol)) {\r\n      throw new ProviderValidationError(`Invalid protocol \"${url.protocol}\"`, {\r\n        check: 'url',\r\n        details: {\r\n          protocol: url.protocol,\r\n          validProtocols,\r\n        },\r\n      });\r\n    }\r\n  }\r\n\r\n  async initTransfer(): Promise<string> {\r\n    const query = this.dispatcher?.dispatchCommand({\r\n      command: 'init',\r\n    });\r\n\r\n    const res = (await query) as Server.Payload<Server.InitMessage>;\r\n\r\n    if (!res?.transferID) {\r\n      throw new ProviderTransferError('Init failed, invalid response from the server');\r\n    }\r\n\r\n    return res.transferID;\r\n  }\r\n\r\n  #reportInfo(message: string) {\r\n    this.#diagnostics?.report({\r\n      details: {\r\n        createdAt: new Date(),\r\n        message,\r\n        origin: 'remote-source-provider',\r\n      },\r\n      kind: 'info',\r\n    });\r\n  }\r\n\r\n  async bootstrap(diagnostics?: IDiagnosticReporter): Promise<void> {\r\n    this.#diagnostics = diagnostics;\r\n    const { url, auth } = this.options;\r\n    let ws: WebSocket;\r\n    this.assertValidProtocol(url);\r\n    const wsProtocol = url.protocol === 'https:' ? 'wss:' : 'ws:';\r\n    const wsUrl = `${wsProtocol}//${url.host}${trimTrailingSlash(\r\n      url.pathname\r\n    )}${TRANSFER_PATH}/pull`;\r\n\r\n    this.#reportInfo('establishing websocket connection');\r\n    // No auth defined, trying public access for transfer\r\n    if (!auth) {\r\n      ws = await connectToWebsocket(wsUrl, undefined, this.#diagnostics);\r\n    }\r\n\r\n    // Common token auth, this should be the main auth method\r\n    else if (auth.type === 'token') {\r\n      const headers = { Authorization: `Bearer ${auth.token}` };\r\n      ws = await connectToWebsocket(wsUrl, { headers }, this.#diagnostics);\r\n    }\r\n\r\n    // Invalid auth method provided\r\n    else {\r\n      throw new ProviderValidationError('Auth method not available', {\r\n        check: 'auth.type',\r\n        details: {\r\n          auth: auth.type,\r\n        },\r\n      });\r\n    }\r\n\r\n    this.#reportInfo('established websocket connection');\r\n    this.ws = ws;\r\n    const { retryMessageOptions } = this.options;\r\n\r\n    this.#reportInfo('creating dispatcher');\r\n    this.dispatcher = createDispatcher(this.ws, retryMessageOptions, (message: string) =>\r\n      this.#reportInfo(message)\r\n    );\r\n    this.#reportInfo('creating dispatcher');\r\n\r\n    this.#reportInfo('initialize transfer');\r\n    const transferID = await this.initTransfer();\r\n    this.#reportInfo(`initialized transfer ${transferID}`);\r\n\r\n    this.dispatcher.setTransferProperties({ id: transferID, kind: 'pull' });\r\n    await this.dispatcher.dispatchTransferAction('bootstrap');\r\n  }\r\n\r\n  async close() {\r\n    await this.dispatcher?.dispatchTransferAction('close');\r\n\r\n    await new Promise<void>((resolve) => {\r\n      const { ws } = this;\r\n\r\n      if (!ws || ws.CLOSED) {\r\n        resolve();\r\n        return;\r\n      }\r\n\r\n      ws.on('close', () => resolve()).close();\r\n    });\r\n  }\r\n\r\n  async getSchemas() {\r\n    const schemas =\r\n      await this.dispatcher?.dispatchTransferAction<Utils.String.Dict<Struct.Schema>>('getSchemas');\r\n\r\n    return schemas ?? null;\r\n  }\r\n\r\n  async #startStep<T extends Client.TransferPullStep>(step: T) {\r\n    try {\r\n      return await this.dispatcher?.dispatchTransferStep({ action: 'start', step });\r\n    } catch (e) {\r\n      if (e instanceof Error) {\r\n        return e;\r\n      }\r\n\r\n      if (typeof e === 'string') {\r\n        return new ProviderTransferError(e);\r\n      }\r\n\r\n      return new ProviderTransferError('Unexpected error');\r\n    }\r\n  }\r\n\r\n  async #respond(uuid: string) {\r\n    return new Promise((resolve, reject) => {\r\n      this.ws?.send(JSON.stringify({ uuid }), (e) => {\r\n        if (e) {\r\n          reject(e);\r\n        } else {\r\n          resolve(e);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  async #endStep<T extends Client.TransferPullStep>(step: T) {\r\n    try {\r\n      await this.dispatcher?.dispatchTransferStep({ action: 'end', step });\r\n    } catch (e) {\r\n      if (e instanceof Error) {\r\n        return e;\r\n      }\r\n\r\n      if (typeof e === 'string') {\r\n        return new ProviderTransferError(e);\r\n      }\r\n\r\n      return new ProviderTransferError('Unexpected error');\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\nexport const createRemoteStrapiSourceProvider = (options: IRemoteStrapiSourceProviderOptions) => {\r\n  return new RemoteStrapiSourceProvider(options);\r\n};\r\n","import type { Step } from '.';\r\n\r\nexport default [\r\n  {\r\n    kind: 'action',\r\n    action: 'bootstrap',\r\n  },\r\n  {\r\n    kind: 'action',\r\n    action: 'init',\r\n  },\r\n  {\r\n    kind: 'action',\r\n    action: 'beforeTransfer',\r\n  },\r\n  {\r\n    kind: 'transfer',\r\n    stage: 'schemas',\r\n  },\r\n  {\r\n    kind: 'transfer',\r\n    stage: 'entities',\r\n  },\r\n  {\r\n    kind: 'transfer',\r\n    stage: 'assets',\r\n  },\r\n  {\r\n    kind: 'transfer',\r\n    stage: 'links',\r\n  },\r\n  {\r\n    kind: 'transfer',\r\n    stage: 'configuration',\r\n  },\r\n  {\r\n    kind: 'action',\r\n    action: 'close',\r\n  },\r\n] as readonly Step[];\r\n","import type { TransferStage } from '../../../../types';\r\n\r\nexport type Step =\r\n  | { kind: 'action'; action: string }\r\n  | { kind: 'transfer'; stage: TransferStage; locked?: boolean };\r\n\r\nexport { default as DEFAULT_TRANSFER_FLOW } from './default';\r\n\r\ninterface IState {\r\n  step: Step | null;\r\n}\r\n\r\nexport interface TransferFlow {\r\n  has(step: Step): boolean;\r\n  can(step: Step): boolean;\r\n  cannot(step: Step): boolean;\r\n  set(step: Step): this;\r\n  get(): Step | null;\r\n}\r\n\r\nexport const createFlow = (flow: readonly Step[]): TransferFlow => {\r\n  const state: IState = { step: null };\r\n\r\n  /**\r\n   * Equality check between two steps\r\n   */\r\n  const stepEqual = (stepA: Step, stepB: Step): boolean => {\r\n    if (stepA.kind === 'action' && stepB.kind === 'action') {\r\n      return stepA.action === stepB.action;\r\n    }\r\n\r\n    if (stepA.kind === 'transfer' && stepB.kind === 'transfer') {\r\n      return stepA.stage === stepB.stage;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Find the index for a given step\r\n   */\r\n  const findStepIndex = (step: Step) => flow.findIndex((flowStep) => stepEqual(step, flowStep));\r\n\r\n  return {\r\n    has(step: Step) {\r\n      return findStepIndex(step) !== -1;\r\n    },\r\n\r\n    can(step: Step) {\r\n      if (state.step === null) {\r\n        return true;\r\n      }\r\n\r\n      const indexesDifference = findStepIndex(step) - findStepIndex(state.step);\r\n\r\n      // It's possible to send multiple time the same transfer step in a row\r\n      if (indexesDifference === 0 && step.kind === 'transfer') {\r\n        return true;\r\n      }\r\n\r\n      return indexesDifference > 0;\r\n    },\r\n\r\n    cannot(step: Step) {\r\n      return !this.can(step);\r\n    },\r\n\r\n    set(step: Step) {\r\n      const canSwitch = this.can(step);\r\n\r\n      if (!canSwitch) {\r\n        throw new Error('Impossible to proceed to the given step');\r\n      }\r\n\r\n      state.step = step;\r\n\r\n      return this;\r\n    },\r\n\r\n    get() {\r\n      return state.step;\r\n    },\r\n  };\r\n};\r\n","export const VALID_TRANSFER_COMMANDS = ['init', 'end', 'status'] as const;\r\nexport type ValidTransferCommand = (typeof VALID_TRANSFER_COMMANDS)[number];\r\n","import type { IncomingMessage } from 'node:http';\r\nimport { randomUUID } from 'crypto';\r\nimport type { Context } from 'koa';\r\nimport type { RawData, ServerOptions } from 'ws';\r\nimport { WebSocket, WebSocketServer } from 'ws';\r\n\r\nimport type { Handler, TransferState } from './abstract';\r\nimport type { Protocol } from '../../../../types';\r\nimport { ProviderError, ProviderTransferError } from '../../../errors/providers';\r\nimport { VALID_TRANSFER_COMMANDS, ValidTransferCommand } from './constants';\r\nimport { TransferMethod } from '../constants';\r\nimport { createDiagnosticReporter } from '../../../utils/diagnostic';\r\n\r\ntype WSCallback = (client: WebSocket, request: IncomingMessage) => void;\r\n\r\nexport interface HandlerOptions {\r\n  verify: (ctx: Context, scope?: TransferMethod) => Promise<void>;\r\n  server?: ServerOptions;\r\n}\r\n\r\nexport const transformUpgradeHeader = (header = '') => {\r\n  return header.split(',').map((s) => s.trim().toLowerCase());\r\n};\r\n\r\nlet timeouts: Record<string, number> | undefined;\r\n\r\nconst hasHttpServer = () => {\r\n  // during server restarts, strapi may not have ever been defined at all, so we have to check it first\r\n  return typeof strapi !== 'undefined' && !!strapi?.server?.httpServer;\r\n};\r\n\r\n// temporarily disable server timeouts while transfer is running\r\nconst disableTimeouts = () => {\r\n  if (!hasHttpServer()) {\r\n    return;\r\n  }\r\n\r\n  const { httpServer } = strapi.server;\r\n\r\n  // save the original timeouts to restore after\r\n  if (!timeouts) {\r\n    timeouts = {\r\n      headersTimeout: httpServer.headersTimeout,\r\n      requestTimeout: httpServer.requestTimeout,\r\n    };\r\n  }\r\n\r\n  httpServer.headersTimeout = 0;\r\n  httpServer.requestTimeout = 0;\r\n\r\n  strapi.log.info('[Data transfer] Disabling http timeouts');\r\n};\r\nconst resetTimeouts = () => {\r\n  if (!hasHttpServer() || !timeouts) {\r\n    return;\r\n  }\r\n\r\n  const { httpServer } = strapi.server;\r\n\r\n  strapi.log.info('[Data transfer] Restoring http timeouts');\r\n  httpServer.headersTimeout = timeouts.headersTimeout;\r\n  httpServer.requestTimeout = timeouts.requestTimeout;\r\n};\r\n/**\r\n * Make sure that the upgrade header is a valid websocket one\r\n */\r\nexport const assertValidHeader = (ctx: Context) => {\r\n  // if it's exactly what we expect, it's fine\r\n  if (ctx.headers.upgrade === 'websocket') {\r\n    return;\r\n  }\r\n\r\n  // check if it could be an array that still includes websocket\r\n  const upgradeHeader = transformUpgradeHeader(ctx.headers.upgrade);\r\n\r\n  // Sanitize user input before writing it to our logs\r\n  const logSafeUpgradeHeader = JSON.stringify(ctx.headers.upgrade)\r\n    ?.replace(/[^a-z0-9\\s.,|]/gi, '')\r\n    .substring(0, 50);\r\n\r\n  if (!upgradeHeader.includes('websocket')) {\r\n    throw new Error(\r\n      `Transfer Upgrade header expected 'websocket', found '${logSafeUpgradeHeader}'. Please ensure that your server or proxy is not modifying the Upgrade header.`\r\n    );\r\n  }\r\n\r\n  /**\r\n   * If there's more than expected but it still includes websocket, in theory it could still work\r\n   * and could be necessary for their certain configurations, so we'll allow it to proceed but\r\n   * log the unexpected behaviour in case it helps debug an issue\r\n   * */\r\n  strapi.log.info(\r\n    `Transfer Upgrade header expected only 'websocket', found unexpected values: ${logSafeUpgradeHeader}`\r\n  );\r\n};\r\n\r\nexport const isDataTransferMessage = (message: unknown): message is Protocol.Client.Message => {\r\n  if (!message || typeof message !== 'object') {\r\n    return false;\r\n  }\r\n\r\n  const { uuid, type } = message as Record<string, unknown>;\r\n\r\n  if (typeof uuid !== 'string' || typeof type !== 'string') {\r\n    return false;\r\n  }\r\n\r\n  if (!['command', 'transfer'].includes(type)) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n/**\r\n * Handle the upgrade to ws connection\r\n */\r\nexport const handleWSUpgrade = (wss: WebSocketServer, ctx: Context, callback: WSCallback) => {\r\n  assertValidHeader(ctx);\r\n\r\n  wss.handleUpgrade(ctx.req, ctx.request.socket, Buffer.alloc(0), (client, request) => {\r\n    if (!client) {\r\n      // If the WebSocket upgrade failed, destroy the socket to avoid hanging\r\n      ctx.request.socket.destroy();\r\n      return;\r\n    }\r\n\r\n    disableTimeouts();\r\n\r\n    // Create a connection between the client & the server\r\n    wss.emit('connection', client, ctx.req);\r\n\r\n    // Invoke the ws callback\r\n    callback(client, request);\r\n  });\r\n\r\n  ctx.respond = false;\r\n};\r\n\r\n// Protocol related functions\r\n\r\nexport const handlerControllerFactory =\r\n  <T extends Partial<Handler>>(implementation: (proto: Handler) => T) =>\r\n  (options: HandlerOptions) => {\r\n    const { verify, server: serverOptions } = options ?? {};\r\n\r\n    const wss = new WebSocket.Server({ ...serverOptions, noServer: true });\r\n\r\n    return async (ctx: Context) => {\r\n      const cb: WSCallback = (ws) => {\r\n        const state: TransferState = { id: undefined };\r\n        const messageUUIDs = new Set<string>();\r\n        const diagnostics = createDiagnosticReporter();\r\n\r\n        const cannotRespondHandler = (err: unknown) => {\r\n          strapi?.log?.error(\r\n            '[Data transfer] Cannot send error response to client, closing connection'\r\n          );\r\n          strapi?.log?.error(err);\r\n          try {\r\n            ws.terminate();\r\n            ctx.req.socket.destroy();\r\n          } catch (err) {\r\n            strapi?.log?.error('[Data transfer] Failed to close socket on error');\r\n          }\r\n        };\r\n\r\n        const prototype: Handler = {\r\n          // Transfer ID\r\n          get transferID() {\r\n            return state.id;\r\n          },\r\n\r\n          set transferID(id) {\r\n            state.id = id;\r\n          },\r\n\r\n          // Started at\r\n          get startedAt() {\r\n            return state.startedAt;\r\n          },\r\n\r\n          set startedAt(timestamp) {\r\n            state.startedAt = timestamp;\r\n          },\r\n\r\n          get response() {\r\n            return state.response;\r\n          },\r\n\r\n          set response(response) {\r\n            state.response = response;\r\n          },\r\n\r\n          get diagnostics() {\r\n            return diagnostics;\r\n          },\r\n\r\n          addUUID(uuid) {\r\n            messageUUIDs.add(uuid);\r\n          },\r\n\r\n          hasUUID(uuid) {\r\n            return messageUUIDs.has(uuid);\r\n          },\r\n\r\n          isTransferStarted() {\r\n            return this.transferID !== undefined && this.startedAt !== undefined;\r\n          },\r\n\r\n          assertValidTransfer() {\r\n            const isStarted = this.isTransferStarted();\r\n\r\n            if (!isStarted) {\r\n              throw new Error('Invalid Transfer Process');\r\n            }\r\n          },\r\n\r\n          assertValidTransferCommand(command: ValidTransferCommand) {\r\n            const isDefined = typeof this[command] === 'function';\r\n            const isValidTransferCommand = VALID_TRANSFER_COMMANDS.includes(command);\r\n\r\n            if (!isDefined || !isValidTransferCommand) {\r\n              throw new Error('Invalid transfer command');\r\n            }\r\n          },\r\n\r\n          async respond(uuid, e, data) {\r\n            let details = {};\r\n            return new Promise<void>((resolve, reject) => {\r\n              if (!uuid && !e) {\r\n                reject(new Error('Missing uuid for this message'));\r\n                return;\r\n              }\r\n\r\n              this.response = {\r\n                uuid,\r\n                data,\r\n                e,\r\n              };\r\n\r\n              if (e instanceof ProviderError) {\r\n                details = e.details;\r\n              }\r\n\r\n              const payload = JSON.stringify({\r\n                uuid,\r\n                data: data ?? null,\r\n                error: e\r\n                  ? {\r\n                      code: e?.name ?? 'ERR',\r\n                      message: e?.message,\r\n                      details,\r\n                    }\r\n                  : null,\r\n              });\r\n\r\n              this.send(payload, (error) => (error ? reject(error) : resolve()));\r\n            });\r\n          },\r\n\r\n          send(message, cb) {\r\n            ws.send(message, cb);\r\n          },\r\n          confirm(message) {\r\n            return new Promise((resolve, reject) => {\r\n              const uuid = randomUUID();\r\n\r\n              const payload = JSON.stringify({ uuid, data: message });\r\n\r\n              this.send(payload, (error) => {\r\n                if (error) {\r\n                  reject(error);\r\n                }\r\n              });\r\n\r\n              const onResponse = (raw: RawData) => {\r\n                const response = JSON.parse(raw.toString());\r\n\r\n                if (response.uuid === uuid) {\r\n                  resolve(response.data ?? null);\r\n                } else {\r\n                  ws.once('message', onResponse);\r\n                }\r\n              };\r\n\r\n              ws.once('message', onResponse);\r\n            });\r\n          },\r\n\r\n          async executeAndRespond(uuid, fn) {\r\n            try {\r\n              const response = await fn();\r\n              await this.respond(uuid, null, response);\r\n            } catch (e) {\r\n              if (e instanceof Error) {\r\n                await this.respond(uuid, e).catch(cannotRespondHandler);\r\n              } else if (typeof e === 'string') {\r\n                await this.respond(uuid, new ProviderTransferError(e)).catch(cannotRespondHandler);\r\n              } else {\r\n                await this.respond(\r\n                  uuid,\r\n                  new ProviderTransferError('Unexpected error', {\r\n                    error: e,\r\n                  })\r\n                ).catch(cannotRespondHandler);\r\n              }\r\n            }\r\n          },\r\n\r\n          cleanup() {\r\n            this.transferID = undefined;\r\n            this.startedAt = undefined;\r\n            this.response = undefined;\r\n          },\r\n\r\n          teardown() {\r\n            this.cleanup();\r\n          },\r\n\r\n          verifyAuth(scope?: TransferMethod) {\r\n            return verify(ctx, scope);\r\n          },\r\n\r\n          // Transfer commands\r\n          init() {},\r\n          end() {},\r\n          status() {},\r\n\r\n          // Default prototype implementation for events\r\n          onMessage() {},\r\n          onError() {},\r\n          onClose() {},\r\n          onInfo() {},\r\n          onWarning() {},\r\n        };\r\n\r\n        const handler: Handler = Object.assign(Object.create(prototype), implementation(prototype));\r\n\r\n        // Bind ws events to handler methods\r\n        ws.on('close', async (...args) => {\r\n          try {\r\n            await handler.onClose(...args);\r\n          } catch (err) {\r\n            strapi?.log?.error('[Data transfer] Uncaught error closing connection');\r\n            strapi?.log?.error(err);\r\n            cannotRespondHandler(err);\r\n          } finally {\r\n            resetTimeouts();\r\n          }\r\n        });\r\n        ws.on('error', async (...args) => {\r\n          try {\r\n            await handler.onError(...args);\r\n          } catch (err) {\r\n            strapi?.log?.error('[Data transfer] Uncaught error in error handling');\r\n            strapi?.log?.error(err);\r\n            cannotRespondHandler(err);\r\n          }\r\n        });\r\n        ws.on('message', async (...args) => {\r\n          try {\r\n            await handler.onMessage(...args);\r\n          } catch (err) {\r\n            strapi?.log?.error('[Data transfer] Uncaught error in message handling');\r\n            strapi?.log?.error(err);\r\n            cannotRespondHandler(err);\r\n          }\r\n        });\r\n\r\n        diagnostics.onDiagnostic((diagnostic) => {\r\n          const uuid = randomUUID();\r\n          const payload = JSON.stringify({\r\n            diagnostic,\r\n            uuid,\r\n          });\r\n\r\n          handler.send(payload);\r\n        });\r\n      };\r\n\r\n      try {\r\n        handleWSUpgrade(wss, ctx, cb);\r\n      } catch (err) {\r\n        strapi?.log?.error('[Data transfer] Error in websocket upgrade request');\r\n        strapi?.log?.error(err);\r\n      }\r\n    };\r\n  };\r\n","import { randomUUID } from 'crypto';\r\nimport { Writable, PassThrough } from 'stream';\r\nimport { type Core } from '@strapi/types';\r\n\r\nimport type { TransferFlow, Step } from '../flows';\r\nimport type { TransferStage, IAsset, Protocol } from '../../../../types';\r\n\r\nimport { ProviderTransferError } from '../../../errors/providers';\r\nimport { createLocalStrapiDestinationProvider } from '../../providers';\r\nimport { createFlow, DEFAULT_TRANSFER_FLOW } from '../flows';\r\nimport { Handler } from './abstract';\r\nimport { handlerControllerFactory, isDataTransferMessage } from './utils';\r\n\r\nconst VALID_TRANSFER_ACTIONS = [\r\n  'bootstrap',\r\n  'close',\r\n  'rollback',\r\n  'beforeTransfer',\r\n  'getMetadata',\r\n  'getSchemas',\r\n] as const;\r\n\r\ntype PushTransferAction = (typeof VALID_TRANSFER_ACTIONS)[number];\r\n\r\nconst TRANSFER_KIND = 'push';\r\n\r\nexport interface PushHandler extends Handler {\r\n  /**\r\n   * Local Strapi Destination Provider used to write data to the current Strapi instance\r\n   */\r\n  provider?: ReturnType<typeof createLocalStrapiDestinationProvider>;\r\n\r\n  /**\r\n   * Holds all the stages' stream for the current transfer handler (one registry per connection)\r\n   */\r\n  streams?: { [stage in TransferStage]?: Writable };\r\n\r\n  stats: {\r\n    [stage in Exclude<TransferStage, 'schemas'>]: Protocol.Client.Stats;\r\n  };\r\n\r\n  /**\r\n   * Holds all the transferred assets for the current transfer handler (one registry per connection)\r\n   */\r\n  assets: { [filepath: string]: IAsset & { stream: PassThrough } };\r\n\r\n  /**\r\n   * Ochestrate and manage the transfer messages' ordering\r\n   */\r\n  flow?: TransferFlow;\r\n\r\n  /**\r\n   * Checks that the given action is a valid push transfer action\r\n   */\r\n  assertValidTransferAction(action: string): asserts action is PushTransferAction;\r\n\r\n  /**\r\n   * Create a new writable stream for the given step in the handler's stream registry\r\n   */\r\n  createWritableStreamForStep(step: TransferStage): Promise<void>;\r\n\r\n  /**\r\n   * Simple override of the auth verification\r\n   */\r\n  verifyAuth(): Promise<void>;\r\n\r\n  /**\r\n   * Callback when receiving a regular transfer message\r\n   */\r\n  onTransferMessage(msg: Protocol.Client.TransferMessage): Promise<unknown> | unknown;\r\n\r\n  /**\r\n   * Callback when receiving a transfer action message\r\n   */\r\n  onTransferAction(msg: Protocol.Client.Action): Promise<unknown> | unknown;\r\n\r\n  /**\r\n   * Callback when receiving a transfer step message\r\n   */\r\n  onTransferStep(msg: Protocol.Client.TransferPushMessage): Promise<unknown> | unknown;\r\n\r\n  /**\r\n   * Start streaming an asset\r\n   */\r\n  streamAsset(\r\n    this: PushHandler,\r\n    payload: Protocol.Client.GetTransferPushStreamData<'assets'>\r\n  ): Promise<void>;\r\n\r\n  // Transfer Flow\r\n\r\n  /**\r\n   * Try to move to a specific transfer stage & lock the step\r\n   */\r\n  lockTransferStep(stage: TransferStage): void;\r\n\r\n  /**\r\n   * Try to move to unlock the current step\r\n   */\r\n  unlockTransferStep(stage: TransferStage): void;\r\n\r\n  /**\r\n   * Checks whether it's possible to stream a chunk for the given stage\r\n   */\r\n  assertValidStreamTransferStep(stage: TransferStage): void;\r\n}\r\n\r\nconst writeAsync = <T>(stream: Writable, data: T) => {\r\n  return new Promise<void>((resolve, reject) => {\r\n    stream.write(data, (error) => {\r\n      if (error) {\r\n        reject(error);\r\n      }\r\n\r\n      resolve();\r\n    });\r\n  });\r\n};\r\n\r\nexport const createPushController = handlerControllerFactory<Partial<PushHandler>>((proto) => ({\r\n  isTransferStarted(this: PushHandler) {\r\n    return proto.isTransferStarted.call(this) && this.provider !== undefined;\r\n  },\r\n\r\n  verifyAuth(this: PushHandler) {\r\n    return proto.verifyAuth.call(this, TRANSFER_KIND);\r\n  },\r\n  onInfo(message) {\r\n    this.diagnostics?.report({\r\n      details: {\r\n        message,\r\n        origin: 'push-handler',\r\n        createdAt: new Date(),\r\n      },\r\n      kind: 'info',\r\n    });\r\n  },\r\n  onWarning(message) {\r\n    this.diagnostics?.report({\r\n      details: {\r\n        message,\r\n        createdAt: new Date(),\r\n        origin: 'push-handler',\r\n      },\r\n      kind: 'warning',\r\n    });\r\n  },\r\n  cleanup(this: PushHandler) {\r\n    proto.cleanup.call(this);\r\n\r\n    this.streams = {};\r\n    this.assets = {};\r\n\r\n    delete this.flow;\r\n    delete this.provider;\r\n  },\r\n\r\n  teardown(this: PushHandler) {\r\n    if (this.provider) {\r\n      this.provider.rollback();\r\n    }\r\n\r\n    proto.teardown.call(this);\r\n  },\r\n\r\n  assertValidTransfer(this: PushHandler) {\r\n    proto.assertValidTransfer.call(this);\r\n\r\n    if (this.provider === undefined) {\r\n      throw new Error('Invalid Transfer Process');\r\n    }\r\n  },\r\n\r\n  assertValidTransferAction(this: PushHandler, action: PushTransferAction) {\r\n    if (VALID_TRANSFER_ACTIONS.includes(action)) {\r\n      return;\r\n    }\r\n\r\n    throw new ProviderTransferError(`Invalid action provided: \"${action}\"`, {\r\n      action,\r\n      validActions: Object.keys(VALID_TRANSFER_ACTIONS),\r\n    });\r\n  },\r\n\r\n  assertValidStreamTransferStep(this: PushHandler, stage) {\r\n    const currentStep = this.flow?.get();\r\n    const nextStep: Step = { kind: 'transfer', stage };\r\n\r\n    if (currentStep?.kind === 'transfer' && !currentStep.locked) {\r\n      throw new ProviderTransferError(\r\n        `You need to initialize the transfer stage (${nextStep}) before starting to stream data`\r\n      );\r\n    }\r\n\r\n    if (this.flow?.cannot(nextStep)) {\r\n      throw new ProviderTransferError(`Invalid stage (${nextStep}) provided for the current flow`, {\r\n        step: nextStep,\r\n      });\r\n    }\r\n  },\r\n\r\n  async createWritableStreamForStep(this: PushHandler, step: Exclude<TransferStage, 'schemas'>) {\r\n    const mapper = {\r\n      entities: () => this.provider?.createEntitiesWriteStream(),\r\n      links: () => this.provider?.createLinksWriteStream(),\r\n      configuration: () => this.provider?.createConfigurationWriteStream(),\r\n      assets: () => this.provider?.createAssetsWriteStream(),\r\n    };\r\n\r\n    if (!(step in mapper)) {\r\n      throw new Error('Invalid transfer step, impossible to create a stream');\r\n    }\r\n\r\n    if (!this.streams) {\r\n      throw new Error('Invalid transfer state');\r\n    }\r\n\r\n    this.streams[step] = await mapper[step]();\r\n  },\r\n\r\n  async onMessage(this: PushHandler, raw) {\r\n    const msg = JSON.parse(raw.toString());\r\n\r\n    if (!isDataTransferMessage(msg)) {\r\n      return;\r\n    }\r\n\r\n    if (!msg.uuid) {\r\n      await this.respond(undefined, new Error('Missing uuid in message'));\r\n    }\r\n\r\n    if (proto.hasUUID(msg.uuid)) {\r\n      const previousResponse = proto.response;\r\n      if (previousResponse?.uuid === msg.uuid) {\r\n        await this.respond(previousResponse?.uuid, previousResponse.e, previousResponse.data);\r\n      }\r\n      return;\r\n    }\r\n\r\n    const { uuid, type } = msg;\r\n    proto.addUUID(uuid);\r\n    // Regular command message (init, end, status)\r\n    if (type === 'command') {\r\n      const { command } = msg;\r\n      this.onInfo(`received command:${command} uuid:${uuid}`);\r\n      await this.executeAndRespond(uuid, () => {\r\n        this.assertValidTransferCommand(command);\r\n\r\n        // The status command don't have params\r\n        if (command === 'status') {\r\n          return this.status();\r\n        }\r\n        return this[command](msg.params);\r\n      });\r\n    }\r\n\r\n    // Transfer message (the transfer must be init first)\r\n    else if (type === 'transfer') {\r\n      this.onInfo(`received transfer action:${msg.action} step:${msg.kind} uuid:${uuid}`);\r\n      await this.executeAndRespond(uuid, async () => {\r\n        await this.verifyAuth();\r\n\r\n        this.assertValidTransfer();\r\n\r\n        return this.onTransferMessage(msg);\r\n      });\r\n    }\r\n\r\n    // Invalid messages\r\n    else {\r\n      await this.respond(uuid, new Error('Bad Request'));\r\n    }\r\n  },\r\n\r\n  async onTransferMessage(this: PushHandler, msg) {\r\n    const { kind } = msg;\r\n\r\n    if (kind === 'action') {\r\n      return this.onTransferAction(msg);\r\n    }\r\n\r\n    if (kind === 'step') {\r\n      return this.onTransferStep(msg as Protocol.Client.TransferPushMessage);\r\n    }\r\n  },\r\n\r\n  lockTransferStep(stage: TransferStage) {\r\n    const currentStep = this.flow?.get();\r\n    const nextStep: Step = { kind: 'transfer', stage };\r\n\r\n    if (currentStep?.kind === 'transfer' && currentStep.locked) {\r\n      throw new ProviderTransferError(\r\n        `It's not possible to start a new transfer stage (${stage}) while another one is in progress (${currentStep.stage})`\r\n      );\r\n    }\r\n\r\n    if (this.flow?.cannot(nextStep)) {\r\n      throw new ProviderTransferError(`Invalid stage (${stage}) provided for the current flow`, {\r\n        step: nextStep,\r\n      });\r\n    }\r\n\r\n    this.flow?.set({ ...nextStep, locked: true });\r\n  },\r\n\r\n  unlockTransferStep(stage: TransferStage) {\r\n    const currentStep = this.flow?.get();\r\n    const nextStep: Step = { kind: 'transfer', stage };\r\n\r\n    // Cannot unlock if not locked (aka: started)\r\n    if (currentStep?.kind === 'transfer' && !currentStep.locked) {\r\n      throw new ProviderTransferError(\r\n        `You need to initialize the transfer stage (${stage}) before ending it`\r\n      );\r\n    }\r\n\r\n    // Cannot unlock if invalid step provided\r\n    if (this.flow?.cannot(nextStep)) {\r\n      throw new ProviderTransferError(`Invalid stage (${stage}) provided for the current flow`, {\r\n        step: nextStep,\r\n      });\r\n    }\r\n\r\n    this.flow?.set({ ...nextStep, locked: false });\r\n  },\r\n\r\n  async onTransferStep(this: PushHandler, msg) {\r\n    const { step: stage } = msg;\r\n\r\n    if (msg.action === 'start') {\r\n      this.lockTransferStep(stage);\r\n\r\n      if (this.streams?.[stage] instanceof Writable) {\r\n        throw new Error('Stream already created, something went wrong');\r\n      }\r\n\r\n      await this.createWritableStreamForStep(stage);\r\n\r\n      this.stats[stage] = { started: 0, finished: 0 };\r\n\r\n      return { ok: true };\r\n    }\r\n\r\n    if (msg.action === 'stream') {\r\n      this.assertValidStreamTransferStep(stage);\r\n\r\n      // Stream operation on the current transfer stage\r\n      const stream = this.streams?.[stage];\r\n\r\n      if (!stream) {\r\n        throw new Error('You need to init first');\r\n      }\r\n\r\n      // Assets are nested streams\r\n      if (stage === 'assets') {\r\n        return this.streamAsset(msg.data);\r\n      }\r\n\r\n      // For all other steps\r\n      await Promise.all(\r\n        msg.data.map(async (item) => {\r\n          this.stats[stage].started += 1;\r\n          await writeAsync(stream, item);\r\n          this.stats[stage].finished += 1;\r\n        })\r\n      );\r\n    }\r\n\r\n    if (msg.action === 'end') {\r\n      this.unlockTransferStep(stage);\r\n      const stream = this.streams?.[stage];\r\n\r\n      if (stream && !stream.closed) {\r\n        await new Promise((resolve, reject) => {\r\n          stream.on('close', resolve).on('error', reject).end();\r\n        });\r\n      }\r\n\r\n      delete this.streams?.[stage];\r\n\r\n      return { ok: true, stats: this.stats[stage] };\r\n    }\r\n  },\r\n\r\n  async onTransferAction(this: PushHandler, msg) {\r\n    const { action } = msg;\r\n\r\n    this.assertValidTransferAction(action);\r\n\r\n    const step: Step = { kind: 'action', action };\r\n    const isStepRegistered = this.flow?.has(step);\r\n\r\n    if (isStepRegistered) {\r\n      if (this.flow?.cannot(step)) {\r\n        throw new ProviderTransferError(`Invalid action \"${action}\" found for the current flow `, {\r\n          action,\r\n        });\r\n      }\r\n\r\n      this.flow?.set(step);\r\n    }\r\n    if (action === 'bootstrap') {\r\n      return this.provider?.[action](this.diagnostics);\r\n    }\r\n    return this.provider?.[action]();\r\n  },\r\n\r\n  async streamAsset(this: PushHandler, payload) {\r\n    const assetsStream = this.streams?.assets;\r\n\r\n    // TODO: close the stream upon receiving an 'end' event instead\r\n    if (payload === null) {\r\n      this.streams?.assets?.end();\r\n      return;\r\n    }\r\n\r\n    for (const item of payload) {\r\n      const { action, assetID } = item;\r\n\r\n      if (!assetsStream) {\r\n        throw new Error('Stream not defined');\r\n      }\r\n\r\n      if (action === 'start') {\r\n        this.stats.assets.started += 1;\r\n        this.assets[assetID] = { ...item.data, stream: new PassThrough() };\r\n        writeAsync(assetsStream, this.assets[assetID]);\r\n      }\r\n\r\n      if (action === 'stream') {\r\n        // The buffer has gone through JSON operations and is now of shape { type: \"Buffer\"; data: UInt8Array }\r\n        // We need to transform it back into a Buffer instance\r\n        const rawBuffer = item.data as unknown as { type: 'Buffer'; data: Uint8Array };\r\n        const chunk = Buffer.from(rawBuffer.data);\r\n        await writeAsync(this.assets[assetID].stream, chunk);\r\n      }\r\n\r\n      if (action === 'end') {\r\n        await new Promise<void>((resolve, reject) => {\r\n          const { stream: assetStream } = this.assets[assetID];\r\n          assetStream\r\n            .on('close', () => {\r\n              this.stats.assets.finished += 1;\r\n              delete this.assets[assetID];\r\n              resolve();\r\n            })\r\n            .on('error', reject)\r\n            .end();\r\n        });\r\n      }\r\n    }\r\n  },\r\n\r\n  onClose(this: Handler) {\r\n    this.teardown();\r\n  },\r\n\r\n  onError(this: Handler, err) {\r\n    this.teardown();\r\n    strapi.log.error(err);\r\n  },\r\n\r\n  // Commands\r\n\r\n  async init(\r\n    this: PushHandler,\r\n    params: Protocol.Client.GetCommandParams<'init'>\r\n  ): Promise<Protocol.Server.Payload<Protocol.Server.InitMessage>> {\r\n    if (this.transferID || this.provider) {\r\n      throw new Error('Transfer already in progress');\r\n    }\r\n\r\n    await this.verifyAuth();\r\n\r\n    this.transferID = randomUUID();\r\n    this.startedAt = Date.now();\r\n\r\n    this.assets = {};\r\n    this.streams = {};\r\n    this.stats = {\r\n      assets: { started: 0, finished: 0 },\r\n      configuration: { started: 0, finished: 0 },\r\n      entities: { started: 0, finished: 0 },\r\n      links: { started: 0, finished: 0 },\r\n    };\r\n\r\n    this.flow = createFlow(DEFAULT_TRANSFER_FLOW);\r\n\r\n    this.provider = createLocalStrapiDestinationProvider({\r\n      ...params.options,\r\n      autoDestroy: false,\r\n      getStrapi: () => strapi as Core.Strapi,\r\n    });\r\n\r\n    this.provider.onWarning = (message) => {\r\n      this.onWarning(message);\r\n      strapi.log.warn(message);\r\n    };\r\n\r\n    return { transferID: this.transferID };\r\n  },\r\n\r\n  async status(this: PushHandler) {\r\n    const isStarted = this.isTransferStarted();\r\n\r\n    if (isStarted) {\r\n      const startedAt = this.startedAt as number;\r\n\r\n      return {\r\n        active: true,\r\n        kind: TRANSFER_KIND,\r\n        startedAt,\r\n        elapsed: Date.now() - startedAt,\r\n      };\r\n    }\r\n\r\n    return { active: false, kind: null, elapsed: null, startedAt: null };\r\n  },\r\n\r\n  async end(\r\n    this: PushHandler,\r\n    params: Protocol.Client.GetCommandParams<'end'>\r\n  ): Promise<Protocol.Server.Payload<Protocol.Server.EndMessage>> {\r\n    await this.verifyAuth();\r\n\r\n    if (this.transferID !== params?.transferID) {\r\n      throw new ProviderTransferError('Bad transfer ID provided');\r\n    }\r\n\r\n    this.cleanup();\r\n\r\n    return { ok: true };\r\n  },\r\n}));\r\n","import { Readable } from 'stream';\r\nimport { randomUUID } from 'crypto';\r\nimport type { Core } from '@strapi/types';\r\n\r\nimport { Handler } from './abstract';\r\nimport { handlerControllerFactory, isDataTransferMessage } from './utils';\r\nimport { createLocalStrapiSourceProvider, ILocalStrapiSourceProvider } from '../../providers';\r\nimport { ProviderTransferError } from '../../../errors/providers';\r\nimport type { IAsset, TransferStage, Protocol } from '../../../../types';\r\nimport { Client } from '../../../../types/remote/protocol';\r\n\r\nconst TRANSFER_KIND = 'pull';\r\nconst VALID_TRANSFER_ACTIONS = ['bootstrap', 'close', 'getMetadata', 'getSchemas'] as const;\r\n\r\ntype PullTransferAction = (typeof VALID_TRANSFER_ACTIONS)[number];\r\n\r\nexport interface PullHandler extends Handler {\r\n  provider?: ILocalStrapiSourceProvider;\r\n\r\n  streams?: { [stage in TransferStage]?: Readable };\r\n\r\n  assertValidTransferAction(action: string): asserts action is PullTransferAction;\r\n\r\n  onTransferMessage(msg: Protocol.Client.TransferMessage): Promise<unknown> | unknown;\r\n  onTransferAction(msg: Protocol.Client.Action): Promise<unknown> | unknown;\r\n  onTransferStep(msg: Protocol.Client.TransferPullMessage): Promise<unknown> | unknown;\r\n\r\n  createReadableStreamForStep(step: TransferStage): Promise<void>;\r\n\r\n  flush(stage: TransferStage, id: string): Promise<void> | void;\r\n}\r\n\r\nexport const createPullController = handlerControllerFactory<Partial<PullHandler>>((proto) => ({\r\n  isTransferStarted(this: PullHandler) {\r\n    return proto.isTransferStarted.call(this) && this.provider !== undefined;\r\n  },\r\n\r\n  verifyAuth(this: PullHandler) {\r\n    return proto.verifyAuth.call(this, TRANSFER_KIND);\r\n  },\r\n\r\n  cleanup(this: PullHandler) {\r\n    proto.cleanup.call(this);\r\n\r\n    this.streams = {};\r\n\r\n    delete this.provider;\r\n  },\r\n\r\n  onInfo(message) {\r\n    this.diagnostics?.report({\r\n      details: {\r\n        message,\r\n        origin: 'pull-handler',\r\n        createdAt: new Date(),\r\n      },\r\n      kind: 'info',\r\n    });\r\n  },\r\n  onWarning(message) {\r\n    this.diagnostics?.report({\r\n      details: {\r\n        message,\r\n        createdAt: new Date(),\r\n        origin: 'pull-handler',\r\n      },\r\n      kind: 'warning',\r\n    });\r\n  },\r\n\r\n  assertValidTransferAction(this: PullHandler, action) {\r\n    // Abstract the constant to string[] to allow looser check on the given action\r\n    const validActions = VALID_TRANSFER_ACTIONS as unknown as string[];\r\n\r\n    if (validActions.includes(action)) {\r\n      return;\r\n    }\r\n\r\n    throw new ProviderTransferError(`Invalid action provided: \"${action}\"`, {\r\n      action,\r\n      validActions: Object.keys(VALID_TRANSFER_ACTIONS),\r\n    });\r\n  },\r\n\r\n  async onMessage(this: PullHandler, raw) {\r\n    const msg = JSON.parse(raw.toString());\r\n\r\n    if (!isDataTransferMessage(msg)) {\r\n      return;\r\n    }\r\n\r\n    if (!msg.uuid) {\r\n      await this.respond(undefined, new Error('Missing uuid in message'));\r\n    }\r\n\r\n    if (proto.hasUUID(msg.uuid)) {\r\n      const previousResponse = proto.response;\r\n      if (previousResponse?.uuid === msg.uuid) {\r\n        await this.respond(previousResponse?.uuid, previousResponse.e, previousResponse.data);\r\n      }\r\n      return;\r\n    }\r\n\r\n    const { uuid, type } = msg;\r\n    proto.addUUID(uuid);\r\n    // Regular command message (init, end, status)\r\n    if (type === 'command') {\r\n      const { command } = msg;\r\n      this.onInfo(`received command:${command} uuid:${uuid}`);\r\n      await this.executeAndRespond(uuid, () => {\r\n        this.assertValidTransferCommand(command);\r\n\r\n        // The status command don't have params\r\n        if (command === 'status') {\r\n          return this.status();\r\n        }\r\n\r\n        return this[command](msg.params);\r\n      });\r\n    }\r\n\r\n    // Transfer message (the transfer must be init first)\r\n    else if (type === 'transfer') {\r\n      this.onInfo(`received transfer action:${msg.action} step:${msg.kind} uuid:${uuid}`);\r\n      await this.executeAndRespond(uuid, async () => {\r\n        await this.verifyAuth();\r\n\r\n        this.assertValidTransfer();\r\n\r\n        return this.onTransferMessage(msg);\r\n      });\r\n    }\r\n\r\n    // Invalid messages\r\n    else {\r\n      await this.respond(uuid, new Error('Bad Request'));\r\n    }\r\n  },\r\n\r\n  async onTransferMessage(this: PullHandler, msg) {\r\n    const { kind } = msg;\r\n\r\n    if (kind === 'action') {\r\n      return this.onTransferAction(msg);\r\n    }\r\n\r\n    if (kind === 'step') {\r\n      return this.onTransferStep(msg as Protocol.Client.TransferPullMessage);\r\n    }\r\n  },\r\n\r\n  async onTransferAction(this: PullHandler, msg) {\r\n    const { action } = msg;\r\n\r\n    this.assertValidTransferAction(action);\r\n\r\n    if (action === 'bootstrap') {\r\n      return this.provider?.[action](this.diagnostics);\r\n    }\r\n    return this.provider?.[action]();\r\n  },\r\n\r\n  async flush(this: PullHandler, stage: Client.TransferPullStep, id) {\r\n    type Stage = typeof stage;\r\n    const batchSize = 1024 * 1024;\r\n    let batch = [] as Client.GetTransferPullStreamData<Stage>;\r\n    const stream = this.streams?.[stage];\r\n\r\n    const batchLength = () => Buffer.byteLength(JSON.stringify(batch));\r\n    const sendBatch = async () => {\r\n      await this.confirm({\r\n        type: 'transfer',\r\n        data: batch,\r\n        ended: false,\r\n        error: null,\r\n        id,\r\n      });\r\n    };\r\n\r\n    if (!stream) {\r\n      throw new ProviderTransferError(`No available stream found for ${stage}`);\r\n    }\r\n\r\n    try {\r\n      for await (const chunk of stream) {\r\n        if (stage !== 'assets') {\r\n          batch.push(chunk);\r\n          if (batchLength() >= batchSize) {\r\n            await sendBatch();\r\n            batch = [];\r\n          }\r\n        } else {\r\n          await this.confirm({\r\n            type: 'transfer',\r\n            data: [chunk],\r\n            ended: false,\r\n            error: null,\r\n            id,\r\n          });\r\n        }\r\n      }\r\n\r\n      if (batch.length > 0 && stage !== 'assets') {\r\n        await sendBatch();\r\n        batch = [];\r\n      }\r\n      await this.confirm({ type: 'transfer', data: null, ended: true, error: null, id });\r\n    } catch (e) {\r\n      await this.confirm({ type: 'transfer', data: null, ended: true, error: e, id });\r\n    }\r\n  },\r\n\r\n  async onTransferStep(this: PullHandler, msg) {\r\n    const { step, action } = msg;\r\n\r\n    if (action === 'start') {\r\n      if (this.streams?.[step] instanceof Readable) {\r\n        throw new Error('Stream already created, something went wrong');\r\n      }\r\n\r\n      const flushUUID = randomUUID();\r\n\r\n      await this.createReadableStreamForStep(step);\r\n      this.flush(step, flushUUID);\r\n\r\n      return { ok: true, id: flushUUID };\r\n    }\r\n\r\n    if (action === 'end') {\r\n      const stream = this.streams?.[step];\r\n\r\n      if (stream?.readableEnded === false) {\r\n        await new Promise((resolve) => {\r\n          stream?.on('close', resolve).destroy();\r\n        });\r\n      }\r\n\r\n      delete this.streams?.[step];\r\n\r\n      return { ok: true };\r\n    }\r\n  },\r\n\r\n  async createReadableStreamForStep(this: PullHandler, step: Exclude<TransferStage, 'schemas'>) {\r\n    const mapper = {\r\n      entities: () => this.provider?.createEntitiesReadStream(),\r\n      links: () => this.provider?.createLinksReadStream(),\r\n      configuration: () => this.provider?.createConfigurationReadStream(),\r\n      assets: () => {\r\n        const assets = this.provider?.createAssetsReadStream();\r\n        let batch: Protocol.Client.TransferAssetFlow[] = [];\r\n\r\n        const batchLength = () => {\r\n          return batch.reduce(\r\n            (acc, chunk) => (chunk.action === 'stream' ? acc + chunk.data.byteLength : acc),\r\n            0\r\n          );\r\n        };\r\n\r\n        const BATCH_MAX_SIZE = 1024 * 1024; // 1MB\r\n\r\n        if (!assets) {\r\n          throw new Error('bad');\r\n        }\r\n        /**\r\n         * Generates batches of 1MB of data from the assets stream to avoid\r\n         * sending too many small chunks\r\n         *\r\n         * @param stream Assets stream from the local source provider\r\n         */\r\n        async function* generator(stream: Readable) {\r\n          let hasStarted = false;\r\n          let assetID = '';\r\n\r\n          for await (const chunk of stream) {\r\n            const { stream: assetStream, ...assetData } = chunk as IAsset;\r\n            if (!hasStarted) {\r\n              assetID = randomUUID();\r\n              // Start the transfer of a new asset\r\n              batch.push({ action: 'start', assetID, data: assetData });\r\n              hasStarted = true;\r\n            }\r\n\r\n            for await (const assetChunk of assetStream) {\r\n              // Add the asset data to the batch\r\n              batch.push({ action: 'stream', assetID, data: assetChunk });\r\n\r\n              // if the batch size is bigger than BATCH_MAX_SIZE stream the batch\r\n              if (batchLength() >= BATCH_MAX_SIZE) {\r\n                yield batch;\r\n                batch = [];\r\n              }\r\n            }\r\n\r\n            // All the asset data has been streamed and gets ready for the next one\r\n            hasStarted = false;\r\n            batch.push({ action: 'end', assetID });\r\n            yield batch;\r\n            batch = [];\r\n          }\r\n        }\r\n\r\n        return Readable.from(generator(assets));\r\n      },\r\n    };\r\n\r\n    if (!(step in mapper)) {\r\n      throw new Error('Invalid transfer step, impossible to create a stream');\r\n    }\r\n\r\n    if (!this.streams) {\r\n      throw new Error('Invalid transfer state');\r\n    }\r\n\r\n    this.streams[step] = await mapper[step]();\r\n  },\r\n\r\n  // Commands\r\n  async init(this: PullHandler) {\r\n    if (this.transferID || this.provider) {\r\n      throw new Error('Transfer already in progress');\r\n    }\r\n    await this.verifyAuth();\r\n\r\n    this.transferID = randomUUID();\r\n    this.startedAt = Date.now();\r\n\r\n    this.streams = {};\r\n\r\n    this.provider = createLocalStrapiSourceProvider({\r\n      autoDestroy: false,\r\n      getStrapi: () => strapi as Core.Strapi,\r\n    });\r\n\r\n    return { transferID: this.transferID };\r\n  },\r\n\r\n  async end(\r\n    this: PullHandler,\r\n    params: Protocol.Client.GetCommandParams<'end'>\r\n  ): Promise<Protocol.Server.Payload<Protocol.Server.EndMessage>> {\r\n    await this.verifyAuth();\r\n\r\n    if (this.transferID !== params?.transferID) {\r\n      throw new ProviderTransferError('Bad transfer ID provided');\r\n    }\r\n\r\n    this.cleanup();\r\n\r\n    return { ok: true };\r\n  },\r\n\r\n  async status(this: PullHandler) {\r\n    const isStarted = this.isTransferStarted();\r\n\r\n    if (!isStarted) {\r\n      const startedAt = this.startedAt as number;\r\n      return {\r\n        active: true,\r\n        kind: TRANSFER_KIND,\r\n        startedAt,\r\n        elapsed: Date.now() - startedAt,\r\n      };\r\n    }\r\n    return { active: false, kind: null, elapsed: null, startedAt: null };\r\n  },\r\n}));\r\n","import path from 'path';\r\n\r\n/**\r\n * Note: in versions of the transfer engine <=4.9.0, exports were generated with windows paths\r\n * on Windows systems, and posix paths on posix systems.\r\n *\r\n * We now store all paths as posix, but need to leave a separator conversion for legacy purposes, and to\r\n * support manually-created tar files coming from Windows systems (ie, if a user creates a\r\n * backup file with a windows tar tool rather than using the `export` command)\r\n *\r\n * Because of this, export/import files may never contain files with a forward slash in the name, even escaped\r\n *\r\n * */\r\n\r\n/**\r\n * Check if the directory of a given filePath (which can be either posix or win32) resolves to the same as the given posix-format path posixDirName\r\n * We must be able to assume the first argument is a path to a directory and the second is a path to a file, otherwise path.dirname will interpret a path without any slashes as the filename\r\n *\r\n * @param {string} posixDirName A posix path pointing to a directory\r\n * @param {string} filePath an unknown filesystem path pointing to a file\r\n * @returns {boolean} is the file located in the given directory\r\n */\r\nexport const isFilePathInDirname = (posixDirName: string, filePath: string) => {\r\n  const normalizedDir = path.posix.dirname(unknownPathToPosix(filePath));\r\n  return isPathEquivalent(posixDirName, normalizedDir);\r\n};\r\n\r\n/**\r\n *  Check if two paths that can be either in posix or win32 format resolves to the same file\r\n *\r\n * @param {string} pathA a path that may be either win32 or posix\r\n * @param {string} pathB a path that may be either win32 or posix\r\n *\r\n * @returns {boolean} do paths point to the same place\r\n */\r\nexport const isPathEquivalent = (pathA: string, pathB: string) => {\r\n  // Check if paths appear to be win32 or posix, and if win32 convert to posix\r\n  const normalizedPathA = path.posix.normalize(unknownPathToPosix(pathA));\r\n  const normalizedPathB = path.posix.normalize(unknownPathToPosix(pathB));\r\n\r\n  return !path.posix.relative(normalizedPathB, normalizedPathA).length;\r\n};\r\n\r\n/**\r\n *  Convert an unknown format path (win32 or posix) to a posix path\r\n *\r\n * @param {string} filePath a path that may be either win32 or posix\r\n *\r\n * @returns {string} a posix path\r\n */\r\nexport const unknownPathToPosix = (filePath: string) => {\r\n  // if it includes a forward slash, it must be posix already -- we will not support win32 with mixed path separators\r\n  if (filePath.includes(path.posix.sep)) {\r\n    return filePath;\r\n  }\r\n\r\n  return path.normalize(filePath).split(path.win32.sep).join(path.posix.sep);\r\n};\r\n","import type { Readable } from 'stream';\r\n\r\nimport zip from 'zlib';\r\nimport path from 'path';\r\nimport { pipeline, PassThrough } from 'stream';\r\nimport fs from 'fs-extra';\r\nimport tar from 'tar';\r\nimport { isEmpty, keyBy } from 'lodash/fp';\r\nimport { chain } from 'stream-chain';\r\nimport { parser } from 'stream-json/jsonl/Parser';\r\nimport type { Struct } from '@strapi/types';\r\n\r\nimport type { IAsset, IMetadata, ISourceProvider, ProviderType, IFile } from '../../../../types';\r\nimport type { IDiagnosticReporter } from '../../../utils/diagnostic';\r\n\r\nimport * as utils from '../../../utils';\r\nimport { ProviderInitializationError, ProviderTransferError } from '../../../errors/providers';\r\nimport { isFilePathInDirname, isPathEquivalent, unknownPathToPosix } from './utils';\r\n\r\ntype StreamItemArray = Parameters<typeof chain>[0];\r\n\r\n/**\r\n * Constant for the metadata file path\r\n */\r\nconst METADATA_FILE_PATH = 'metadata.json';\r\n\r\n/**\r\n * Provider options\r\n */\r\nexport interface ILocalFileSourceProviderOptions {\r\n  file: {\r\n    path: string; // the file to load\r\n  };\r\n\r\n  encryption: {\r\n    enabled: boolean; // if the file is encrypted (and should be decrypted)\r\n    key?: string; // the key to decrypt the file\r\n  };\r\n\r\n  compression: {\r\n    enabled: boolean; // if the file is compressed (and should be decompressed)\r\n  };\r\n}\r\n\r\nexport const createLocalFileSourceProvider = (options: ILocalFileSourceProviderOptions) => {\r\n  return new LocalFileSourceProvider(options);\r\n};\r\n\r\nclass LocalFileSourceProvider implements ISourceProvider {\r\n  type: ProviderType = 'source';\r\n\r\n  name = 'source::local-file';\r\n\r\n  options: ILocalFileSourceProviderOptions;\r\n\r\n  #metadata?: IMetadata;\r\n\r\n  #diagnostics?: IDiagnosticReporter;\r\n\r\n  constructor(options: ILocalFileSourceProviderOptions) {\r\n    this.options = options;\r\n\r\n    const { encryption } = this.options;\r\n\r\n    if (encryption.enabled && encryption.key === undefined) {\r\n      throw new Error('Missing encryption key');\r\n    }\r\n  }\r\n\r\n  #reportInfo(message: string) {\r\n    this.#diagnostics?.report({\r\n      details: {\r\n        createdAt: new Date(),\r\n        message,\r\n        origin: 'file-source-provider',\r\n      },\r\n      kind: 'info',\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Pre flight checks regarding the provided options, making sure that the file can be opened (decrypted, decompressed), etc.\r\n   */\r\n  async bootstrap(diagnostics: IDiagnosticReporter) {\r\n    this.#diagnostics = diagnostics;\r\n    const { path: filePath } = this.options.file;\r\n\r\n    try {\r\n      // Read the metadata to ensure the file can be parsed\r\n      await this.#loadMetadata();\r\n      // TODO: we might also need to read the schema.jsonl files & implements a custom stream-check\r\n    } catch (e) {\r\n      if (this.options?.encryption?.enabled) {\r\n        throw new ProviderInitializationError(\r\n          `Key is incorrect or the file '${filePath}' is not a valid Strapi data file.`\r\n        );\r\n      }\r\n      throw new ProviderInitializationError(`File '${filePath}' is not a valid Strapi data file.`);\r\n    }\r\n\r\n    if (!this.#metadata) {\r\n      throw new ProviderInitializationError('Could not load metadata from Strapi data file.');\r\n    }\r\n  }\r\n\r\n  async #loadMetadata() {\r\n    const backupStream = this.#getBackupStream();\r\n    this.#metadata = await this.#parseJSONFile<IMetadata>(backupStream, METADATA_FILE_PATH);\r\n  }\r\n\r\n  async #loadAssetMetadata(path: string) {\r\n    const backupStream = this.#getBackupStream();\r\n    return this.#parseJSONFile<IFile>(backupStream, path);\r\n  }\r\n\r\n  async getMetadata() {\r\n    this.#reportInfo('getting metadata');\r\n    if (!this.#metadata) {\r\n      await this.#loadMetadata();\r\n    }\r\n\r\n    return this.#metadata ?? null;\r\n  }\r\n\r\n  async getSchemas() {\r\n    this.#reportInfo('getting schemas');\r\n    const schemaCollection = await utils.stream.collect<Struct.Schema>(\r\n      this.createSchemasReadStream()\r\n    );\r\n\r\n    if (isEmpty(schemaCollection)) {\r\n      throw new ProviderInitializationError('Could not load schemas from Strapi data file.');\r\n    }\r\n\r\n    // Group schema by UID\r\n    const schemas = keyBy('uid', schemaCollection);\r\n\r\n    // Transform to valid JSON\r\n    return utils.schema.schemasToValidJSON(schemas);\r\n  }\r\n\r\n  createEntitiesReadStream(): Readable {\r\n    this.#reportInfo('creating entities read stream');\r\n    return this.#streamJsonlDirectory('entities');\r\n  }\r\n\r\n  createSchemasReadStream(): Readable {\r\n    this.#reportInfo('creating schemas read stream');\r\n    return this.#streamJsonlDirectory('schemas');\r\n  }\r\n\r\n  createLinksReadStream(): Readable {\r\n    this.#reportInfo('creating links read stream');\r\n    return this.#streamJsonlDirectory('links');\r\n  }\r\n\r\n  createConfigurationReadStream(): Readable {\r\n    this.#reportInfo('creating configuration read stream');\r\n    // NOTE: TBD\r\n    return this.#streamJsonlDirectory('configuration');\r\n  }\r\n\r\n  createAssetsReadStream(): Readable | Promise<Readable> {\r\n    const inStream = this.#getBackupStream();\r\n    const outStream = new PassThrough({ objectMode: true });\r\n    const loadAssetMetadata = this.#loadAssetMetadata.bind(this);\r\n    this.#reportInfo('creating assets read stream');\r\n\r\n    pipeline(\r\n      [\r\n        inStream,\r\n        new tar.Parse({\r\n          // find only files in the assets/uploads folder\r\n          filter(filePath, entry) {\r\n            if (entry.type !== 'File') {\r\n              return false;\r\n            }\r\n            return isFilePathInDirname('assets/uploads', filePath);\r\n          },\r\n          async onentry(entry) {\r\n            const { path: filePath, size = 0 } = entry;\r\n            const normalizedPath = unknownPathToPosix(filePath);\r\n            const file = path.basename(normalizedPath);\r\n            let metadata;\r\n            try {\r\n              metadata = await loadAssetMetadata(`assets/metadata/${file}.json`);\r\n            } catch (error) {\r\n              throw new Error(`Failed to read metadata for ${file}`);\r\n            }\r\n            const asset: IAsset = {\r\n              metadata,\r\n              filename: file,\r\n              filepath: normalizedPath,\r\n              stats: { size },\r\n              stream: entry as unknown as Readable,\r\n            };\r\n            outStream.write(asset);\r\n          },\r\n        }),\r\n      ],\r\n      () => outStream.end()\r\n    );\r\n\r\n    return outStream;\r\n  }\r\n\r\n  #getBackupStream() {\r\n    const { file, encryption, compression } = this.options;\r\n\r\n    const streams: StreamItemArray = [];\r\n\r\n    try {\r\n      streams.push(fs.createReadStream(file.path));\r\n    } catch (e) {\r\n      throw new Error(`Could not read backup file path provided at \"${this.options.file.path}\"`);\r\n    }\r\n\r\n    if (encryption.enabled && encryption.key) {\r\n      streams.push(utils.encryption.createDecryptionCipher(encryption.key));\r\n    }\r\n\r\n    if (compression.enabled) {\r\n      streams.push(zip.createGunzip());\r\n    }\r\n\r\n    return chain(streams);\r\n  }\r\n\r\n  // `directory` must be posix formatted path\r\n  #streamJsonlDirectory(directory: string) {\r\n    const inStream = this.#getBackupStream();\r\n\r\n    const outStream = new PassThrough({ objectMode: true });\r\n\r\n    pipeline(\r\n      [\r\n        inStream,\r\n        new tar.Parse({\r\n          filter(filePath, entry) {\r\n            if (entry.type !== 'File') {\r\n              return false;\r\n            }\r\n\r\n            return isFilePathInDirname(directory, filePath);\r\n          },\r\n\r\n          async onentry(entry) {\r\n            const transforms = [\r\n              // JSONL parser to read the data chunks one by one (line by line)\r\n              parser({\r\n                checkErrors: true,\r\n              }),\r\n              // The JSONL parser returns each line as key/value\r\n              (line: { key: string; value: object }) => line.value,\r\n            ];\r\n\r\n            const stream = entry.pipe(chain(transforms));\r\n\r\n            try {\r\n              for await (const chunk of stream) {\r\n                outStream.write(chunk);\r\n              }\r\n            } catch (e: unknown) {\r\n              outStream.destroy(\r\n                new ProviderTransferError(\r\n                  `Error parsing backup files from backup file ${entry.path}: ${\r\n                    (e as Error).message\r\n                  }`,\r\n                  {\r\n                    details: {\r\n                      error: e,\r\n                    },\r\n                  }\r\n                )\r\n              );\r\n            }\r\n          },\r\n        }),\r\n      ],\r\n      async () => {\r\n        // Manually send the 'end' event to the out stream\r\n        // once every entry has finished streaming its content\r\n        outStream.end();\r\n      }\r\n    );\r\n\r\n    return outStream;\r\n  }\r\n\r\n  // For collecting an entire JSON file then parsing it, not for streaming JSONL\r\n  async #parseJSONFile<T extends object>(fileStream: Readable, filePath: string): Promise<T> {\r\n    return new Promise<T>((resolve, reject) => {\r\n      pipeline(\r\n        [\r\n          fileStream,\r\n          // Custom backup archive parsing\r\n          new tar.Parse({\r\n            /**\r\n             * Filter the parsed entries to only keep the one that matches the given filepath\r\n             */\r\n            filter(entryPath, entry) {\r\n              if (entry.type !== 'File') {\r\n                return false;\r\n              }\r\n\r\n              return isPathEquivalent(entryPath, filePath);\r\n            },\r\n\r\n            async onentry(entry) {\r\n              // Collect all the content of the entry file\r\n              const content = await entry.collect();\r\n\r\n              try {\r\n                // Parse from buffer array to string to JSON\r\n                const parsedContent = JSON.parse(Buffer.concat(content).toString());\r\n\r\n                // Resolve the Promise with the parsed content\r\n                resolve(parsedContent);\r\n              } catch (e) {\r\n                reject(e);\r\n              } finally {\r\n                // Cleanup (close the stream associated to the entry)\r\n                entry.destroy();\r\n              }\r\n            },\r\n          }),\r\n        ],\r\n        () => {\r\n          // If the promise hasn't been resolved and we've parsed all\r\n          // the archive entries, then the file doesn't exist\r\n          reject(new Error(`File \"${filePath}\" not found`));\r\n        }\r\n      );\r\n    });\r\n  }\r\n}\r\n","import { Writable } from 'stream';\r\nimport { posix } from 'path';\r\nimport tar from 'tar-stream';\r\n\r\n/**\r\n * Create a file path factory for a given path & prefix.\r\n * Upon being called, the factory will return a file path for a given index\r\n */\r\nexport const createFilePathFactory =\r\n  (type: string) =>\r\n  (fileIndex = 0): string => {\r\n    // always write tar files with posix paths so we have a standard format for paths regardless of system\r\n    return posix.join(\r\n      // \"{type}\" directory\r\n      type,\r\n      // \"${type}_XXXXX.jsonl\" file\r\n      `${type}_${String(fileIndex).padStart(5, '0')}.jsonl`\r\n    );\r\n  };\r\n\r\nexport const createTarEntryStream = (\r\n  archive: tar.Pack,\r\n  pathFactory: (index?: number) => string,\r\n  maxSize = 2.56e8\r\n) => {\r\n  let fileIndex = 0;\r\n  let buffer = '';\r\n\r\n  const flush = async () => {\r\n    if (!buffer) {\r\n      return;\r\n    }\r\n\r\n    fileIndex += 1;\r\n    const name = pathFactory(fileIndex);\r\n    const size = buffer.length;\r\n\r\n    await new Promise<void>((resolve, reject) => {\r\n      archive.entry({ name, size }, buffer, (err) => {\r\n        if (err) {\r\n          reject(err);\r\n        }\r\n\r\n        resolve();\r\n      });\r\n    });\r\n\r\n    buffer = '';\r\n  };\r\n\r\n  const push = (chunk: string | Buffer) => {\r\n    buffer += chunk;\r\n  };\r\n\r\n  return new Writable({\r\n    async destroy(err, callback) {\r\n      await flush();\r\n      callback(err);\r\n    },\r\n\r\n    async write(chunk, _encoding, callback) {\r\n      const size = chunk.length;\r\n\r\n      if (chunk.length > maxSize) {\r\n        callback(new Error(`payload too large: ${chunk.length}>${maxSize}`));\r\n        return;\r\n      }\r\n\r\n      if (buffer.length + size > maxSize) {\r\n        await flush();\r\n      }\r\n\r\n      push(chunk);\r\n\r\n      callback(null);\r\n    },\r\n  });\r\n};\r\n","import path from 'path';\r\nimport zlib from 'zlib';\r\nimport { Readable, Writable } from 'stream';\r\nimport { rm, createWriteStream } from 'fs-extra';\r\nimport tar from 'tar-stream';\r\nimport { stringer } from 'stream-json/jsonl/Stringer';\r\nimport { chain } from 'stream-chain';\r\n\r\nimport { createEncryptionCipher } from '../../../utils/encryption';\r\nimport type {\r\n  IAsset,\r\n  IDestinationProvider,\r\n  IDestinationProviderTransferResults,\r\n  IMetadata,\r\n  ProviderType,\r\n  Stream,\r\n} from '../../../../types';\r\nimport type { IDiagnosticReporter } from '../../../utils/diagnostic';\r\nimport { createFilePathFactory, createTarEntryStream } from './utils';\r\nimport { ProviderTransferError } from '../../../errors/providers';\r\n\r\nexport interface ILocalFileDestinationProviderOptions {\r\n  encryption: {\r\n    enabled: boolean; // if the file should be encrypted\r\n    key?: string; // the key to use when encryption.enabled is true\r\n  };\r\n\r\n  compression: {\r\n    enabled: boolean; // if the file should be compressed with gzip\r\n  };\r\n\r\n  file: {\r\n    path: string; // the filename to create\r\n    maxSize?: number; // the max size of a single backup file\r\n    maxSizeJsonl?: number; // the max lines of each jsonl file before creating the next file\r\n  };\r\n}\r\n\r\nexport interface ILocalFileDestinationProviderTransferResults\r\n  extends IDestinationProviderTransferResults {\r\n  file?: {\r\n    path?: string;\r\n  };\r\n}\r\n\r\nexport const createLocalFileDestinationProvider = (\r\n  options: ILocalFileDestinationProviderOptions\r\n) => {\r\n  return new LocalFileDestinationProvider(options);\r\n};\r\n\r\nclass LocalFileDestinationProvider implements IDestinationProvider {\r\n  name = 'destination::local-file';\r\n\r\n  type: ProviderType = 'destination';\r\n\r\n  options: ILocalFileDestinationProviderOptions;\r\n\r\n  results: ILocalFileDestinationProviderTransferResults = {};\r\n\r\n  #providersMetadata: { source?: IMetadata; destination?: IMetadata } = {};\r\n\r\n  #archive: { stream?: tar.Pack; pipeline?: Stream } = {};\r\n\r\n  #diagnostics?: IDiagnosticReporter;\r\n\r\n  constructor(options: ILocalFileDestinationProviderOptions) {\r\n    this.options = options;\r\n  }\r\n\r\n  #reportInfo(message: string) {\r\n    this.#diagnostics?.report({\r\n      details: {\r\n        createdAt: new Date(),\r\n        message,\r\n        origin: 'file-destination-provider',\r\n      },\r\n      kind: 'info',\r\n    });\r\n  }\r\n\r\n  get #archivePath() {\r\n    const { encryption, compression, file } = this.options;\r\n\r\n    let filePath = `${file.path}.tar`;\r\n\r\n    if (compression.enabled) {\r\n      filePath += '.gz';\r\n    }\r\n\r\n    if (encryption.enabled) {\r\n      filePath += '.enc';\r\n    }\r\n\r\n    return filePath;\r\n  }\r\n\r\n  setMetadata(target: ProviderType, metadata: IMetadata): IDestinationProvider {\r\n    this.#providersMetadata[target] = metadata;\r\n\r\n    return this;\r\n  }\r\n\r\n  createGzip(): zlib.Gzip {\r\n    this.#reportInfo('creating gzip');\r\n    return zlib.createGzip();\r\n  }\r\n\r\n  bootstrap(diagnostics: IDiagnosticReporter): void | Promise<void> {\r\n    this.#diagnostics = diagnostics;\r\n    const { compression, encryption } = this.options;\r\n\r\n    if (encryption.enabled && !encryption.key) {\r\n      throw new Error(\"Can't encrypt without a key\");\r\n    }\r\n\r\n    this.#archive.stream = tar.pack();\r\n\r\n    const outStream = createWriteStream(this.#archivePath);\r\n\r\n    outStream.on('error', (err: NodeJS.ErrnoException) => {\r\n      if (err.code === 'ENOSPC') {\r\n        throw new ProviderTransferError(\r\n          \"Your server doesn't have space to proceed with the import.\"\r\n        );\r\n      }\r\n      throw err;\r\n    });\r\n\r\n    const archiveTransforms: Stream[] = [];\r\n\r\n    if (compression.enabled) {\r\n      archiveTransforms.push(this.createGzip());\r\n    }\r\n\r\n    if (encryption.enabled && encryption.key) {\r\n      archiveTransforms.push(createEncryptionCipher(encryption.key));\r\n    }\r\n\r\n    this.#archive.pipeline = chain([this.#archive.stream, ...archiveTransforms, outStream]);\r\n\r\n    this.results.file = { path: this.#archivePath };\r\n  }\r\n\r\n  async close() {\r\n    const { stream, pipeline } = this.#archive;\r\n\r\n    if (!stream) {\r\n      return;\r\n    }\r\n\r\n    await this.#writeMetadata();\r\n    stream.finalize();\r\n\r\n    if (pipeline && !pipeline.closed) {\r\n      await new Promise<void>((resolve, reject) => {\r\n        pipeline.on('close', resolve).on('error', reject);\r\n      });\r\n    }\r\n  }\r\n\r\n  async rollback(): Promise<void> {\r\n    this.#reportInfo('rolling back');\r\n    await this.close();\r\n    await rm(this.#archivePath, { force: true });\r\n  }\r\n\r\n  getMetadata() {\r\n    return null;\r\n  }\r\n\r\n  async #writeMetadata(): Promise<void> {\r\n    this.#reportInfo('writing metadata');\r\n    const metadata = this.#providersMetadata.source;\r\n\r\n    if (metadata) {\r\n      await new Promise((resolve) => {\r\n        const outStream = this.#getMetadataStream();\r\n        const data = JSON.stringify(metadata, null, 2);\r\n\r\n        Readable.from(data).pipe(outStream).on('close', resolve);\r\n      });\r\n    }\r\n  }\r\n\r\n  #getMetadataStream() {\r\n    const { stream } = this.#archive;\r\n\r\n    if (!stream) {\r\n      throw new Error('Archive stream is unavailable');\r\n    }\r\n\r\n    return createTarEntryStream(stream, () => 'metadata.json');\r\n  }\r\n\r\n  createSchemasWriteStream() {\r\n    if (!this.#archive.stream) {\r\n      throw new Error('Archive stream is unavailable');\r\n    }\r\n    this.#reportInfo('creating schemas write stream');\r\n    const filePathFactory = createFilePathFactory('schemas');\r\n\r\n    const entryStream = createTarEntryStream(\r\n      this.#archive.stream,\r\n      filePathFactory,\r\n      this.options.file.maxSizeJsonl\r\n    );\r\n\r\n    return chain([stringer(), entryStream]);\r\n  }\r\n\r\n  createEntitiesWriteStream(): Writable {\r\n    if (!this.#archive.stream) {\r\n      throw new Error('Archive stream is unavailable');\r\n    }\r\n    this.#reportInfo('creating entities write stream');\r\n    const filePathFactory = createFilePathFactory('entities');\r\n\r\n    const entryStream = createTarEntryStream(\r\n      this.#archive.stream,\r\n      filePathFactory,\r\n      this.options.file.maxSizeJsonl\r\n    );\r\n\r\n    return chain([stringer(), entryStream]);\r\n  }\r\n\r\n  createLinksWriteStream(): Writable {\r\n    if (!this.#archive.stream) {\r\n      throw new Error('Archive stream is unavailable');\r\n    }\r\n    this.#reportInfo('creating links write stream');\r\n    const filePathFactory = createFilePathFactory('links');\r\n\r\n    const entryStream = createTarEntryStream(\r\n      this.#archive.stream,\r\n      filePathFactory,\r\n      this.options.file.maxSizeJsonl\r\n    );\r\n\r\n    return chain([stringer(), entryStream]);\r\n  }\r\n\r\n  createConfigurationWriteStream(): Writable {\r\n    if (!this.#archive.stream) {\r\n      throw new Error('Archive stream is unavailable');\r\n    }\r\n    this.#reportInfo('creating configuration write stream');\r\n    const filePathFactory = createFilePathFactory('configuration');\r\n\r\n    const entryStream = createTarEntryStream(\r\n      this.#archive.stream,\r\n      filePathFactory,\r\n      this.options.file.maxSizeJsonl\r\n    );\r\n\r\n    return chain([stringer(), entryStream]);\r\n  }\r\n\r\n  createAssetsWriteStream(): Writable {\r\n    const { stream: archiveStream } = this.#archive;\r\n\r\n    if (!archiveStream) {\r\n      throw new Error('Archive stream is unavailable');\r\n    }\r\n\r\n    this.#reportInfo('creating assets write stream');\r\n    return new Writable({\r\n      objectMode: true,\r\n      write(data: IAsset, _encoding, callback) {\r\n        // always write tar files with posix paths so we have a standard format for paths regardless of system\r\n        const entryPath = path.posix.join('assets', 'uploads', data.filename);\r\n\r\n        const entryMetadataPath = path.posix.join('assets', 'metadata', `${data.filename}.json`);\r\n        const stringifiedMetadata = JSON.stringify(data.metadata);\r\n        archiveStream.entry(\r\n          {\r\n            name: entryMetadataPath,\r\n            size: stringifiedMetadata.length,\r\n          },\r\n          stringifiedMetadata\r\n        );\r\n\r\n        const entry = archiveStream.entry({\r\n          name: entryPath,\r\n          size: data.stats.size,\r\n        });\r\n\r\n        if (!entry) {\r\n          callback(new Error(`Failed to created an asset tar entry for ${entryPath}`));\r\n          return;\r\n        }\r\n\r\n        data.stream.pipe(entry);\r\n\r\n        entry\r\n          .on('finish', () => {\r\n            callback(null);\r\n          })\r\n          .on('error', (error) => {\r\n            callback(error);\r\n          });\r\n      },\r\n    });\r\n  }\r\n}\r\n"],"names":["strategies","scryptSync","createCipheriv","createDecipheriv","Transform","stream","reject","path","isArray","zip","isObject","uniq","isEqual","mapValues","pick","strapi","EventEmitter","randomUUID","diagnostic","diff","utils.json.diff","origin","capitalize","utils.middleware.runMiddleware","PassThrough","utils.stream.filter","utils.stream.map","chain","isNumber","semverDiff","isEmpty","EOL","last","entity","schema","set","link","extname","contentTypesUtils","omit","has","async","_","pipe","assign","get","omitInvalidCreationAttributes","componentsService.createComponents","componentsService.getComponents","componentsService.deleteComponents","map","size","isNil","clone","transaction","queries.entity.createEntityQuery","Writable","json.diff","chalk","filter","utils.transaction.createTransaction","restore.deleteRecords","utils.schema.schemasToValidJSON","utils.schema.mapSchemasValues","restore.createEntitiesWriteStream","fse","Readable","entry","restore.createConfigurationWriteStream","restore.createLinksWriteStream","shared.entity.createEntityQuery","createReadStream","webStream","stat","file","join","Duplex","ws","message","WebSocket","once","castArray","err","cb","VALID_TRANSFER_ACTIONS","TRANSFER_KIND","utils.stream.collect","keyBy","pipeline","tar","fs","utils.encryption.createDecryptionCipher","parser","posix","zlib","createWriteStream","rm","stringer"],"mappings":"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"}