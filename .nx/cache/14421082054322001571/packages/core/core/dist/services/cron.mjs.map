{"version":3,"file":"cron.mjs","sources":["../../src/services/cron.ts"],"sourcesContent":["import { Job, Spec } from 'node-schedule';\r\nimport { isFunction } from 'lodash/fp';\r\nimport type { Core } from '@strapi/types';\r\n\r\ninterface JobSpec {\r\n  job: Job;\r\n  options: Spec;\r\n  name: string | null;\r\n}\r\n\r\ntype TaskFn = ({ strapi }: { strapi: Core.Strapi }, ...args: unknown[]) => Promise<unknown>;\r\n\r\ntype Task =\r\n  | TaskFn\r\n  | {\r\n      task: TaskFn;\r\n      options: Spec;\r\n    };\r\n\r\ninterface Tasks {\r\n  [key: string]: Task;\r\n}\r\n\r\nconst createCronService = () => {\r\n  let jobsSpecs: JobSpec[] = [];\r\n  let running = false;\r\n\r\n  return {\r\n    add(tasks: Tasks = {}) {\r\n      for (const taskExpression of Object.keys(tasks)) {\r\n        const taskValue = tasks[taskExpression];\r\n\r\n        let fn: TaskFn;\r\n        let options: Spec;\r\n        let taskName: string | null;\r\n        if (isFunction(taskValue)) {\r\n          // don't use task name if key is the rule\r\n          taskName = null;\r\n          fn = taskValue.bind(tasks);\r\n          options = taskExpression;\r\n        } else if (isFunction(taskValue.task)) {\r\n          // set task name if key is not the rule\r\n          taskName = taskExpression;\r\n          fn = taskValue.task.bind(taskValue);\r\n          options = taskValue.options;\r\n        } else {\r\n          throw new Error(\r\n            `Could not schedule a cron job for \"${taskExpression}\": no function found.`\r\n          );\r\n        }\r\n\r\n        const fnWithStrapi = (...args: unknown[]) => fn({ strapi }, ...args);\r\n\r\n        // const job = new Job(null, fnWithStrapi);\r\n        const job = new Job(fnWithStrapi);\r\n        jobsSpecs.push({ job, options, name: taskName });\r\n\r\n        if (running) {\r\n          job.schedule(options);\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n\r\n    remove(name: string) {\r\n      if (!name) throw new Error('You must provide a name to remove a cron job.');\r\n      const matchingJobsSpecs = jobsSpecs.filter(({ name: jobSpecName }, index) => {\r\n        if (jobSpecName === name) {\r\n          jobsSpecs.splice(index, 1);\r\n          return true;\r\n        }\r\n        return false;\r\n      });\r\n      matchingJobsSpecs.forEach(({ job }) => job.cancel());\r\n      return this;\r\n    },\r\n\r\n    start() {\r\n      jobsSpecs.forEach(({ job, options }) => job.schedule(options));\r\n      running = true;\r\n      return this;\r\n    },\r\n\r\n    stop() {\r\n      jobsSpecs.forEach(({ job }) => job.cancel());\r\n      running = false;\r\n      return this;\r\n    },\r\n\r\n    destroy() {\r\n      this.stop();\r\n      jobsSpecs = [];\r\n      return this;\r\n    },\r\n    jobs: jobsSpecs,\r\n  };\r\n};\r\n\r\nexport default createCronService;\r\n"],"names":[],"mappings":";;AAuBA,MAAM,oBAAoB,MAAM;AAC9B,MAAI,YAAuB,CAAC;AAC5B,MAAI,UAAU;AAEP,SAAA;AAAA,IACL,IAAI,QAAe,IAAI;AACrB,iBAAW,kBAAkB,OAAO,KAAK,KAAK,GAAG;AACzC,cAAA,YAAY,MAAM,cAAc;AAElC,YAAA;AACA,YAAA;AACA,YAAA;AACA,YAAA,WAAW,SAAS,GAAG;AAEd,qBAAA;AACN,eAAA,UAAU,KAAK,KAAK;AACf,oBAAA;AAAA,QACD,WAAA,WAAW,UAAU,IAAI,GAAG;AAE1B,qBAAA;AACN,eAAA,UAAU,KAAK,KAAK,SAAS;AAClC,oBAAU,UAAU;AAAA,QAAA,OACf;AACL,gBAAM,IAAI;AAAA,YACR,sCAAsC,cAAc;AAAA,UACtD;AAAA,QAAA;AAGI,cAAA,eAAe,IAAI,SAAoB,GAAG,EAAE,OAAO,GAAG,GAAG,IAAI;AAG7D,cAAA,MAAM,IAAI,IAAI,YAAY;AAChC,kBAAU,KAAK,EAAE,KAAK,SAAS,MAAM,UAAU;AAE/C,YAAI,SAAS;AACX,cAAI,SAAS,OAAO;AAAA,QAAA;AAAA,MACtB;AAEK,aAAA;AAAA,IACT;AAAA,IAEA,OAAO,MAAc;AACnB,UAAI,CAAC,KAAY,OAAA,IAAI,MAAM,+CAA+C;AACpE,YAAA,oBAAoB,UAAU,OAAO,CAAC,EAAE,MAAM,eAAe,UAAU;AAC3E,YAAI,gBAAgB,MAAM;AACd,oBAAA,OAAO,OAAO,CAAC;AAClB,iBAAA;AAAA,QAAA;AAEF,eAAA;AAAA,MAAA,CACR;AACD,wBAAkB,QAAQ,CAAC,EAAE,UAAU,IAAI,QAAQ;AAC5C,aAAA;AAAA,IACT;AAAA,IAEA,QAAQ;AACI,gBAAA,QAAQ,CAAC,EAAE,KAAK,cAAc,IAAI,SAAS,OAAO,CAAC;AACnD,gBAAA;AACH,aAAA;AAAA,IACT;AAAA,IAEA,OAAO;AACL,gBAAU,QAAQ,CAAC,EAAE,UAAU,IAAI,QAAQ;AACjC,gBAAA;AACH,aAAA;AAAA,IACT;AAAA,IAEA,UAAU;AACR,WAAK,KAAK;AACV,kBAAY,CAAC;AACN,aAAA;AAAA,IACT;AAAA,IACA,MAAM;AAAA,EACR;AACF;"}