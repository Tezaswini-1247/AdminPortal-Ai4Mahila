{"version":3,"file":"index.js","sources":["../../../src/services/entity-validator/index.ts"],"sourcesContent":["/**\r\n * Entity validator\r\n * Module that will validate input data for entity creation or edition\r\n */\r\n\r\nimport { uniqBy, castArray, isNil, isArray, mergeWith } from 'lodash';\r\nimport { has, prop, isObject, isEmpty } from 'lodash/fp';\r\nimport strapiUtils from '@strapi/utils';\r\nimport { Modules, UID, Struct, Schema } from '@strapi/types';\r\nimport { Validators, ValidatorMetas } from './validators';\r\n\r\ntype CreateOrUpdate = 'creation' | 'update';\r\n\r\nconst { yup, validateYupSchema } = strapiUtils;\r\nconst { isMediaAttribute, isScalarAttribute, getWritableAttributes } = strapiUtils.contentTypes;\r\nconst { ValidationError } = strapiUtils.errors;\r\n\r\ntype ID = { id: string | number };\r\n\r\ntype RelationSource = string | number | ID;\r\n\r\nexport type ComponentContext = {\r\n  parentContent: {\r\n    // The model of the parent content type that contains the current component.\r\n    model: Struct.Schema;\r\n    // The numeric id of the parent entity that contains the component.\r\n    id?: number;\r\n    // The options passed to the entity validator. From which we can extract\r\n    // entity dimensions such as locale and publication state.\r\n    options?: ValidatorContext;\r\n  };\r\n  // The path to the component within the parent content type schema.\r\n  pathToComponent: string[];\r\n  // If working with a repeatable component this contains the\r\n  // full data of the repeatable component in the current entity.\r\n  repeatableData: Modules.EntityValidator.Entity[];\r\n  fullDynamicZoneContent?: Schema.Attribute.Value<Schema.Attribute.DynamicZone>;\r\n};\r\n\r\ninterface WithComponentContext {\r\n  componentContext?: ComponentContext;\r\n}\r\n\r\ninterface ValidatorMeta<TAttribute = Schema.Attribute.AnyAttribute> extends WithComponentContext {\r\n  attr: TAttribute;\r\n  updatedAttribute: { name: string; value: any };\r\n}\r\n\r\ninterface ValidatorContext {\r\n  isDraft?: boolean;\r\n  locale?: string | null;\r\n}\r\n\r\ninterface ModelValidatorMetas extends WithComponentContext {\r\n  model: Struct.Schema;\r\n  data: Record<string, unknown>;\r\n  entity?: Modules.EntityValidator.Entity;\r\n}\r\n\r\nconst isInteger = (value: unknown): value is number => Number.isInteger(value);\r\n\r\nconst addMinMax = <\r\n  T extends {\r\n    min(value: number): T;\r\n    max(value: number): T;\r\n  },\r\n>(\r\n  validator: T,\r\n  {\r\n    attr,\r\n    updatedAttribute,\r\n  }: ValidatorMeta<Schema.Attribute.AnyAttribute & Schema.Attribute.MinMaxOption<string | number>>\r\n): T => {\r\n  let nextValidator: T = validator;\r\n\r\n  if (\r\n    isInteger(attr.min) &&\r\n    (('required' in attr && attr.required) ||\r\n      (Array.isArray(updatedAttribute.value) && updatedAttribute.value.length > 0))\r\n  ) {\r\n    nextValidator = nextValidator.min(attr.min);\r\n  }\r\n  if (isInteger(attr.max)) {\r\n    nextValidator = nextValidator.max(attr.max);\r\n  }\r\n  return nextValidator;\r\n};\r\n\r\nconst addRequiredValidation = (createOrUpdate: CreateOrUpdate) => {\r\n  return <T extends strapiUtils.yup.AnySchema>(\r\n    validator: T,\r\n    {\r\n      attr: { required },\r\n    }: ValidatorMeta<Partial<Schema.Attribute.AnyAttribute & Schema.Attribute.RequiredOption>>\r\n  ): T => {\r\n    let nextValidator = validator;\r\n\r\n    if (required) {\r\n      if (createOrUpdate === 'creation') {\r\n        nextValidator = nextValidator.notNil();\r\n      } else if (createOrUpdate === 'update') {\r\n        nextValidator = nextValidator.notNull();\r\n      }\r\n    } else {\r\n      nextValidator = nextValidator.nullable();\r\n    }\r\n    return nextValidator;\r\n  };\r\n};\r\n\r\nconst addDefault = (createOrUpdate: CreateOrUpdate) => {\r\n  return (\r\n    validator: strapiUtils.yup.BaseSchema,\r\n    { attr }: ValidatorMeta<Schema.Attribute.AnyAttribute & Schema.Attribute.DefaultOption<unknown>>\r\n  ) => {\r\n    let nextValidator = validator;\r\n\r\n    if (createOrUpdate === 'creation') {\r\n      if (\r\n        ((attr.type === 'component' && attr.repeatable) || attr.type === 'dynamiczone') &&\r\n        !attr.required\r\n      ) {\r\n        nextValidator = nextValidator.default([]);\r\n      } else {\r\n        nextValidator = nextValidator.default(attr.default);\r\n      }\r\n    } else {\r\n      nextValidator = nextValidator.default(undefined);\r\n    }\r\n\r\n    return nextValidator;\r\n  };\r\n};\r\n\r\nconst preventCast = (validator: strapiUtils.yup.AnySchema) =>\r\n  validator.transform((val, originalVal) => originalVal);\r\n\r\nconst createComponentValidator =\r\n  (createOrUpdate: CreateOrUpdate) =>\r\n  (\r\n    {\r\n      attr,\r\n      updatedAttribute,\r\n      componentContext,\r\n    }: ValidatorMeta<Schema.Attribute.Component<UID.Component, boolean>>,\r\n    { isDraft }: ValidatorContext\r\n  ) => {\r\n    const model = strapi.getModel(attr.component);\r\n    if (!model) {\r\n      throw new Error('Validation failed: Model not found');\r\n    }\r\n\r\n    if (attr?.repeatable) {\r\n      // FIXME: yup v1\r\n\r\n      let validator = yup\r\n        .array()\r\n        .of(\r\n          yup.lazy((item) =>\r\n            createModelValidator(createOrUpdate)(\r\n              { componentContext, model, data: item },\r\n              { isDraft }\r\n            ).notNull()\r\n          ) as any\r\n        );\r\n\r\n      validator = addRequiredValidation(createOrUpdate)(validator, {\r\n        attr: { required: true },\r\n        updatedAttribute,\r\n      });\r\n\r\n      if (!isDraft) {\r\n        validator = addMinMax(validator, { attr, updatedAttribute });\r\n      }\r\n\r\n      return validator;\r\n    }\r\n\r\n    let validator = createModelValidator(createOrUpdate)(\r\n      {\r\n        model,\r\n        data: updatedAttribute.value,\r\n        componentContext,\r\n      },\r\n      { isDraft }\r\n    );\r\n\r\n    validator = addRequiredValidation(createOrUpdate)(validator, {\r\n      attr: { required: !isDraft && attr.required },\r\n      updatedAttribute,\r\n    });\r\n\r\n    return validator;\r\n  };\r\n\r\nconst createDzValidator =\r\n  (createOrUpdate: CreateOrUpdate) =>\r\n  ({ attr, updatedAttribute, componentContext }: ValidatorMeta, { isDraft }: ValidatorContext) => {\r\n    let validator;\r\n\r\n    validator = yup.array().of(\r\n      yup.lazy((item) => {\r\n        const model = strapi.getModel(prop('__component', item));\r\n        const schema = yup\r\n          .object()\r\n          .shape({\r\n            __component: yup.string().required().oneOf(Object.keys(strapi.components)),\r\n          })\r\n          .notNull();\r\n\r\n        return model\r\n          ? schema.concat(\r\n              createModelValidator(createOrUpdate)(\r\n                { model, data: item, componentContext },\r\n                { isDraft }\r\n              )\r\n            )\r\n          : schema;\r\n      }) as any // FIXME: yup v1\r\n    );\r\n\r\n    validator = addRequiredValidation(createOrUpdate)(validator, {\r\n      attr: { required: true },\r\n      updatedAttribute,\r\n    });\r\n\r\n    if (!isDraft) {\r\n      validator = addMinMax(validator, { attr, updatedAttribute });\r\n    }\r\n\r\n    return validator;\r\n  };\r\n\r\nconst createRelationValidator = ({\r\n  updatedAttribute,\r\n}: ValidatorMeta<Schema.Attribute.Relation>) => {\r\n  let validator;\r\n\r\n  if (Array.isArray(updatedAttribute.value)) {\r\n    validator = yup.array().of(yup.mixed());\r\n  } else {\r\n    validator = yup.mixed();\r\n  }\r\n\r\n  return validator;\r\n};\r\n\r\nconst createScalarAttributeValidator =\r\n  (createOrUpdate: CreateOrUpdate) => (metas: ValidatorMeta, options: ValidatorContext) => {\r\n    let validator;\r\n\r\n    if (has(metas.attr.type, Validators)) {\r\n      validator = (Validators as any)[metas.attr.type](metas, options);\r\n    } else {\r\n      // No validators specified - fall back to mixed\r\n      validator = yup.mixed();\r\n    }\r\n\r\n    validator = addRequiredValidation(createOrUpdate)(validator, {\r\n      attr: { required: !options.isDraft && metas.attr.required },\r\n      updatedAttribute: metas.updatedAttribute,\r\n    });\r\n\r\n    return validator;\r\n  };\r\n\r\nconst createAttributeValidator =\r\n  (createOrUpdate: CreateOrUpdate) => (metas: ValidatorMetas, options: ValidatorContext) => {\r\n    let validator = yup.mixed();\r\n\r\n    if (isMediaAttribute(metas.attr)) {\r\n      validator = yup.mixed();\r\n    } else if (isScalarAttribute(metas.attr)) {\r\n      validator = createScalarAttributeValidator(createOrUpdate)(metas, options);\r\n    } else {\r\n      if (metas.attr.type === 'component' && metas.componentContext) {\r\n        // Build the path to the component within the parent content type schema.\r\n        const pathToComponent = [\r\n          ...(metas?.componentContext?.pathToComponent ?? []),\r\n          metas.updatedAttribute.name,\r\n        ];\r\n\r\n        // If working with a repeatable component, determine the repeatable data\r\n        // based on the component's path.\r\n\r\n        // In order to validate the repeatable within this entity we need\r\n        // access to the full repeatable data. In case we are validating a\r\n        // nested component within a repeatable.\r\n        // Hence why we set this up when the path to the component is only one level deep.\r\n        const repeatableData = (\r\n          metas.attr.repeatable && pathToComponent.length === 1\r\n            ? metas.updatedAttribute.value\r\n            : metas.componentContext?.repeatableData\r\n        ) as Modules.EntityValidator.Entity[];\r\n\r\n        const newComponentContext: ComponentContext = {\r\n          ...metas.componentContext,\r\n          pathToComponent,\r\n          repeatableData,\r\n        };\r\n\r\n        validator = createComponentValidator(createOrUpdate)(\r\n          {\r\n            componentContext: newComponentContext,\r\n            attr: metas.attr,\r\n            updatedAttribute: metas.updatedAttribute,\r\n          },\r\n          options\r\n        );\r\n      } else if (metas.attr.type === 'dynamiczone' && metas.componentContext) {\r\n        const newComponentContext: ComponentContext = {\r\n          ...metas.componentContext,\r\n          fullDynamicZoneContent: metas.updatedAttribute.value,\r\n          pathToComponent: [...metas.componentContext.pathToComponent, metas.updatedAttribute.name],\r\n        };\r\n\r\n        Object.assign(metas, { componentContext: newComponentContext });\r\n\r\n        validator = createDzValidator(createOrUpdate)(metas, options);\r\n      } else if (metas.attr.type === 'relation') {\r\n        validator = createRelationValidator({\r\n          attr: metas.attr,\r\n          updatedAttribute: metas.updatedAttribute,\r\n        });\r\n      }\r\n\r\n      validator = preventCast(validator);\r\n    }\r\n\r\n    validator = addDefault(createOrUpdate)(validator, metas);\r\n\r\n    return validator;\r\n  };\r\n\r\nconst createModelValidator =\r\n  (createOrUpdate: CreateOrUpdate) =>\r\n  ({ componentContext, model, data, entity }: ModelValidatorMetas, options: ValidatorContext) => {\r\n    const writableAttributes = model ? getWritableAttributes(model as any) : [];\r\n\r\n    const schema = writableAttributes.reduce(\r\n      (validators, attributeName) => {\r\n        const metas = {\r\n          attr: model.attributes[attributeName],\r\n          updatedAttribute: { name: attributeName, value: prop(attributeName, data) },\r\n          model,\r\n          entity,\r\n          componentContext,\r\n        };\r\n\r\n        const validator = createAttributeValidator(createOrUpdate)(metas, options);\r\n\r\n        validators[attributeName] = validator;\r\n\r\n        return validators;\r\n      },\r\n      {} as Record<string, strapiUtils.yup.BaseSchema>\r\n    );\r\n\r\n    return yup.object().shape(schema);\r\n  };\r\n\r\nconst createValidateEntity = (createOrUpdate: CreateOrUpdate) => {\r\n  return async <\r\n    TUID extends UID.ContentType,\r\n    TData extends Modules.EntityService.Params.Data.Input<TUID>,\r\n  >(\r\n    model: Schema.ContentType<TUID>,\r\n    data: TData | Partial<TData> | undefined,\r\n    options?: ValidatorContext,\r\n    entity?: Modules.EntityValidator.Entity\r\n  ): Promise<TData> => {\r\n    if (!isObject(data)) {\r\n      const { displayName } = model.info;\r\n\r\n      throw new ValidationError(\r\n        `Invalid payload submitted for the ${createOrUpdate} of an entity of type ${displayName}. Expected an object, but got ${typeof data}`\r\n      );\r\n    }\r\n\r\n    const validator = createModelValidator(createOrUpdate)(\r\n      {\r\n        model,\r\n        data,\r\n        entity,\r\n        componentContext: {\r\n          // Set up the initial component context.\r\n          // Keeping track of parent content type context in which a component will be used.\r\n          // This is necessary to validate component field constraints such as uniqueness.\r\n          parentContent: {\r\n            id: entity?.id,\r\n            model,\r\n            options,\r\n          },\r\n          pathToComponent: [],\r\n          repeatableData: [],\r\n        },\r\n      },\r\n      {\r\n        isDraft: options?.isDraft ?? false,\r\n        locale: options?.locale ?? null,\r\n      }\r\n    )\r\n      .test(\r\n        'relations-test',\r\n        'check that all relations exist',\r\n        async function relationsValidation(data) {\r\n          try {\r\n            await checkRelationsExist(buildRelationsStore({ uid: model.uid, data }));\r\n          } catch (e) {\r\n            return this.createError({\r\n              path: this.path,\r\n              message: (e instanceof ValidationError && e.message) || 'Invalid relations',\r\n            });\r\n          }\r\n          return true;\r\n        }\r\n      )\r\n      .required();\r\n\r\n    return validateYupSchema(validator, {\r\n      strict: false,\r\n      abortEarly: false,\r\n    })(data);\r\n  };\r\n};\r\n\r\n/**\r\n * Builds an object containing all the media and relations being associated with an entity\r\n */\r\nconst buildRelationsStore = <TUID extends UID.Schema>({\r\n  uid,\r\n  data,\r\n}: {\r\n  uid: TUID;\r\n  data: Record<string, unknown> | null;\r\n}): Record<string, ID[]> => {\r\n  if (!uid) {\r\n    throw new ValidationError(`Cannot build relations store: \"uid\" is undefined`);\r\n  }\r\n\r\n  if (isEmpty(data)) {\r\n    return {};\r\n  }\r\n\r\n  const currentModel = strapi.getModel(uid);\r\n\r\n  return Object.keys(currentModel.attributes).reduce(\r\n    (result, attributeName: string) => {\r\n      const attribute = currentModel.attributes[attributeName];\r\n      const value = data[attributeName];\r\n\r\n      if (isNil(value)) {\r\n        return result;\r\n      }\r\n\r\n      switch (attribute.type) {\r\n        case 'relation':\r\n        case 'media': {\r\n          if (\r\n            attribute.type === 'relation' &&\r\n            (attribute.relation === 'morphToMany' || attribute.relation === 'morphToOne')\r\n          ) {\r\n            // TODO: handle polymorphic relations\r\n            break;\r\n          }\r\n\r\n          const target =\r\n            // eslint-disable-next-line no-nested-ternary\r\n            attribute.type === 'media' ? 'plugin::upload.file' : attribute.target;\r\n          // As there are multiple formats supported for associating relations\r\n          // with an entity, the value here can be an: array, object or number.\r\n          let source: RelationSource[];\r\n          if (Array.isArray(value)) {\r\n            source = value;\r\n          } else if (isObject(value)) {\r\n            if ('connect' in value && !isNil(value.connect)) {\r\n              source = value.connect as RelationSource[];\r\n            } else if ('set' in value && !isNil(value.set)) {\r\n              source = value.set as RelationSource[];\r\n            } else {\r\n              source = [];\r\n            }\r\n          } else {\r\n            source = castArray(value as RelationSource);\r\n          }\r\n          const idArray = source.map((v) => ({\r\n            id: typeof v === 'object' ? v.id : v,\r\n          }));\r\n\r\n          // Update the relationStore to keep track of all associations being made\r\n          // with relations and media.\r\n          result[target] = result[target] || [];\r\n          result[target].push(...idArray);\r\n          break;\r\n        }\r\n        case 'component': {\r\n          return castArray(value).reduce((relationsStore, componentValue) => {\r\n            if (!attribute.component) {\r\n              throw new ValidationError(\r\n                `Cannot build relations store from component, component identifier is undefined`\r\n              );\r\n            }\r\n\r\n            return mergeWith(\r\n              relationsStore,\r\n              buildRelationsStore({\r\n                uid: attribute.component,\r\n                data: componentValue as Record<string, unknown>,\r\n              }),\r\n              (objValue, srcValue) => {\r\n                if (isArray(objValue)) {\r\n                  return objValue.concat(srcValue);\r\n                }\r\n              }\r\n            );\r\n          }, result) as Record<string, ID[]>;\r\n        }\r\n        case 'dynamiczone': {\r\n          return castArray(value).reduce((relationsStore, dzValue) => {\r\n            const value = dzValue as Record<string, unknown>;\r\n            if (!value.__component) {\r\n              throw new ValidationError(\r\n                `Cannot build relations store from dynamiczone, component identifier is undefined`\r\n              );\r\n            }\r\n\r\n            return mergeWith(\r\n              relationsStore,\r\n              buildRelationsStore({\r\n                uid: value.__component as UID.Component,\r\n                data: value,\r\n              }),\r\n              (objValue, srcValue) => {\r\n                if (isArray(objValue)) {\r\n                  return objValue.concat(srcValue);\r\n                }\r\n              }\r\n            );\r\n          }, result) as Record<string, ID[]>;\r\n        }\r\n        default:\r\n          break;\r\n      }\r\n\r\n      return result;\r\n    },\r\n    {} as Record<string, ID[]>\r\n  );\r\n};\r\n\r\n/**\r\n * Iterate through the relations store and validates that every relation or media\r\n * mentioned exists\r\n */\r\nconst checkRelationsExist = async (relationsStore: Record<string, ID[]> = {}) => {\r\n  const promises: Promise<void>[] = [];\r\n\r\n  for (const [key, value] of Object.entries(relationsStore)) {\r\n    const evaluate = async () => {\r\n      const uniqueValues = uniqBy(value, `id`);\r\n      const count = await strapi.db.query(key as UID.Schema).count({\r\n        where: {\r\n          id: {\r\n            $in: uniqueValues.map((v) => v.id),\r\n          },\r\n        },\r\n      });\r\n\r\n      if (count !== uniqueValues.length) {\r\n        throw new ValidationError(\r\n          `${\r\n            uniqueValues.length - count\r\n          } relation(s) of type ${key} associated with this entity do not exist`\r\n        );\r\n      }\r\n    };\r\n    promises.push(evaluate());\r\n  }\r\n\r\n  return Promise.all(promises);\r\n};\r\n\r\nconst entityValidator: Modules.EntityValidator.EntityValidator = {\r\n  validateEntityCreation: createValidateEntity('creation'),\r\n  validateEntityUpdate: createValidateEntity('update'),\r\n};\r\n\r\nexport default entityValidator;\r\n"],"names":["strapiUtils","validator","prop","has","Validators","validators","isObject","data","isEmpty","isNil","castArray","mergeWith","isArray","value","uniqBy"],"mappings":"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"}