{"version":3,"file":"components.js","sources":["../../../src/services/document-service/components.ts"],"sourcesContent":["import _ from 'lodash';\r\nimport { has, omit, pipe, assign, curry } from 'lodash/fp';\r\nimport type { Utils, UID, Schema, Data, Modules } from '@strapi/types';\r\nimport { contentTypes as contentTypesUtils, async, errors } from '@strapi/utils';\r\n\r\n// type aliases for readability\r\ntype Input<T extends UID.Schema> = Modules.Documents.Params.Data.Input<T>;\r\n\r\ntype LoadedComponents<TUID extends UID.Schema> = Data.Entity<\r\n  TUID,\r\n  Schema.AttributeNamesByType<TUID, 'component' | 'dynamiczone'>\r\n>;\r\n\r\ntype SingleComponentValue = Schema.Attribute.ComponentValue<UID.Component, false>;\r\ntype RepeatableComponentValue = Schema.Attribute.ComponentValue<UID.Component, true>;\r\n\r\ntype ComponentValue = SingleComponentValue | RepeatableComponentValue;\r\n\r\ntype DynamicZoneValue = Schema.Attribute.DynamicZoneValue<UID.Component[]>;\r\n\r\ntype ComponentBody = {\r\n  [key: string]: ComponentValue | DynamicZoneValue;\r\n};\r\n\r\nconst omitComponentData = curry(\r\n  (schema: Schema.Schema, data: Input<UID.Schema>): Partial<Input<UID.Schema>> => {\r\n    const { attributes } = schema;\r\n    const componentAttributes = Object.keys(attributes).filter((attributeName) =>\r\n      contentTypesUtils.isComponentAttribute(attributes[attributeName])\r\n    );\r\n\r\n    return omit(componentAttributes, data);\r\n  }\r\n);\r\n\r\n// NOTE: we could generalize the logic to allow CRUD of relation directly in the DB layer\r\nconst createComponents = async <TUID extends UID.Schema, TData extends Input<TUID>>(\r\n  uid: TUID,\r\n  data: TData\r\n) => {\r\n  const { attributes = {} } = strapi.getModel(uid);\r\n\r\n  const componentBody: ComponentBody = {};\r\n\r\n  const attributeNames = Object.keys(attributes);\r\n\r\n  for (const attributeName of attributeNames) {\r\n    const attribute = attributes[attributeName];\r\n\r\n    if (!has(attributeName, data) || !contentTypesUtils.isComponentAttribute(attribute)) {\r\n      continue;\r\n    }\r\n\r\n    if (attribute.type === 'component') {\r\n      const { component: componentUID, repeatable = false } = attribute;\r\n\r\n      const componentValue = data[attributeName as keyof TData];\r\n\r\n      if (componentValue === null) {\r\n        continue;\r\n      }\r\n\r\n      if (repeatable === true) {\r\n        if (!Array.isArray(componentValue)) {\r\n          throw new Error('Expected an array to create repeatable component');\r\n        }\r\n\r\n        const components: RepeatableComponentValue = await async.map(componentValue, (value: any) =>\r\n          createComponent(componentUID, value)\r\n        );\r\n\r\n        componentBody[attributeName] = components.map(({ id }) => {\r\n          return {\r\n            id,\r\n            __pivot: {\r\n              field: attributeName,\r\n              component_type: componentUID,\r\n            },\r\n          };\r\n        });\r\n      } else {\r\n        const component = await createComponent(\r\n          componentUID,\r\n          componentValue as Input<UID.Component>\r\n        );\r\n\r\n        componentBody[attributeName] = {\r\n          id: component.id,\r\n          __pivot: {\r\n            field: attributeName,\r\n            component_type: componentUID,\r\n          },\r\n        };\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    if (attribute.type === 'dynamiczone') {\r\n      const dynamiczoneValues = data[\r\n        attributeName as keyof TData\r\n      ] as Modules.EntityService.Params.Attribute.GetValue<Schema.Attribute.DynamicZone>;\r\n\r\n      if (!Array.isArray(dynamiczoneValues)) {\r\n        throw new Error('Expected an array to create repeatable component');\r\n      }\r\n\r\n      const createDynamicZoneComponents = async (\r\n        value: Utils.Array.Values<typeof dynamiczoneValues>\r\n      ) => {\r\n        const { id } = await createComponent(value.__component, value);\r\n        return {\r\n          id,\r\n          __component: value.__component,\r\n          __pivot: {\r\n            field: attributeName,\r\n          },\r\n        };\r\n      };\r\n\r\n      // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\r\n      componentBody[attributeName] = await async.map(\r\n        dynamiczoneValues,\r\n        createDynamicZoneComponents\r\n      );\r\n\r\n      continue;\r\n    }\r\n  }\r\n\r\n  return componentBody;\r\n};\r\n\r\nconst getComponents = async <TUID extends UID.Schema>(\r\n  uid: TUID,\r\n  entity: { id: Modules.EntityService.Params.Attribute.ID }\r\n): Promise<LoadedComponents<TUID>> => {\r\n  const componentAttributes = contentTypesUtils.getComponentAttributes(strapi.getModel(uid));\r\n\r\n  if (_.isEmpty(componentAttributes)) {\r\n    return {} as LoadedComponents<TUID>;\r\n  }\r\n\r\n  return strapi.db.query(uid).load(entity, componentAttributes) as Promise<LoadedComponents<TUID>>;\r\n};\r\n\r\n/*\r\n  delete old components\r\n  create or update\r\n*/\r\nconst updateComponents = async <TUID extends UID.Schema, TData extends Partial<Input<TUID>>>(\r\n  uid: TUID,\r\n  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\r\n  data: TData\r\n) => {\r\n  const { attributes = {} } = strapi.getModel(uid);\r\n\r\n  const componentBody: ComponentBody = {};\r\n\r\n  for (const attributeName of Object.keys(attributes)) {\r\n    const attribute = attributes[attributeName];\r\n\r\n    if (!has(attributeName, data)) {\r\n      continue;\r\n    }\r\n\r\n    if (attribute.type === 'component') {\r\n      const { component: componentUID, repeatable = false } = attribute;\r\n\r\n      const componentValue = data[attributeName as keyof TData] as ComponentValue;\r\n\r\n      await deleteOldComponents(uid, componentUID, entityToUpdate, attributeName, componentValue);\r\n\r\n      if (repeatable === true) {\r\n        if (!Array.isArray(componentValue)) {\r\n          throw new Error('Expected an array to create repeatable component');\r\n        }\r\n\r\n        // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\r\n        const components: RepeatableComponentValue = await async.map(componentValue, (value: any) =>\r\n          updateOrCreateComponent(componentUID, value)\r\n        );\r\n\r\n        componentBody[attributeName] = components.filter(_.negate(_.isNil)).map(({ id }) => {\r\n          return {\r\n            id,\r\n            __pivot: {\r\n              field: attributeName,\r\n              component_type: componentUID,\r\n            },\r\n          };\r\n        });\r\n      } else {\r\n        const component = await updateOrCreateComponent(componentUID, componentValue);\r\n        componentBody[attributeName] = component && {\r\n          id: component.id,\r\n          __pivot: {\r\n            field: attributeName,\r\n            component_type: componentUID,\r\n          },\r\n        };\r\n      }\r\n    } else if (attribute.type === 'dynamiczone') {\r\n      const dynamiczoneValues = data[attributeName as keyof TData] as DynamicZoneValue;\r\n\r\n      await deleteOldDZComponents(uid, entityToUpdate, attributeName, dynamiczoneValues);\r\n\r\n      if (!Array.isArray(dynamiczoneValues)) {\r\n        throw new Error('Expected an array to create repeatable component');\r\n      }\r\n\r\n      // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\r\n      componentBody[attributeName] = await async.map(dynamiczoneValues, async (value: any) => {\r\n        const { id } = await updateOrCreateComponent(value.__component, value);\r\n\r\n        return {\r\n          id,\r\n          __component: value.__component,\r\n          __pivot: {\r\n            field: attributeName,\r\n          },\r\n        };\r\n      });\r\n    }\r\n  }\r\n\r\n  return componentBody;\r\n};\r\n\r\nconst pickStringifiedId = ({\r\n  id,\r\n}: {\r\n  id: Modules.EntityService.Params.Attribute.ID;\r\n}): Modules.EntityService.Params.Attribute.ID & string => {\r\n  if (typeof id === 'string') {\r\n    return id;\r\n  }\r\n\r\n  return `${id}`;\r\n};\r\n\r\nconst deleteOldComponents = async <TUID extends UID.Schema>(\r\n  uid: TUID,\r\n  componentUID: UID.Component,\r\n  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\r\n  attributeName: string,\r\n  componentValue: ComponentValue\r\n) => {\r\n  const previousValue = (await strapi.db\r\n    .query(uid)\r\n    .load(entityToUpdate, attributeName)) as ComponentValue;\r\n\r\n  const idsToKeep = _.castArray(componentValue).filter(has('id')).map(pickStringifiedId);\r\n  const allIds = _.castArray(previousValue).filter(has('id')).map(pickStringifiedId);\r\n\r\n  idsToKeep.forEach((id) => {\r\n    if (!allIds.includes(id)) {\r\n      throw new errors.ApplicationError(\r\n        `Some of the provided components in ${attributeName} are not related to the entity`\r\n      );\r\n    }\r\n  });\r\n\r\n  const idsToDelete = _.difference(allIds, idsToKeep);\r\n\r\n  if (idsToDelete.length > 0) {\r\n    for (const idToDelete of idsToDelete) {\r\n      await deleteComponent(componentUID, { id: idToDelete });\r\n    }\r\n  }\r\n};\r\n\r\nconst deleteOldDZComponents = async <TUID extends UID.Schema>(\r\n  uid: TUID,\r\n  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\r\n  attributeName: string,\r\n  dynamiczoneValues: DynamicZoneValue\r\n) => {\r\n  const previousValue = (await strapi.db\r\n    .query(uid)\r\n    .load(entityToUpdate, attributeName)) as DynamicZoneValue;\r\n\r\n  const idsToKeep = _.castArray(dynamiczoneValues)\r\n    .filter(has('id'))\r\n    .map((v) => ({\r\n      id: pickStringifiedId(v),\r\n      __component: v.__component,\r\n    }));\r\n\r\n  const allIds = _.castArray(previousValue)\r\n    .filter(has('id'))\r\n    .map((v) => ({\r\n      id: pickStringifiedId(v),\r\n      __component: v.__component,\r\n    }));\r\n\r\n  idsToKeep.forEach(({ id, __component }) => {\r\n    if (!allIds.find((el) => el.id === id && el.__component === __component)) {\r\n      const err = new Error(\r\n        `Some of the provided components in ${attributeName} are not related to the entity`\r\n      );\r\n\r\n      Object.assign(err, { status: 400 });\r\n      throw err;\r\n    }\r\n  });\r\n\r\n  type IdsToDelete = DynamicZoneValue;\r\n\r\n  const idsToDelete = allIds.reduce((acc, { id, __component }) => {\r\n    if (!idsToKeep.find((el) => el.id === id && el.__component === __component)) {\r\n      acc.push({ id, __component });\r\n    }\r\n\r\n    return acc;\r\n  }, [] as IdsToDelete);\r\n\r\n  if (idsToDelete.length > 0) {\r\n    for (const idToDelete of idsToDelete) {\r\n      const { id, __component } = idToDelete;\r\n      await deleteComponent(__component, { id });\r\n    }\r\n  }\r\n};\r\n\r\nconst deleteComponents = async <TUID extends UID.Schema, TEntity extends Data.Entity<TUID>>(\r\n  uid: TUID,\r\n  entityToDelete: TEntity,\r\n  { loadComponents = true } = {}\r\n) => {\r\n  const { attributes = {} } = strapi.getModel(uid);\r\n\r\n  const attributeNames = Object.keys(attributes);\r\n\r\n  for (const attributeName of attributeNames) {\r\n    const attribute = attributes[attributeName];\r\n\r\n    if (attribute.type === 'component' || attribute.type === 'dynamiczone') {\r\n      let value;\r\n\r\n      if (loadComponents) {\r\n        value = await strapi.db.query(uid).load(entityToDelete, attributeName);\r\n      } else {\r\n        value = entityToDelete[attributeName as keyof TEntity];\r\n      }\r\n\r\n      if (!value) {\r\n        continue;\r\n      }\r\n\r\n      if (attribute.type === 'component') {\r\n        const { component: componentUID } = attribute;\r\n        await async.map(_.castArray(value), (subValue: any) =>\r\n          deleteComponent(componentUID, subValue)\r\n        );\r\n      } else {\r\n        await async.map(_.castArray(value), (subValue: any) =>\r\n          deleteComponent(subValue.__component, subValue)\r\n        );\r\n      }\r\n\r\n      continue;\r\n    }\r\n  }\r\n};\r\n\r\n/** *************************\r\n    Component queries\r\n************************** */\r\n\r\n// components can have nested compos so this must be recursive\r\nconst createComponent = async <TUID extends UID.Component>(uid: TUID, data: Input<TUID>) => {\r\n  const schema = strapi.getModel(uid);\r\n\r\n  const componentData = await createComponents(uid, data);\r\n\r\n  const transform = pipe(\r\n    // Make sure we don't save the component with a pre-defined ID\r\n    omit('id'),\r\n    assignComponentData(schema, componentData)\r\n  );\r\n\r\n  return strapi.db.query(uid).create({ data: transform(data) });\r\n};\r\n\r\n// components can have nested compos so this must be recursive\r\nconst updateComponent = async <TUID extends UID.Component>(\r\n  uid: TUID,\r\n  componentToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\r\n  data: Input<TUID>\r\n) => {\r\n  const schema = strapi.getModel(uid);\r\n\r\n  const componentData = await updateComponents(uid, componentToUpdate, data);\r\n\r\n  return strapi.db.query(uid).update({\r\n    where: {\r\n      id: componentToUpdate.id,\r\n    },\r\n    data: assignComponentData(schema, componentData, data),\r\n  });\r\n};\r\n\r\nconst updateOrCreateComponent = <TUID extends UID.Component>(\r\n  componentUID: TUID,\r\n  value: Input<TUID>\r\n) => {\r\n  if (value === null) {\r\n    return null;\r\n  }\r\n\r\n  // update\r\n  if ('id' in value && typeof value.id !== 'undefined') {\r\n    // TODO: verify the compo is associated with the entity\r\n    return updateComponent(componentUID, { id: value.id }, value);\r\n  }\r\n\r\n  // create\r\n  return createComponent(componentUID, value);\r\n};\r\n\r\nconst deleteComponent = async <TUID extends UID.Component>(\r\n  uid: TUID,\r\n  componentToDelete: Data.Component<TUID>\r\n) => {\r\n  await deleteComponents(uid, componentToDelete);\r\n  await strapi.db.query(uid).delete({ where: { id: componentToDelete.id } });\r\n};\r\n\r\nconst assignComponentData = curry(\r\n  (schema: Schema.Schema, componentData: ComponentBody, data: Input<UID.Schema>) => {\r\n    return pipe(omitComponentData(schema), assign(componentData))(data);\r\n  }\r\n);\r\n\r\nexport {\r\n  omitComponentData,\r\n  assignComponentData,\r\n  getComponents,\r\n  createComponents,\r\n  updateComponents,\r\n  deleteComponents,\r\n  deleteComponent,\r\n};\r\n"],"names":["curry","contentTypesUtils","omit","has","async","_","errors","pipe","assign"],"mappings":"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"}