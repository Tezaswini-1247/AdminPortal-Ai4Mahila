{"version":3,"file":"validator.mjs","sources":["../../../src/domain/content-type/validator.ts"],"sourcesContent":["import _ from 'lodash';\r\nimport { yup, strings } from '@strapi/utils';\r\nimport type { Schema } from '@strapi/types';\r\n\r\nconst LIFECYCLES = [\r\n  'beforeCreate',\r\n  'afterCreate',\r\n  'beforeFindOne',\r\n  'afterFindOne',\r\n  'beforeFindMany',\r\n  'afterFindMany',\r\n  'beforeCount',\r\n  'afterCount',\r\n  'beforeCreateMany',\r\n  'afterCreateMany',\r\n  'beforeUpdate',\r\n  'afterUpdate',\r\n  'beforeUpdateMany',\r\n  'afterUpdateMany',\r\n  'beforeDelete',\r\n  'afterDelete',\r\n  'beforeDeleteMany',\r\n  'afterDeleteMany',\r\n] as const;\r\n\r\n/**\r\n * For enumerations the least common denomiator is GraphQL, where\r\n * values needs to match the secure name regex:\r\n * GraphQL Spec https://spec.graphql.org/June2018/#sec-Names\r\n *\r\n * Therefore we need to make sure our users only use values, which\r\n * can be returned by GraphQL, by checking the regressed values\r\n * agains the GraphQL regex.\r\n *\r\n * TODO V5: check if we can avoid this coupling by moving this logic\r\n * into the GraphQL plugin.\r\n */\r\nconst GRAPHQL_ENUM_REGEX = /^[_A-Za-z][_0-9A-Za-z]*$/;\r\n\r\nconst lifecyclesShape = _.mapValues(_.keyBy(LIFECYCLES), () => yup.mixed().nullable().isFunction());\r\n\r\nconst contentTypeSchemaValidator = yup.object().shape({\r\n  schema: yup.object().shape({\r\n    info: yup\r\n      .object()\r\n      .shape({\r\n        displayName: yup.string().required(),\r\n        singularName: yup.string().isKebabCase().required(),\r\n        pluralName: yup.string().isKebabCase().required(),\r\n      })\r\n      .required(),\r\n    attributes: yup.object().test({\r\n      name: 'valuesCollide',\r\n      message: 'Some values collide when normalized',\r\n      test(attributes: Schema.ContentType['attributes']) {\r\n        for (const attrName of Object.keys(attributes)) {\r\n          const attr = attributes[attrName];\r\n          if (attr.type === 'enumeration') {\r\n            const regressedValues = attr.enum.map(strings.toRegressedEnumValue);\r\n\r\n            // should match the GraphQL regex\r\n            if (!regressedValues.every((value: string) => GRAPHQL_ENUM_REGEX.test(value))) {\r\n              const message = `Invalid enumeration value. Values should have at least one alphabetical character preceding the first occurence of a number. Update your enumeration '${attrName}'.`;\r\n\r\n              return this.createError({ message });\r\n            }\r\n\r\n            // should not contain empty values\r\n            if (regressedValues.some((value: string) => value === '')) {\r\n              return this.createError({\r\n                message: `At least one value of the enumeration '${attrName}' appears to be empty. Only alphanumerical characters are taken into account.`,\r\n              });\r\n            }\r\n\r\n            // should not collide\r\n            const duplicates = _.uniq(\r\n              regressedValues.filter(\r\n                (value: string, index: number, values: string[]) => values.indexOf(value) !== index\r\n              )\r\n            );\r\n\r\n            if (duplicates.length) {\r\n              const message = `Some enumeration values of the field '${attrName}' collide when normalized: ${duplicates.join(\r\n                ', '\r\n              )}. Please modify your enumeration.`;\r\n\r\n              return this.createError({ message });\r\n            }\r\n          }\r\n        }\r\n\r\n        return true;\r\n      },\r\n    }),\r\n  }),\r\n  actions: yup.object().onlyContainsFunctions(),\r\n  lifecycles: yup.object().shape(lifecyclesShape).noUnknown(),\r\n});\r\n\r\nconst validateContentTypeDefinition = (data: unknown) => {\r\n  return contentTypeSchemaValidator.validateSync(data, { strict: true, abortEarly: false });\r\n};\r\n\r\nexport { validateContentTypeDefinition };\r\n"],"names":[],"mappings":";;AAIA,MAAM,aAAa;AAAA,EACjB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAcA,MAAM,qBAAqB;AAE3B,MAAM,kBAAkB,EAAE,UAAU,EAAE,MAAM,UAAU,GAAG,MAAM,IAAI,MAAM,EAAE,SAAS,EAAE,YAAY;AAElG,MAAM,6BAA6B,IAAI,OAAO,EAAE,MAAM;AAAA,EACpD,QAAQ,IAAI,OAAO,EAAE,MAAM;AAAA,IACzB,MAAM,IACH,OAAO,EACP,MAAM;AAAA,MACL,aAAa,IAAI,OAAO,EAAE,SAAS;AAAA,MACnC,cAAc,IAAI,OAAS,EAAA,YAAA,EAAc,SAAS;AAAA,MAClD,YAAY,IAAI,SAAS,cAAc,SAAS;AAAA,IACjD,CAAA,EACA,SAAS;AAAA,IACZ,YAAY,IAAI,OAAO,EAAE,KAAK;AAAA,MAC5B,MAAM;AAAA,MACN,SAAS;AAAA,MACT,KAAK,YAA8C;AACjD,mBAAW,YAAY,OAAO,KAAK,UAAU,GAAG;AACxC,gBAAA,OAAO,WAAW,QAAQ;AAC5B,cAAA,KAAK,SAAS,eAAe;AAC/B,kBAAM,kBAAkB,KAAK,KAAK,IAAI,QAAQ,oBAAoB;AAG9D,gBAAA,CAAC,gBAAgB,MAAM,CAAC,UAAkB,mBAAmB,KAAK,KAAK,CAAC,GAAG;AACvE,oBAAA,UAAU,yJAAyJ,QAAQ;AAEjL,qBAAO,KAAK,YAAY,EAAE,SAAS;AAAA,YAAA;AAIrC,gBAAI,gBAAgB,KAAK,CAAC,UAAkB,UAAU,EAAE,GAAG;AACzD,qBAAO,KAAK,YAAY;AAAA,gBACtB,SAAS,0CAA0C,QAAQ;AAAA,cAAA,CAC5D;AAAA,YAAA;AAIH,kBAAM,aAAa,EAAE;AAAA,cACnB,gBAAgB;AAAA,gBACd,CAAC,OAAe,OAAe,WAAqB,OAAO,QAAQ,KAAK,MAAM;AAAA,cAAA;AAAA,YAElF;AAEA,gBAAI,WAAW,QAAQ;AACrB,oBAAM,UAAU,yCAAyC,QAAQ,8BAA8B,WAAW;AAAA,gBACxG;AAAA,cACD,CAAA;AAED,qBAAO,KAAK,YAAY,EAAE,SAAS;AAAA,YAAA;AAAA,UACrC;AAAA,QACF;AAGK,eAAA;AAAA,MAAA;AAAA,IAEV,CAAA;AAAA,EAAA,CACF;AAAA,EACD,SAAS,IAAI,OAAO,EAAE,sBAAsB;AAAA,EAC5C,YAAY,IAAI,OAAA,EAAS,MAAM,eAAe,EAAE,UAAU;AAC5D,CAAC;AAEK,MAAA,gCAAgC,CAAC,SAAkB;AAChD,SAAA,2BAA2B,aAAa,MAAM,EAAE,QAAQ,MAAM,YAAY,OAAO;AAC1F;"}