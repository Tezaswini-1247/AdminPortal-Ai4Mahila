{"version":3,"file":"plugins.js","sources":["../../../src/node/core/plugins.ts"],"sourcesContent":["import os from 'node:os';\r\nimport path from 'node:path';\r\nimport fs from 'node:fs';\r\nimport camelCase from 'lodash/camelCase';\r\nimport { env } from '@strapi/utils';\r\nimport { getModule, PackageJson } from './dependencies';\r\nimport { convertModulePathToSystemPath, convertSystemPathToModulePath, loadFile } from './files';\r\nimport type { BaseContext } from '../types';\r\nimport { isError } from './errors';\r\n\r\ninterface LocalPluginMeta {\r\n  name: string;\r\n  /**\r\n   * camelCased version of the plugin name\r\n   */\r\n  importName: string;\r\n  /**\r\n   * The path to the plugin, relative to the app's root directory\r\n   * in system format\r\n   */\r\n  path: string;\r\n  /**\r\n   * The path to the plugin, relative to the runtime directory\r\n   * in module format (i.e. with forward slashes) because thats\r\n   * where it should be used as an import\r\n   */\r\n  modulePath: string;\r\n  type: 'local';\r\n}\r\n\r\ninterface ModulePluginMeta {\r\n  name: string;\r\n  /**\r\n   * camelCased version of the plugin name\r\n   */\r\n  importName: string;\r\n  /**\r\n   * Modules don't have a path because we never resolve them to their node_modules\r\n   * because we simply do not require it.\r\n   */\r\n  path?: never;\r\n  /**\r\n   * The path to the plugin, relative to the app's root directory\r\n   * in module format (i.e. with forward slashes)\r\n   */\r\n  modulePath: string;\r\n  type: 'module';\r\n}\r\n\r\ntype PluginMeta = LocalPluginMeta | ModulePluginMeta;\r\n\r\ninterface StrapiPlugin extends PackageJson {\r\n  strapi: {\r\n    description?: string;\r\n    displayName?: string;\r\n    kind: 'plugin';\r\n    name?: string;\r\n    required?: boolean;\r\n  };\r\n}\r\n\r\nconst validatePackageHasStrapi = (\r\n  pkg: PackageJson\r\n): pkg is PackageJson & { strapi: Record<string, unknown> } =>\r\n  'strapi' in pkg &&\r\n  typeof pkg.strapi === 'object' &&\r\n  !Array.isArray(pkg.strapi) &&\r\n  pkg.strapi !== null;\r\n\r\nconst validatePackageIsPlugin = (pkg: PackageJson): pkg is StrapiPlugin =>\r\n  validatePackageHasStrapi(pkg) && pkg.strapi.kind === 'plugin';\r\n\r\nconst getEnabledPlugins = async ({\r\n  cwd,\r\n  logger,\r\n  runtimeDir,\r\n  strapi,\r\n}: Pick<BaseContext, 'cwd' | 'logger' | 'strapi' | 'runtimeDir'>): Promise<\r\n  Record<string, PluginMeta>\r\n> => {\r\n  const plugins: Record<string, PluginMeta> = {};\r\n\r\n  /**\r\n   * This is the list of dependencies that are installed in the user's project.\r\n   * It will include libraries like \"react\", so we need to collect the ones that\r\n   * are plugins.\r\n   */\r\n  const deps = strapi.config.get('info.dependencies', {});\r\n\r\n  logger.debug(\"Dependencies from user's project\", os.EOL, deps);\r\n\r\n  for (const dep of Object.keys(deps)) {\r\n    const pkg = await getModule(dep, cwd);\r\n\r\n    if (pkg && validatePackageIsPlugin(pkg)) {\r\n      const name = pkg.strapi.name || pkg.name;\r\n\r\n      if (!name) {\r\n        /**\r\n         * Unlikely to happen, but you never know.\r\n         */\r\n        throw Error(\r\n          \"You're trying to import a plugin that doesn't have a name â€“ check the package.json of that plugin!\"\r\n        );\r\n      }\r\n\r\n      plugins[name] = {\r\n        name,\r\n        importName: camelCase(name),\r\n        type: 'module',\r\n        modulePath: dep,\r\n      };\r\n    }\r\n  }\r\n\r\n  const userPluginsFile = await loadUserPluginsFile(strapi.dirs.app.config);\r\n\r\n  logger.debug(\"User's plugins file\", os.EOL, userPluginsFile);\r\n\r\n  for (const [userPluginName, userPluginConfig] of Object.entries(userPluginsFile)) {\r\n    if (userPluginConfig.enabled && userPluginConfig.resolve) {\r\n      const sysPath = convertModulePathToSystemPath(userPluginConfig.resolve);\r\n      plugins[userPluginName] = {\r\n        name: userPluginName,\r\n        importName: camelCase(userPluginName),\r\n        type: 'local',\r\n        /**\r\n         * User plugin paths are resolved from the entry point\r\n         * of the app, because that's how you import them.\r\n         */\r\n        modulePath: convertSystemPathToModulePath(path.relative(runtimeDir, sysPath)),\r\n        path: sysPath,\r\n      };\r\n    }\r\n  }\r\n\r\n  return plugins;\r\n};\r\n\r\nconst PLUGIN_CONFIGS = ['plugins.js', 'plugins.mjs', 'plugins.ts'];\r\n\r\ntype UserPluginConfigFile = Record<string, { enabled: boolean; resolve: string }>;\r\n\r\nconst loadUserPluginsFile = async (root: string): Promise<UserPluginConfigFile> => {\r\n  for (const file of PLUGIN_CONFIGS) {\r\n    const filePath = path.join(root, file);\r\n    const configFile = await loadFile(filePath);\r\n\r\n    if (configFile) {\r\n      /**\r\n       * Configs can be a function or they can be just an object!\r\n       */\r\n      return typeof configFile === 'function' ? configFile({ env }) : configFile;\r\n    }\r\n  }\r\n\r\n  return {};\r\n};\r\n\r\nconst getMapOfPluginsWithAdmin = (plugins: Record<string, PluginMeta>) => {\r\n  /**\r\n   * This variable stores the import paths for plugins.\r\n   * The keys are the module paths of the plugins, and the values are the paths\r\n   * to the admin part of the plugins, which is either loaded from the\r\n   * package.json exports or from the legacy strapi-admin.js file.\r\n   */\r\n  const pluginImportPaths: Record<string, string> = {};\r\n\r\n  return Object.values(plugins)\r\n    .filter((plugin) => {\r\n      if (!plugin) {\r\n        return false;\r\n      }\r\n\r\n      /**\r\n       * There are two ways a plugin should be imported, either it's local to the strapi app,\r\n       * or it's an actual npm module that's installed and resolved via node_modules.\r\n       *\r\n       * We first check if the plugin is local to the strapi app, using a regular `fs.existsSync` because\r\n       * the pathToPlugin will be relative i.e. `/Users/my-name/strapi-app/src/plugins/my-plugin`.\r\n       *\r\n       * If the file doesn't exist well then it's probably a node_module, so instead we use `require.resolve`\r\n       * which will resolve the path to the module in node_modules. If it fails with the specific code `MODULE_NOT_FOUND`\r\n       * then it doesn't have an admin part to the package.\r\n       */\r\n      try {\r\n        const localPluginPath = plugin.path;\r\n        if (localPluginPath) {\r\n          // Here we are loading a locally installed plugin\r\n          const packageJsonPath = path.join(localPluginPath, 'package.json');\r\n\r\n          if (fs.existsSync(packageJsonPath)) {\r\n            const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));\r\n            const localAdminPath = packageJson?.exports?.['./strapi-admin']?.import;\r\n\r\n            if (localAdminPath) {\r\n              pluginImportPaths[plugin.modulePath] = localAdminPath;\r\n              return true;\r\n            }\r\n          }\r\n\r\n          // Check if legacy admin file exists in local plugin\r\n          if (fs.existsSync(path.join(localPluginPath, 'strapi-admin.js'))) {\r\n            pluginImportPaths[plugin.modulePath] = 'strapi-admin';\r\n            return true;\r\n          }\r\n        }\r\n\r\n        // This plugin is a module, so we need to check if it has a strapi-admin export\r\n        if (require.resolve(`${plugin.modulePath}/strapi-admin`)) {\r\n          pluginImportPaths[plugin.modulePath] = 'strapi-admin';\r\n          return true;\r\n        }\r\n\r\n        return false;\r\n      } catch (err) {\r\n        if (\r\n          isError(err) &&\r\n          'code' in err &&\r\n          (err.code === 'MODULE_NOT_FOUND' || err.code === 'ERR_PACKAGE_PATH_NOT_EXPORTED')\r\n        ) {\r\n          /**\r\n           * the plugin does not contain FE code, so we\r\n           * don't want to import it anyway\r\n           */\r\n          return false;\r\n        }\r\n\r\n        throw err;\r\n      }\r\n    })\r\n    .map((plugin) => ({\r\n      ...plugin,\r\n      modulePath: `${plugin.modulePath}/${pluginImportPaths[plugin.modulePath]}`,\r\n    }));\r\n};\r\n\r\nexport { getEnabledPlugins, getMapOfPluginsWithAdmin };\r\nexport type { PluginMeta, LocalPluginMeta, ModulePluginMeta };\r\n"],"names":["os","getModule","camelCase","convertModulePathToSystemPath","convertSystemPathToModulePath","path","loadFile","env","fs","isError"],"mappings":"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"}