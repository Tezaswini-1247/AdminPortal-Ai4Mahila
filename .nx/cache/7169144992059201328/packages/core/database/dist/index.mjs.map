{"version":3,"file":"index.mjs","sources":["../src/dialects/dialect.ts","../src/errors/database.ts","../src/errors/not-null.ts","../src/errors/invalid-time.ts","../src/errors/invalid-date.ts","../src/errors/invalid-datetime.ts","../src/errors/invalid-relation.ts","../src/dialects/postgresql/schema-inspector.ts","../src/dialects/postgresql/index.ts","../src/dialects/mysql/schema-inspector.ts","../src/dialects/mysql/constants.ts","../src/dialects/mysql/database-inspector.ts","../src/dialects/mysql/index.ts","../src/dialects/sqlite/schema-inspector.ts","../src/dialects/sqlite/index.ts","../src/dialects/index.ts","../src/schema/builder.ts","../src/schema/diff.ts","../src/schema/storage.ts","../src/utils/types.ts","../src/utils/identifiers/hash.ts","../src/utils/identifiers/index.ts","../src/schema/schema.ts","../src/schema/index.ts","../src/metadata/relations.ts","../src/metadata/metadata.ts","../src/metadata/index.ts","../src/fields/field.ts","../src/fields/string.ts","../src/fields/json.ts","../src/fields/biginteger.ts","../src/fields/number.ts","../src/fields/shared/parsers.ts","../src/fields/date.ts","../src/fields/time.ts","../src/fields/datetime.ts","../src/fields/timestamp.ts","../src/fields/boolean.ts","../src/fields/index.ts","../src/transaction-context.ts","../src/utils/knex.ts","../src/query/helpers/transform.ts","../src/query/helpers/search.ts","../src/query/helpers/join.ts","../src/query/helpers/order-by.ts","../src/query/helpers/populate/apply.ts","../src/query/helpers/populate/process.ts","../src/query/helpers/where.ts","../src/query/helpers/streams/readable.ts","../src/query/query-builder.ts","../src/entity-manager/entity-repository.ts","../src/entity-manager/morph-relations.ts","../src/entity-manager/regular-relations.ts","../src/entity-manager/relations-orderer.ts","../src/entity-manager/index.ts","../src/migrations/storage.ts","../src/migrations/common.ts","../src/migrations/logger.ts","../src/migrations/users.ts","../src/migrations/internal-migrations/5.0.0-02-document-id.ts","../src/migrations/internal-migrations/5.0.0-01-convert-identifiers-long-than-max-length.ts","../src/migrations/internal-migrations/5.0.0-03-locale.ts","../src/migrations/internal-migrations/5.0.0-04-published-at.ts","../src/migrations/internal-migrations/5.0.0-05-drop-slug-unique-index.ts","../src/migrations/internal-migrations/index.ts","../src/migrations/internal.ts","../src/migrations/index.ts","../src/lifecycles/subscribers/models-lifecycles.ts","../src/lifecycles/subscribers/timestamps.ts","../src/lifecycles/subscribers/index.ts","../src/lifecycles/index.ts","../src/connection.ts","../src/validations/relations/bidirectional.ts","../src/validations/relations/index.ts","../src/validations/index.ts","../src/index.ts"],"sourcesContent":["import type { Database } from '..';\r\nimport type { Schema } from '../schema';\r\n\r\nexport interface SchemaInspector {\r\n  getSchema(): Promise<Schema>;\r\n}\r\n\r\nexport default class Dialect {\r\n  db: Database;\r\n\r\n  schemaInspector: SchemaInspector = {} as SchemaInspector;\r\n\r\n  client: string;\r\n\r\n  constructor(db: Database, client: string) {\r\n    this.db = db;\r\n    this.client = client;\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n  configure(conn?: any) {}\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n  async initialize(_nativeConnection?: unknown) {\r\n    // noop\r\n  }\r\n\r\n  getSqlType(type: unknown) {\r\n    return type;\r\n  }\r\n\r\n  canAlterConstraints() {\r\n    return true;\r\n  }\r\n\r\n  usesForeignKeys() {\r\n    return false;\r\n  }\r\n\r\n  useReturning() {\r\n    return false;\r\n  }\r\n\r\n  supportsUnsigned() {\r\n    return false;\r\n  }\r\n\r\n  supportsOperator(operator?: string): boolean;\r\n  supportsOperator(): boolean {\r\n    return true;\r\n  }\r\n\r\n  async startSchemaUpdate() {\r\n    // noop\r\n  }\r\n\r\n  async endSchemaUpdate() {\r\n    // noop\r\n  }\r\n\r\n  transformErrors(error: Error | { message: string }) {\r\n    if (error instanceof Error) {\r\n      throw error;\r\n    }\r\n\r\n    throw new Error(error.message);\r\n  }\r\n\r\n  canAddIncrements() {\r\n    return true;\r\n  }\r\n}\r\n","export default class DatabaseError extends Error {\r\n  details: unknown;\r\n\r\n  constructor(message = 'A database error occured', details = {}) {\r\n    super();\r\n    this.name = 'DatabaseError';\r\n    this.message = message;\r\n    this.details = details;\r\n  }\r\n}\r\n","import DatabaseError from './database';\r\n\r\nexport default class NotNullError extends DatabaseError {\r\n  constructor({ column = '' } = {}) {\r\n    super(`Not null constraint violation${column ? ` on column ${column}` : ''}.`);\r\n    this.name = 'NotNullError';\r\n    this.details = { column };\r\n    this.stack = '';\r\n  }\r\n}\r\n","import DatabaseError from './database';\r\n\r\nexport default class InvalidTimeError extends DatabaseError {\r\n  constructor(message = 'Invalid time format, expected HH:mm:ss.SSS') {\r\n    super(message);\r\n    this.name = 'InvalidTimeFormat';\r\n  }\r\n}\r\n","import DatabaseError from './database';\r\n\r\nexport default class InvalidDateError extends DatabaseError {\r\n  constructor(message = 'Invalid date format, expected YYYY-MM-DD') {\r\n    super(message);\r\n    this.name = 'InvalidDateFormat';\r\n  }\r\n}\r\n","import DatabaseError from './database';\r\n\r\nexport default class InvalidDateTimeError extends DatabaseError {\r\n  constructor(message = 'Invalid relation format') {\r\n    super(message);\r\n    this.name = 'InvalidDatetimeFormat';\r\n  }\r\n}\r\n","import DatabaseError from './database';\r\n\r\nexport default class InvalidRelationError extends DatabaseError {\r\n  constructor(message = 'Invalid relation format') {\r\n    super(message);\r\n    this.name = 'InvalidRelationFormat';\r\n  }\r\n}\r\n","import type { Database } from '../..';\r\nimport type { Schema, Column, Index, ForeignKey } from '../../schema/types';\r\nimport type { SchemaInspector } from '../dialect';\r\n\r\ninterface RawTable {\r\n  table_name: string;\r\n}\r\n\r\ninterface RawColumn {\r\n  data_type: string;\r\n  column_name: string;\r\n  character_maximum_length: number;\r\n  column_default: string;\r\n  is_nullable: string;\r\n}\r\n\r\ninterface RawIndex {\r\n  indexrelid: string;\r\n  index_name: string;\r\n  column_name: string;\r\n  is_unique: boolean;\r\n  is_primary: boolean;\r\n}\r\n\r\ninterface RawForeignKey {\r\n  constraint_name: string;\r\n}\r\n\r\nconst SQL_QUERIES = {\r\n  TABLE_LIST: /* sql */ `\r\n    SELECT *\r\n    FROM information_schema.tables\r\n    WHERE\r\n      table_schema = ?\r\n      AND table_type = 'BASE TABLE'\r\n      AND table_name != 'geometry_columns'\r\n      AND table_name != 'spatial_ref_sys';\r\n  `,\r\n  LIST_COLUMNS: /* sql */ `\r\n    SELECT data_type, column_name, character_maximum_length, column_default, is_nullable\r\n    FROM information_schema.columns\r\n    WHERE table_schema = ? AND table_name = ?;\r\n  `,\r\n  INDEX_LIST: /* sql */ `\r\n    SELECT\r\n      ix.indexrelid,\r\n      i.relname as index_name,\r\n      a.attname as column_name,\r\n      ix.indisunique as is_unique,\r\n      ix.indisprimary as is_primary\r\n    FROM\r\n      pg_class t,\r\n      pg_namespace s,\r\n      pg_class i,\r\n      pg_index ix,\r\n      pg_attribute a\r\n    WHERE\r\n      t.oid = ix.indrelid\r\n      AND i.oid = ix.indexrelid\r\n      AND a.attrelid = t.oid\r\n      AND a.attnum = ANY(ix.indkey)\r\n      AND t.relkind = 'r'\r\n      AND t.relnamespace = s.oid\r\n      AND s.nspname = ?\r\n      AND t.relname = ?;\r\n  `,\r\n  FOREIGN_KEY_LIST: /* sql */ `\r\n    SELECT\r\n      tco.\"constraint_name\" as constraint_name\r\n    FROM information_schema.table_constraints tco\r\n    WHERE\r\n      tco.constraint_type = 'FOREIGN KEY'\r\n      AND tco.constraint_schema = ?\r\n      AND tco.table_name = ?\r\n  `,\r\n  FOREIGN_KEY_REFERENCES: /* sql */ `\r\n    SELECT\r\n      kcu.\"constraint_name\" as constraint_name,\r\n      kcu.\"column_name\" as column_name\r\n\r\n    FROM information_schema.key_column_usage kcu\r\n    WHERE kcu.constraint_name=ANY(?)\r\n    AND kcu.table_schema = ?\r\n    AND kcu.table_name = ?;\r\n  `,\r\n\r\n  FOREIGN_KEY_REFERENCES_CONSTRAIN: /* sql */ `\r\n  SELECT\r\n  rco.update_rule as on_update,\r\n  rco.delete_rule as on_delete,\r\n  rco.\"unique_constraint_name\" as unique_constraint_name\r\n  FROM information_schema.referential_constraints rco\r\n  WHERE rco.constraint_name=ANY(?)\r\n  AND rco.constraint_schema = ?\r\n`,\r\n  FOREIGN_KEY_REFERENCES_CONSTRAIN_RFERENCE: /* sql */ `\r\n  SELECT\r\n  rel_kcu.\"table_name\" as foreign_table,\r\n  rel_kcu.\"column_name\" as fk_column_name\r\n    FROM information_schema.key_column_usage rel_kcu\r\n    WHERE rel_kcu.constraint_name=?\r\n    AND rel_kcu.table_schema = ?\r\n`,\r\n};\r\n\r\nconst toStrapiType = (column: RawColumn) => {\r\n  const rootType = column.data_type.toLowerCase().match(/[^(), ]+/)?.[0];\r\n\r\n  switch (rootType) {\r\n    case 'integer': {\r\n      // find a way to figure out the increments\r\n      return { type: 'integer' };\r\n    }\r\n    case 'text': {\r\n      return { type: 'text', args: ['longtext'] };\r\n    }\r\n    case 'boolean': {\r\n      return { type: 'boolean' };\r\n    }\r\n    case 'character': {\r\n      return { type: 'string', args: [column.character_maximum_length] };\r\n    }\r\n    case 'timestamp': {\r\n      return { type: 'datetime', args: [{ useTz: false, precision: 6 }] };\r\n    }\r\n    case 'date': {\r\n      return { type: 'date' };\r\n    }\r\n    case 'time': {\r\n      return { type: 'time', args: [{ precision: 3 }] };\r\n    }\r\n    case 'numeric': {\r\n      return { type: 'decimal', args: [10, 2] };\r\n    }\r\n    case 'real':\r\n    case 'double': {\r\n      return { type: 'double' };\r\n    }\r\n    case 'bigint': {\r\n      return { type: 'bigInteger' };\r\n    }\r\n    case 'jsonb': {\r\n      return { type: 'jsonb' };\r\n    }\r\n    default: {\r\n      return { type: 'specificType', args: [column.data_type] };\r\n    }\r\n  }\r\n};\r\n\r\nconst getIndexType = (index: RawIndex) => {\r\n  if (index.is_primary) {\r\n    return 'primary';\r\n  }\r\n\r\n  if (index.is_unique) {\r\n    return 'unique';\r\n  }\r\n};\r\n\r\nexport default class PostgresqlSchemaInspector implements SchemaInspector {\r\n  db: Database;\r\n\r\n  constructor(db: Database) {\r\n    this.db = db;\r\n  }\r\n\r\n  async getSchema() {\r\n    const schema: Schema = { tables: [] };\r\n\r\n    const tables = await this.getTables();\r\n\r\n    schema.tables = await Promise.all(\r\n      tables.map(async (tableName) => {\r\n        const columns = await this.getColumns(tableName);\r\n        const indexes = await this.getIndexes(tableName);\r\n        const foreignKeys = await this.getForeignKeys(tableName);\r\n\r\n        return {\r\n          name: tableName,\r\n          columns,\r\n          indexes,\r\n          foreignKeys,\r\n        };\r\n      })\r\n    );\r\n\r\n    return schema;\r\n  }\r\n\r\n  getDatabaseSchema(): string {\r\n    return this.db.getSchemaName() || 'public';\r\n  }\r\n\r\n  async getTables(): Promise<string[]> {\r\n    const { rows } = await this.db.connection.raw<{ rows: RawTable[] }>(SQL_QUERIES.TABLE_LIST, [\r\n      this.getDatabaseSchema(),\r\n    ]);\r\n\r\n    return rows.map((row) => row.table_name);\r\n  }\r\n\r\n  async getColumns(tableName: string): Promise<Column[]> {\r\n    const { rows } = await this.db.connection.raw<{ rows: RawColumn[] }>(SQL_QUERIES.LIST_COLUMNS, [\r\n      this.getDatabaseSchema(),\r\n      tableName,\r\n    ]);\r\n\r\n    return rows.map((row) => {\r\n      const { type, args = [], ...rest } = toStrapiType(row);\r\n\r\n      const defaultTo =\r\n        row.column_default && row.column_default.includes('nextval(') ? null : row.column_default;\r\n\r\n      return {\r\n        type,\r\n        args,\r\n        defaultTo,\r\n        name: row.column_name,\r\n        notNullable: row.is_nullable === 'NO',\r\n        unsigned: false,\r\n        ...rest,\r\n      };\r\n    });\r\n  }\r\n\r\n  async getIndexes(tableName: string): Promise<Index[]> {\r\n    const { rows } = await this.db.connection.raw<{ rows: RawIndex[] }>(SQL_QUERIES.INDEX_LIST, [\r\n      this.getDatabaseSchema(),\r\n      tableName,\r\n    ]);\r\n\r\n    const ret: Record<RawIndex['indexrelid'], Index> = {};\r\n\r\n    for (const index of rows) {\r\n      if (index.column_name === 'id') {\r\n        continue;\r\n      }\r\n\r\n      if (!ret[index.indexrelid]) {\r\n        ret[index.indexrelid] = {\r\n          columns: [index.column_name],\r\n          name: index.index_name,\r\n          type: getIndexType(index),\r\n        };\r\n      } else {\r\n        ret[index.indexrelid].columns.push(index.column_name);\r\n      }\r\n    }\r\n\r\n    return Object.values(ret);\r\n  }\r\n\r\n  async getForeignKeys(tableName: string): Promise<ForeignKey[]> {\r\n    const { rows } = await this.db.connection.raw<{ rows: RawForeignKey[] }>(\r\n      SQL_QUERIES.FOREIGN_KEY_LIST,\r\n      [this.getDatabaseSchema(), tableName]\r\n    );\r\n\r\n    const ret: Record<RawForeignKey['constraint_name'], ForeignKey> = {};\r\n\r\n    for (const fk of rows) {\r\n      ret[fk.constraint_name] = {\r\n        name: fk.constraint_name,\r\n        columns: [],\r\n        referencedColumns: [],\r\n        referencedTable: null,\r\n        onUpdate: null,\r\n        onDelete: null,\r\n      } as unknown as ForeignKey;\r\n    }\r\n\r\n    const constraintNames = Object.keys(ret);\r\n    const dbSchema = this.getDatabaseSchema();\r\n    if (constraintNames.length > 0) {\r\n      const { rows: fkReferences } = await this.db.connection.raw(\r\n        SQL_QUERIES.FOREIGN_KEY_REFERENCES,\r\n        [[constraintNames], dbSchema, tableName]\r\n      );\r\n\r\n      for (const fkReference of fkReferences) {\r\n        ret[fkReference.constraint_name].columns.push(fkReference.column_name);\r\n\r\n        const { rows: fkReferencesConstraint } = await this.db.connection.raw(\r\n          SQL_QUERIES.FOREIGN_KEY_REFERENCES_CONSTRAIN,\r\n          [[fkReference.constraint_name], dbSchema]\r\n        );\r\n\r\n        for (const fkReferenceC of fkReferencesConstraint) {\r\n          const { rows: fkReferencesConstraintReferece } = await this.db.connection.raw(\r\n            SQL_QUERIES.FOREIGN_KEY_REFERENCES_CONSTRAIN_RFERENCE,\r\n            [fkReferenceC.unique_constraint_name, dbSchema]\r\n          );\r\n          for (const fkReferenceConst of fkReferencesConstraintReferece) {\r\n            ret[fkReference.constraint_name].referencedTable = fkReferenceConst.foreign_table;\r\n            ret[fkReference.constraint_name].referencedColumns.push(\r\n              fkReferenceConst.fk_column_name\r\n            );\r\n          }\r\n          ret[fkReference.constraint_name].onUpdate = fkReferenceC.on_update.toUpperCase();\r\n          ret[fkReference.constraint_name].onDelete = fkReferenceC.on_delete.toUpperCase();\r\n        }\r\n      }\r\n    }\r\n\r\n    return Object.values(ret);\r\n  }\r\n}\r\n","import * as errors from '../../errors';\r\nimport type { Database } from '../..';\r\nimport Dialect from '../dialect';\r\nimport PostgresqlSchemaInspector from './schema-inspector';\r\n\r\nexport default class PostgresDialect extends Dialect {\r\n  schemaInspector: PostgresqlSchemaInspector;\r\n\r\n  constructor(db: Database) {\r\n    super(db, 'postgres');\r\n\r\n    this.schemaInspector = new PostgresqlSchemaInspector(db);\r\n  }\r\n\r\n  useReturning() {\r\n    return true;\r\n  }\r\n\r\n  async initialize(nativeConnection: unknown) {\r\n    // Don't cast DATE string to Date()\r\n    this.db.connection.client.driver.types.setTypeParser(\r\n      this.db.connection.client.driver.types.builtins.DATE,\r\n      'text',\r\n      (v: unknown) => v\r\n    );\r\n    // Don't parse JSONB automatically\r\n    this.db.connection.client.driver.types.setTypeParser(\r\n      this.db.connection.client.driver.types.builtins.JSONB,\r\n      'text',\r\n      (v: unknown) => v\r\n    );\r\n    this.db.connection.client.driver.types.setTypeParser(\r\n      this.db.connection.client.driver.types.builtins.NUMERIC,\r\n      'text',\r\n      parseFloat\r\n    );\r\n\r\n    // If we're using a schema, set the default path for all table names in queries to use that schema\r\n    // Ideally we would rely on Knex config.searchPath to do this for us\r\n    // However, createConnection must remain synchronous and if the user is using a connection function,\r\n    // we do not know what their schema is until after the connection is resolved\r\n    const schemaName = this.db.getSchemaName();\r\n    if (schemaName) {\r\n      await this.db.connection\r\n        .raw(`SET search_path TO \"${schemaName}\"`)\r\n        .connection(nativeConnection);\r\n    }\r\n  }\r\n\r\n  usesForeignKeys() {\r\n    return true;\r\n  }\r\n\r\n  getSqlType(type: string) {\r\n    switch (type) {\r\n      case 'timestamp': {\r\n        return 'datetime';\r\n      }\r\n      default: {\r\n        return type;\r\n      }\r\n    }\r\n  }\r\n\r\n  transformErrors(error: NodeJS.ErrnoException) {\r\n    switch (error.code) {\r\n      case '23502': {\r\n        throw new errors.NotNullError({\r\n          column: 'column' in error ? `${error.column}` : undefined,\r\n        });\r\n      }\r\n      default: {\r\n        super.transformErrors(error);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import type { Column, ForeignKey, Index, Schema } from '../../schema/types';\r\nimport type { SchemaInspector } from '../dialect';\r\nimport type { Database } from '../..';\r\n\r\ninterface RawTable {\r\n  table_name: string;\r\n}\r\n\r\ninterface RawColumn {\r\n  data_type: string;\r\n  column_name: string;\r\n  character_maximum_length: number;\r\n  column_default: string;\r\n  is_nullable: string;\r\n  column_type: string;\r\n  column_key: string;\r\n}\r\n\r\ninterface RawIndex {\r\n  Key_name: string;\r\n  Column_name: string;\r\n  Non_unique: boolean | string;\r\n}\r\n\r\ninterface RawForeignKey {\r\n  constraint_name: string;\r\n}\r\n\r\nconst SQL_QUERIES = {\r\n  TABLE_LIST: /* sql */ `\r\n    SELECT\r\n      t.table_name as table_name\r\n    FROM information_schema.tables t\r\n    WHERE table_type = 'BASE TABLE'\r\n    AND table_schema = schema();\r\n  `,\r\n  LIST_COLUMNS: /* sql */ `\r\n    SELECT\r\n      c.data_type as data_type,\r\n      c.column_name as column_name,\r\n      c.character_maximum_length as character_maximum_length,\r\n      c.column_default as column_default,\r\n      c.is_nullable as is_nullable,\r\n      c.column_type as column_type,\r\n      c.column_key as column_key\r\n    FROM information_schema.columns c\r\n    WHERE table_schema = database()\r\n    AND table_name = ?;\r\n  `,\r\n  INDEX_LIST: /* sql */ `\r\n    show index from ??;\r\n  `,\r\n  FOREIGN_KEY_LIST: /* sql */ `\r\n    SELECT\r\n      tc.constraint_name as constraint_name\r\n    FROM information_schema.table_constraints tc\r\n    WHERE tc.constraint_type = 'FOREIGN KEY'\r\n    AND tc.table_schema = database()\r\n    AND tc.table_name = ?;\r\n  `,\r\n  FOREIGN_KEY_REFERENCES: /* sql */ `\r\n    SELECT\r\n      kcu.constraint_name as constraint_name,\r\n      kcu.column_name as column_name,\r\n      kcu.referenced_table_name as referenced_table_name,\r\n      kcu.referenced_column_name as referenced_column_name\r\n    FROM information_schema.key_column_usage kcu\r\n    WHERE kcu.constraint_name in (?)\r\n    AND kcu.table_schema = database()\r\n    AND kcu.table_name = ?;\r\n  `,\r\n  FOREIGN_KEY_REFERENTIALS_CONSTRAINTS: /* sql */ `\r\n    SELECT\r\n      rc.constraint_name as constraint_name,\r\n      rc.update_rule as on_update,\r\n      rc.delete_rule as on_delete\r\n    FROM information_schema.referential_constraints AS rc\r\n    WHERE rc.constraint_name in (?)\r\n    AND rc.constraint_schema = database()\r\n    AND rc.table_name = ?;\r\n  `,\r\n};\r\n\r\nconst toStrapiType = (column: RawColumn) => {\r\n  const rootType = column.data_type.toLowerCase().match(/[^(), ]+/)?.[0];\r\n\r\n  switch (rootType) {\r\n    case 'int': {\r\n      if (column.column_key === 'PRI') {\r\n        return { type: 'increments', args: [{ primary: true, primaryKey: true }], unsigned: false };\r\n      }\r\n\r\n      return { type: 'integer' };\r\n    }\r\n    case 'decimal': {\r\n      return { type: 'decimal', args: [10, 2] };\r\n    }\r\n    case 'double': {\r\n      return { type: 'double' };\r\n    }\r\n    case 'bigint': {\r\n      return { type: 'bigInteger' };\r\n    }\r\n    case 'enum': {\r\n      return { type: 'string' };\r\n    }\r\n    case 'tinyint': {\r\n      return { type: 'boolean' };\r\n    }\r\n    case 'longtext': {\r\n      return { type: 'text', args: ['longtext'] };\r\n    }\r\n    case 'varchar': {\r\n      return { type: 'string', args: [column.character_maximum_length] };\r\n    }\r\n    case 'datetime': {\r\n      return { type: 'datetime', args: [{ useTz: false, precision: 6 }] };\r\n    }\r\n    case 'date': {\r\n      return { type: 'date' };\r\n    }\r\n    case 'time': {\r\n      return { type: 'time', args: [{ precision: 3 }] };\r\n    }\r\n    case 'timestamp': {\r\n      return { type: 'timestamp', args: [{ useTz: false, precision: 6 }] };\r\n    }\r\n    case 'json': {\r\n      return { type: 'jsonb' };\r\n    }\r\n    default: {\r\n      return { type: 'specificType', args: [column.data_type] };\r\n    }\r\n  }\r\n};\r\n\r\nexport default class MysqlSchemaInspector implements SchemaInspector {\r\n  db: Database;\r\n\r\n  constructor(db: Database) {\r\n    this.db = db;\r\n  }\r\n\r\n  async getSchema() {\r\n    const schema: Schema = { tables: [] };\r\n\r\n    const tables = await this.getTables();\r\n\r\n    schema.tables = await Promise.all(\r\n      tables.map(async (tableName) => {\r\n        const columns = await this.getColumns(tableName);\r\n        const indexes = await this.getIndexes(tableName);\r\n        const foreignKeys = await this.getForeignKeys(tableName);\r\n\r\n        return {\r\n          name: tableName,\r\n          columns,\r\n          indexes,\r\n          foreignKeys,\r\n        };\r\n      })\r\n    );\r\n\r\n    return schema;\r\n  }\r\n\r\n  async getTables(): Promise<string[]> {\r\n    const [rows] = await this.db.connection.raw<[RawTable[]]>(SQL_QUERIES.TABLE_LIST);\r\n\r\n    return rows.map((row) => row.table_name);\r\n  }\r\n\r\n  async getColumns(tableName: string): Promise<Column[]> {\r\n    const [rows] = await this.db.connection.raw<[RawColumn[]]>(SQL_QUERIES.LIST_COLUMNS, [\r\n      tableName,\r\n    ]);\r\n\r\n    return rows.map((row) => {\r\n      const { type, args = [], ...rest } = toStrapiType(row);\r\n\r\n      return {\r\n        type,\r\n        args,\r\n        defaultTo: row.column_default,\r\n        name: row.column_name,\r\n        notNullable: row.is_nullable === 'NO',\r\n        unsigned: row.column_type.endsWith(' unsigned'),\r\n        ...rest,\r\n      };\r\n    });\r\n  }\r\n\r\n  async getIndexes(tableName: string): Promise<Index[]> {\r\n    const [rows] = await this.db.connection.raw<[RawIndex[]]>(SQL_QUERIES.INDEX_LIST, [tableName]);\r\n\r\n    const ret: Record<RawIndex['Key_name'], Index> = {};\r\n\r\n    for (const index of rows) {\r\n      if (index.Column_name === 'id') {\r\n        continue;\r\n      }\r\n\r\n      if (!ret[index.Key_name]) {\r\n        const indexInfo: Index = {\r\n          columns: [index.Column_name],\r\n          name: index.Key_name,\r\n        };\r\n        if (!index.Non_unique || index.Non_unique === '0') {\r\n          indexInfo.type = 'unique';\r\n        }\r\n\r\n        ret[index.Key_name] = indexInfo;\r\n      } else {\r\n        ret[index.Key_name].columns.push(index.Column_name);\r\n      }\r\n    }\r\n\r\n    return Object.values(ret);\r\n  }\r\n\r\n  async getForeignKeys(tableName: string): Promise<ForeignKey[]> {\r\n    const [rows] = await this.db.connection.raw<[RawForeignKey[]]>(SQL_QUERIES.FOREIGN_KEY_LIST, [\r\n      tableName,\r\n    ]);\r\n\r\n    const ret: Record<RawForeignKey['constraint_name'], ForeignKey> = {};\r\n\r\n    for (const fk of rows) {\r\n      ret[fk.constraint_name] = {\r\n        name: fk.constraint_name,\r\n        columns: [],\r\n        referencedColumns: [],\r\n        referencedTable: null,\r\n        onUpdate: null,\r\n        onDelete: null,\r\n      } as unknown as ForeignKey;\r\n    }\r\n\r\n    const contraintNames = Object.keys(ret);\r\n\r\n    if (contraintNames.length > 0) {\r\n      const [fkReferences] = await this.db.connection.raw(SQL_QUERIES.FOREIGN_KEY_REFERENCES, [\r\n        contraintNames,\r\n        tableName,\r\n      ]);\r\n\r\n      for (const fkReference of fkReferences) {\r\n        ret[fkReference.constraint_name].referencedTable = fkReference.referenced_table_name;\r\n        ret[fkReference.constraint_name].columns.push(fkReference.column_name);\r\n        ret[fkReference.constraint_name].referencedColumns.push(fkReference.referenced_column_name);\r\n      }\r\n\r\n      const [fkReferentialConstraints] = await this.db.connection.raw(\r\n        SQL_QUERIES.FOREIGN_KEY_REFERENTIALS_CONSTRAINTS,\r\n        [contraintNames, tableName]\r\n      );\r\n\r\n      for (const fkReferentialConstraint of fkReferentialConstraints) {\r\n        ret[fkReferentialConstraint.constraint_name].onUpdate =\r\n          fkReferentialConstraint.on_update.toUpperCase();\r\n        ret[fkReferentialConstraint.constraint_name].onDelete =\r\n          fkReferentialConstraint.on_delete.toUpperCase();\r\n      }\r\n    }\r\n\r\n    return Object.values(ret);\r\n  }\r\n}\r\n","export const MYSQL = 'MYSQL';\r\nexport const MARIADB = 'MARIADB';\r\n","import { MARIADB, MYSQL } from './constants';\r\nimport type { Database } from '../..';\r\n\r\nexport interface Information {\r\n  database: typeof MARIADB | typeof MYSQL | null;\r\n  version: string | null;\r\n}\r\n\r\nconst SQL_QUERIES = {\r\n  VERSION: `SELECT version() as version`,\r\n};\r\n\r\nexport default class MysqlDatabaseInspector {\r\n  db: Database;\r\n\r\n  constructor(db: Database) {\r\n    this.db = db;\r\n  }\r\n\r\n  async getInformation(nativeConnection?: unknown): Promise<Information> {\r\n    let database: Information['database'];\r\n    let versionNumber: Information['version'];\r\n    try {\r\n      const [results] = await this.db.connection\r\n        .raw(SQL_QUERIES.VERSION)\r\n        .connection(nativeConnection);\r\n      const versionSplit = results[0].version.split('-');\r\n      const databaseName = versionSplit[1];\r\n      versionNumber = versionSplit[0];\r\n      database = databaseName && databaseName.toLowerCase() === 'mariadb' ? MARIADB : MYSQL;\r\n    } catch (e) {\r\n      return {\r\n        database: null,\r\n        version: null,\r\n      };\r\n    }\r\n\r\n    return {\r\n      database,\r\n      version: versionNumber,\r\n    };\r\n  }\r\n}\r\n","import type { Knex } from 'knex';\r\n\r\nimport Dialect from '../dialect';\r\nimport MysqlSchemaInspector from './schema-inspector';\r\nimport MysqlDatabaseInspector from './database-inspector';\r\nimport type { Database } from '../..';\r\n\r\nimport type { Information } from './database-inspector';\r\n\r\nexport default class MysqlDialect extends Dialect {\r\n  schemaInspector: MysqlSchemaInspector;\r\n\r\n  databaseInspector: MysqlDatabaseInspector;\r\n\r\n  info: Information | null = null;\r\n\r\n  constructor(db: Database) {\r\n    super(db, 'mysql');\r\n\r\n    this.schemaInspector = new MysqlSchemaInspector(db);\r\n    this.databaseInspector = new MysqlDatabaseInspector(db);\r\n  }\r\n\r\n  configure() {\r\n    const connection = this.db.config.connection.connection as Knex.MySqlConnectionConfig;\r\n\r\n    connection.supportBigNumbers = true;\r\n    // Only allow bigNumberStrings option set to be true if no connection option passed\r\n    // Otherwise bigNumberStrings option should be allowed to used from DB config\r\n    if (connection.bigNumberStrings === undefined) {\r\n      connection.bigNumberStrings = true;\r\n    }\r\n    connection.typeCast = (\r\n      field: { type: string; string: () => string; length: number },\r\n      next: () => void\r\n    ) => {\r\n      if (field.type === 'DECIMAL' || field.type === 'NEWDECIMAL') {\r\n        const value = field.string();\r\n        return value === null ? null : Number(value);\r\n      }\r\n\r\n      if (field.type === 'TINY' && field.length === 1) {\r\n        const value = field.string();\r\n        return value ? value === '1' : null;\r\n      }\r\n\r\n      if (field.type === 'DATE') {\r\n        return field.string();\r\n      }\r\n\r\n      return next();\r\n    };\r\n  }\r\n\r\n  async initialize(nativeConnection: unknown) {\r\n    try {\r\n      await this.db.connection\r\n        .raw(`set session sql_require_primary_key = 0;`)\r\n        .connection(nativeConnection);\r\n    } catch (err) {\r\n      // Ignore error due to lack of session permissions\r\n    }\r\n\r\n    // We only need to get info on the first connection in the pool\r\n    /**\r\n     * Note: There is a race condition here where if two connections are opened at the same time, both will retrieve\r\n     * db info, but it doesn't cause issues, it's just one wasted query one time, so we can safely leave it to avoid\r\n     * adding extra complexity\r\n     * */\r\n    if (!this.info) {\r\n      this.info = await this.databaseInspector.getInformation(nativeConnection);\r\n    }\r\n  }\r\n\r\n  async startSchemaUpdate() {\r\n    try {\r\n      await this.db.connection.raw(`set foreign_key_checks = 0;`);\r\n      await this.db.connection.raw(`set session sql_require_primary_key = 0;`);\r\n    } catch (err) {\r\n      // Ignore error due to lack of session permissions\r\n    }\r\n  }\r\n\r\n  async endSchemaUpdate() {\r\n    await this.db.connection.raw(`set foreign_key_checks = 1;`);\r\n  }\r\n\r\n  supportsUnsigned() {\r\n    return true;\r\n  }\r\n\r\n  usesForeignKeys() {\r\n    return true;\r\n  }\r\n\r\n  transformErrors(error: Error) {\r\n    super.transformErrors(error);\r\n  }\r\n}\r\n","import type { Database } from '../..';\r\nimport type { Schema, Column, Index, ForeignKey } from '../../schema/types';\r\nimport type { SchemaInspector } from '../dialect';\r\n\r\nconst SQL_QUERIES = {\r\n  TABLE_LIST: `select name from sqlite_master where type = 'table' and name NOT LIKE 'sqlite%'`,\r\n  TABLE_INFO: `pragma table_info(??)`,\r\n  INDEX_LIST: 'pragma index_list(??)',\r\n  INDEX_INFO: 'pragma index_info(??)',\r\n  FOREIGN_KEY_LIST: 'pragma foreign_key_list(??)',\r\n};\r\n\r\ninterface RawTable {\r\n  name: string;\r\n}\r\ninterface RawColumn {\r\n  type: string;\r\n  args?: unknown[];\r\n  name: string;\r\n  defaultTo?: unknown;\r\n  notNullable?: boolean;\r\n  unsigned?: boolean;\r\n  unique?: boolean;\r\n  primary?: boolean;\r\n  pk?: boolean;\r\n  foreign?: {\r\n    table: string;\r\n    column: string;\r\n    onUpdate: string;\r\n    onDelete: string;\r\n  };\r\n  data_type?: string;\r\n  dflt_value?: unknown;\r\n  notnull?: boolean;\r\n}\r\n\r\ninterface RawIndex {\r\n  name: string;\r\n  unique: boolean;\r\n}\r\n\r\ninterface RawIndexInfo {\r\n  name: string;\r\n}\r\n\r\ninterface RawForeignKey {\r\n  id: number;\r\n  seq: number;\r\n  table: string;\r\n  from: string;\r\n  to: string;\r\n  on_update: string;\r\n  on_delete: string;\r\n}\r\n\r\nconst toStrapiType = (column: RawColumn) => {\r\n  const { type } = column;\r\n\r\n  const rootType = type.toLowerCase().match(/[^(), ]+/)?.[0];\r\n\r\n  switch (rootType) {\r\n    case 'integer': {\r\n      if (column.pk) {\r\n        return { type: 'increments', args: [{ primary: true, primaryKey: true }] };\r\n      }\r\n\r\n      return { type: 'integer' };\r\n    }\r\n    case 'float': {\r\n      return { type: 'float', args: [10, 2] };\r\n    }\r\n    case 'bigint': {\r\n      return { type: 'bigInteger' };\r\n    }\r\n    case 'varchar': {\r\n      const length = type.slice(8, type.length - 1);\r\n\r\n      return { type: 'string', args: [Number(length)] };\r\n    }\r\n    case 'text': {\r\n      return { type: 'text', args: ['longtext'] };\r\n    }\r\n    case 'json': {\r\n      return { type: 'jsonb' };\r\n    }\r\n    case 'boolean': {\r\n      return { type: 'boolean' };\r\n    }\r\n    case 'datetime': {\r\n      return { type: 'datetime', args: [{ useTz: false, precision: 6 }] };\r\n    }\r\n    case 'date': {\r\n      return { type: 'date' };\r\n    }\r\n    case 'time': {\r\n      return { type: 'time', args: [{ precision: 3 }] };\r\n    }\r\n    default: {\r\n      return { type: 'specificType', args: [column.data_type] };\r\n    }\r\n  }\r\n};\r\n\r\nexport default class SqliteSchemaInspector implements SchemaInspector {\r\n  db: Database;\r\n\r\n  constructor(db: Database) {\r\n    this.db = db;\r\n  }\r\n\r\n  async getSchema() {\r\n    const schema: Schema = { tables: [] };\r\n    const tables = await this.getTables();\r\n\r\n    for (const tableName of tables) {\r\n      const columns = await this.getColumns(tableName);\r\n      const indexes = await this.getIndexes(tableName);\r\n      const foreignKeys = await this.getForeignKeys(tableName);\r\n\r\n      schema.tables.push({\r\n        name: tableName,\r\n        columns,\r\n        indexes,\r\n        foreignKeys,\r\n      });\r\n    }\r\n\r\n    return schema;\r\n  }\r\n\r\n  async getTables(): Promise<string[]> {\r\n    const rows = await this.db.connection.raw<RawTable[]>(SQL_QUERIES.TABLE_LIST);\r\n\r\n    return rows.map((row) => row.name);\r\n  }\r\n\r\n  async getColumns(tableName: string): Promise<Column[]> {\r\n    const rows = await this.db.connection.raw<RawColumn[]>(SQL_QUERIES.TABLE_INFO, [tableName]);\r\n\r\n    return rows.map((row) => {\r\n      const { type, args = [], ...rest } = toStrapiType(row);\r\n\r\n      return {\r\n        type,\r\n        args,\r\n        name: row.name,\r\n        defaultTo: row.dflt_value,\r\n        notNullable: row.notnull !== null ? Boolean(row.notnull) : null,\r\n        unsigned: false,\r\n        ...rest,\r\n      };\r\n    });\r\n  }\r\n\r\n  async getIndexes(tableName: string): Promise<Index[]> {\r\n    const indexes = await this.db.connection.raw<RawIndex[]>(SQL_QUERIES.INDEX_LIST, [tableName]);\r\n\r\n    const ret: Index[] = [];\r\n\r\n    for (const index of indexes.filter((index) => !index.name.startsWith('sqlite_'))) {\r\n      const res = await this.db.connection.raw<RawIndexInfo[]>(SQL_QUERIES.INDEX_INFO, [\r\n        index.name,\r\n      ]);\r\n\r\n      const indexInfo: Index = {\r\n        columns: res.map((row) => row.name),\r\n        name: index.name,\r\n      };\r\n\r\n      if (index.unique) {\r\n        indexInfo.type = 'unique';\r\n      }\r\n\r\n      ret.push(indexInfo);\r\n    }\r\n\r\n    return ret;\r\n  }\r\n\r\n  async getForeignKeys(tableName: string): Promise<ForeignKey[]> {\r\n    const fks = await this.db.connection.raw<RawForeignKey[]>(SQL_QUERIES.FOREIGN_KEY_LIST, [\r\n      tableName,\r\n    ]);\r\n\r\n    const ret: Record<RawForeignKey['id'], ForeignKey> = {};\r\n\r\n    for (const fk of fks) {\r\n      if (!ret[fk.id]) {\r\n        ret[fk.id] = {\r\n          // TODO: name, //  find name\r\n          name: '',\r\n          columns: [fk.from],\r\n          referencedColumns: [fk.to],\r\n          referencedTable: fk.table,\r\n          onUpdate: fk.on_update.toUpperCase(),\r\n          onDelete: fk.on_delete.toUpperCase(),\r\n        };\r\n      } else {\r\n        ret[fk.id].columns.push(fk.from);\r\n        ret[fk.id].referencedColumns.push(fk.to);\r\n      }\r\n    }\r\n\r\n    return Object.values(ret);\r\n  }\r\n}\r\n","import path from 'path';\r\nimport fse from 'fs-extra';\r\nimport type { Knex } from 'knex';\r\n\r\nimport * as errors from '../../errors';\r\nimport Dialect from '../dialect';\r\nimport SqliteSchemaInspector from './schema-inspector';\r\nimport type { Database } from '../..';\r\n\r\nconst UNSUPPORTED_OPERATORS = ['$jsonSupersetOf'];\r\n\r\nexport default class SqliteDialect extends Dialect {\r\n  schemaInspector: SqliteSchemaInspector;\r\n\r\n  constructor(db: Database) {\r\n    super(db, 'sqlite');\r\n\r\n    this.schemaInspector = new SqliteSchemaInspector(db);\r\n  }\r\n\r\n  configure(conn?: Knex.Sqlite3ConnectionConfig) {\r\n    const connection =\r\n      conn || (this.db.config.connection.connection as Knex.Sqlite3ConnectionConfig);\r\n    if (typeof connection !== 'string') {\r\n      connection.filename = path.resolve(connection.filename);\r\n    }\r\n\r\n    const dbDir = path.dirname(connection.filename);\r\n\r\n    fse.ensureDirSync(dbDir);\r\n  }\r\n\r\n  useReturning() {\r\n    return true;\r\n  }\r\n\r\n  async initialize(nativeConnection: unknown) {\r\n    await this.db.connection.raw('pragma foreign_keys = on').connection(nativeConnection);\r\n  }\r\n\r\n  canAlterConstraints() {\r\n    return false;\r\n  }\r\n\r\n  getSqlType(type: string) {\r\n    switch (type) {\r\n      case 'enum': {\r\n        return 'text';\r\n      }\r\n      case 'double':\r\n      case 'decimal': {\r\n        return 'float';\r\n      }\r\n      case 'timestamp': {\r\n        return 'datetime';\r\n      }\r\n      default: {\r\n        return type;\r\n      }\r\n    }\r\n  }\r\n\r\n  supportsOperator(operator: string) {\r\n    return !UNSUPPORTED_OPERATORS.includes(operator);\r\n  }\r\n\r\n  async startSchemaUpdate() {\r\n    await this.db.connection.raw(`pragma foreign_keys = off`);\r\n  }\r\n\r\n  async endSchemaUpdate() {\r\n    await this.db.connection.raw(`pragma foreign_keys = on`);\r\n  }\r\n\r\n  transformErrors(error: NodeJS.ErrnoException) {\r\n    switch (error.errno) {\r\n      case 19: {\r\n        throw new errors.NotNullError(); // TODO: extract column name\r\n      }\r\n      default: {\r\n        super.transformErrors(error);\r\n      }\r\n    }\r\n  }\r\n\r\n  canAddIncrements() {\r\n    return false;\r\n  }\r\n}\r\n","import type { Database } from '..';\r\nimport Dialect from './dialect';\r\nimport PostgresClass from './postgresql';\r\nimport MysqlClass from './mysql';\r\nimport SqliteClass from './sqlite';\r\n\r\n/**\r\n * Require our dialect-specific code\r\n */\r\nconst getDialectClass = (client: string): typeof Dialect => {\r\n  switch (client) {\r\n    case 'postgres':\r\n      return PostgresClass;\r\n    case 'mysql':\r\n      return MysqlClass;\r\n    case 'sqlite':\r\n      return SqliteClass;\r\n    default:\r\n      throw new Error(`Unknown dialect ${client}`);\r\n  }\r\n};\r\n\r\n/**\r\n * Get the dialect of a database client\r\n */\r\nconst getDialectName = (client: unknown) => {\r\n  switch (client) {\r\n    case 'postgres':\r\n      return 'postgres';\r\n    case 'mysql':\r\n      return 'mysql';\r\n    case 'sqlite':\r\n      return 'sqlite';\r\n    default:\r\n      throw new Error(`Unknown dialect ${client}`);\r\n  }\r\n};\r\n\r\nconst getDialect = (db: Database) => {\r\n  const { client } = db.config.connection;\r\n  const dialectName = getDialectName(client);\r\n\r\n  const constructor = getDialectClass(dialectName);\r\n  const dialect = new constructor(db, dialectName);\r\n\r\n  return dialect;\r\n};\r\n\r\nexport { Dialect, getDialect };\r\n","import { isNil, prop, omit, castArray } from 'lodash/fp';\r\nimport createDebug from 'debug';\r\n\r\nimport type { Knex } from 'knex';\r\nimport type { Database } from '..';\r\nimport type { Schema, Table, SchemaDiff, TableDiff, ForeignKey, Index, Column } from './types';\r\n\r\nconst debug = createDebug('strapi::database');\r\n\r\nexport default (db: Database) => {\r\n  const helpers = createHelpers(db);\r\n\r\n  return {\r\n    /**\r\n     * Returns a knex schema builder instance\r\n     * @param {string} table - table name\r\n     */\r\n    getSchemaBuilder(trx: Knex.Transaction) {\r\n      return db.getSchemaConnection(trx);\r\n    },\r\n\r\n    /**\r\n     * Creates schema in DB\r\n     */\r\n    async createSchema(schema: Schema) {\r\n      await db.connection.transaction(async (trx) => {\r\n        await this.createTables(schema.tables, trx);\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Creates a list of tables in a schema\r\n     * @param {KnexInstance} trx\r\n     * @param {Table[]} tables\r\n     */\r\n    async createTables(tables: Table[], trx: Knex.Transaction) {\r\n      for (const table of tables) {\r\n        debug(`Creating table: ${table.name}`);\r\n        const schemaBuilder = this.getSchemaBuilder(trx);\r\n        await helpers.createTable(schemaBuilder, table);\r\n      }\r\n\r\n      // create FKs once all the tables exist\r\n      for (const table of tables) {\r\n        debug(`Creating table foreign keys: ${table.name}`);\r\n        const schemaBuilder = this.getSchemaBuilder(trx);\r\n        await helpers.createTableForeignKeys(schemaBuilder, table);\r\n      }\r\n    },\r\n    /**\r\n     * Drops schema from DB\r\n     */\r\n    async dropSchema(schema: Schema, { dropDatabase = false } = {}) {\r\n      if (dropDatabase) {\r\n        // TODO: drop database & return as it will drop everything\r\n        return;\r\n      }\r\n\r\n      await db.connection.transaction(async (trx) => {\r\n        for (const table of schema.tables.reverse()) {\r\n          const schemaBuilder = this.getSchemaBuilder(trx);\r\n          await helpers.dropTable(schemaBuilder, table);\r\n        }\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Applies a schema diff update in the DB\r\n     * @param {*} schemaDiff\r\n     */\r\n    // TODO: implement force option to disable removal in DB\r\n    async updateSchema(schemaDiff: SchemaDiff['diff']) {\r\n      const forceMigration = db.config.settings?.forceMigration;\r\n\r\n      await db.dialect.startSchemaUpdate();\r\n      await db.connection.transaction(async (trx) => {\r\n        await this.createTables(schemaDiff.tables.added, trx);\r\n\r\n        if (forceMigration) {\r\n          // drop all delete table foreign keys then delete the tables\r\n          for (const table of schemaDiff.tables.removed) {\r\n            debug(`Removing table foreign keys: ${table.name}`);\r\n\r\n            const schemaBuilder = this.getSchemaBuilder(trx);\r\n            await helpers.dropTableForeignKeys(schemaBuilder, table);\r\n          }\r\n\r\n          for (const table of schemaDiff.tables.removed) {\r\n            debug(`Removing table: ${table.name}`);\r\n\r\n            const schemaBuilder = this.getSchemaBuilder(trx);\r\n            await helpers.dropTable(schemaBuilder, table);\r\n          }\r\n        }\r\n\r\n        for (const table of schemaDiff.tables.updated) {\r\n          debug(`Updating table: ${table.name}`);\r\n          // alter table\r\n          const schemaBuilder = this.getSchemaBuilder(trx);\r\n\r\n          await helpers.alterTable(schemaBuilder, table);\r\n        }\r\n      });\r\n\r\n      await db.dialect.endSchemaUpdate();\r\n    },\r\n  };\r\n};\r\n\r\nconst createHelpers = (db: Database) => {\r\n  /**\r\n   *  Creates a foreign key on a table\r\n   */\r\n  const createForeignKey = (tableBuilder: Knex.TableBuilder, foreignKey: ForeignKey) => {\r\n    const { name, columns, referencedColumns, referencedTable, onDelete, onUpdate } = foreignKey;\r\n\r\n    const constraint = tableBuilder\r\n      .foreign(columns, name)\r\n      .references(referencedColumns)\r\n      .inTable(db.getSchemaName() ? `${db.getSchemaName()}.${referencedTable}` : referencedTable);\r\n\r\n    if (onDelete) {\r\n      constraint.onDelete(onDelete);\r\n    }\r\n\r\n    if (onUpdate) {\r\n      constraint.onUpdate(onUpdate);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Drops a foreign key from a table\r\n   */\r\n  const dropForeignKey = (tableBuilder: Knex.TableBuilder, foreignKey: ForeignKey) => {\r\n    const { name, columns } = foreignKey;\r\n\r\n    tableBuilder.dropForeign(columns, name);\r\n  };\r\n\r\n  /**\r\n   * Creates an index on a table\r\n   */\r\n  const createIndex = (tableBuilder: Knex.TableBuilder, index: Index) => {\r\n    const { type, columns, name } = index;\r\n\r\n    switch (type) {\r\n      case 'primary': {\r\n        return tableBuilder.primary(columns, name);\r\n      }\r\n      case 'unique': {\r\n        return tableBuilder.unique(columns, name);\r\n      }\r\n      default: {\r\n        return tableBuilder.index(columns, name, type);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Drops an index from table\r\n   * @param {Knex.TableBuilder} tableBuilder\r\n   * @param {Index} index\r\n   */\r\n  const dropIndex = (tableBuilder: Knex.TableBuilder, index: Index) => {\r\n    if (!db.config.settings?.forceMigration) {\r\n      return;\r\n    }\r\n\r\n    const { type, columns, name } = index;\r\n\r\n    switch (type) {\r\n      case 'primary': {\r\n        return tableBuilder.dropPrimary(name);\r\n      }\r\n      case 'unique': {\r\n        return tableBuilder.dropUnique(columns, name);\r\n      }\r\n      default: {\r\n        return tableBuilder.dropIndex(columns, name);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Creates a column in a table\r\n   */\r\n  const createColumn = (tableBuilder: Knex.TableBuilder, column: Column) => {\r\n    const { type, name, args = [], defaultTo, unsigned, notNullable } = column;\r\n\r\n    const col = (tableBuilder[type as keyof Knex.TableBuilder] as any)(name, ...args);\r\n\r\n    if (unsigned === true) {\r\n      col.unsigned();\r\n    }\r\n\r\n    if (!isNil(defaultTo)) {\r\n      const [value, opts] = castArray(defaultTo);\r\n\r\n      if (prop('isRaw', opts)) {\r\n        col.defaultTo(db.connection.raw(value), omit('isRaw', opts));\r\n      } else {\r\n        col.defaultTo(value, opts);\r\n      }\r\n    }\r\n\r\n    if (notNullable === true) {\r\n      col.notNullable();\r\n    } else {\r\n      col.nullable();\r\n    }\r\n\r\n    return col;\r\n  };\r\n\r\n  /**\r\n   * Drops a column from a table\r\n   */\r\n  const dropColumn = (tableBuilder: Knex.TableBuilder, column: Column) => {\r\n    if (!db.config.settings?.forceMigration) {\r\n      return;\r\n    }\r\n\r\n    return tableBuilder.dropColumn(column.name);\r\n  };\r\n\r\n  /**\r\n   * Creates a table in a database\r\n   */\r\n  const createTable = async (schemaBuilder: Knex.SchemaBuilder, table: Table) => {\r\n    await schemaBuilder.createTable(table.name, (tableBuilder) => {\r\n      // columns\r\n      (table.columns || []).forEach((column) => createColumn(tableBuilder, column));\r\n\r\n      // indexes\r\n      (table.indexes || []).forEach((index) => createIndex(tableBuilder, index));\r\n\r\n      // foreign keys\r\n\r\n      if (!db.dialect.canAlterConstraints()) {\r\n        (table.foreignKeys || []).forEach((foreignKey) =>\r\n          createForeignKey(tableBuilder, foreignKey)\r\n        );\r\n      }\r\n    });\r\n  };\r\n\r\n  const alterTable = async (schemaBuilder: Knex.SchemaBuilder, table: TableDiff['diff']) => {\r\n    await schemaBuilder.alterTable(table.name, (tableBuilder) => {\r\n      // Delete indexes / fks / columns\r\n\r\n      // Drop foreign keys first to avoid foreign key errors in the following steps\r\n      for (const removedForeignKey of table.foreignKeys.removed) {\r\n        debug(`Dropping foreign key ${removedForeignKey.name} on ${table.name}`);\r\n        dropForeignKey(tableBuilder, removedForeignKey);\r\n      }\r\n\r\n      for (const updatedForeignKey of table.foreignKeys.updated) {\r\n        debug(`Dropping updated foreign key ${updatedForeignKey.name} on ${table.name}`);\r\n        dropForeignKey(tableBuilder, updatedForeignKey.object);\r\n      }\r\n\r\n      // for mysql only, dropForeignKey also removes the index, so don't drop it twice\r\n      const isMySQL = db.config.connection.client === 'mysql';\r\n      const ignoreForeignKeyNames = isMySQL\r\n        ? [\r\n            ...table.foreignKeys.removed.map((fk) => fk.name),\r\n            ...table.foreignKeys.updated.map((fk) => fk.name),\r\n          ]\r\n        : [];\r\n\r\n      for (const removedIndex of table.indexes.removed) {\r\n        if (!ignoreForeignKeyNames.includes(removedIndex.name)) {\r\n          debug(`Dropping index ${removedIndex.name} on ${table.name}`);\r\n          dropIndex(tableBuilder, removedIndex);\r\n        }\r\n      }\r\n\r\n      for (const updatedIndex of table.indexes.updated) {\r\n        if (!ignoreForeignKeyNames.includes(updatedIndex.name)) {\r\n          debug(`Dropping updated index ${updatedIndex.name} on ${table.name}`);\r\n          dropIndex(tableBuilder, updatedIndex.object);\r\n        }\r\n      }\r\n\r\n      // We drop columns after indexes to ensure that it doesn't cascade delete any indexes we expect to exist\r\n      for (const removedColumn of table.columns.removed) {\r\n        debug(`Dropping column ${removedColumn.name} on ${table.name}`);\r\n        dropColumn(tableBuilder, removedColumn);\r\n      }\r\n\r\n      // Update existing columns\r\n      for (const updatedColumn of table.columns.updated) {\r\n        debug(`Updating column ${updatedColumn.name} on ${table.name}`);\r\n\r\n        const { object } = updatedColumn;\r\n\r\n        if (object.type === 'increments') {\r\n          createColumn(tableBuilder, { ...object, type: 'integer' }).alter();\r\n        } else {\r\n          createColumn(tableBuilder, object).alter();\r\n        }\r\n      }\r\n\r\n      // Add any new columns\r\n      for (const addedColumn of table.columns.added) {\r\n        debug(`Creating column ${addedColumn.name} on ${table.name}`);\r\n\r\n        if (addedColumn.type === 'increments' && !db.dialect.canAddIncrements()) {\r\n          tableBuilder.integer(addedColumn.name).unsigned();\r\n          tableBuilder.primary([addedColumn.name]);\r\n        } else {\r\n          createColumn(tableBuilder, addedColumn);\r\n        }\r\n      }\r\n\r\n      // once the columns have all been updated, we can create indexes again\r\n      for (const updatedForeignKey of table.foreignKeys.updated) {\r\n        debug(`Recreating updated foreign key ${updatedForeignKey.name} on ${table.name}`);\r\n        createForeignKey(tableBuilder, updatedForeignKey.object);\r\n      }\r\n\r\n      for (const updatedIndex of table.indexes.updated) {\r\n        debug(`Recreating updated index ${updatedIndex.name} on ${table.name}`);\r\n        createIndex(tableBuilder, updatedIndex.object);\r\n      }\r\n\r\n      for (const addedForeignKey of table.foreignKeys.added) {\r\n        debug(`Creating foreign keys ${addedForeignKey.name} on ${table.name}`);\r\n        createForeignKey(tableBuilder, addedForeignKey);\r\n      }\r\n\r\n      for (const addedIndex of table.indexes.added) {\r\n        debug(`Creating index ${addedIndex.name} on ${table.name}`);\r\n        createIndex(tableBuilder, addedIndex);\r\n      }\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Drops a table from a database\r\n   */\r\n  const dropTable = (schemaBuilder: Knex.SchemaBuilder, table: Table) => {\r\n    if (!db.config.settings.forceMigration) {\r\n      return;\r\n    }\r\n\r\n    return schemaBuilder.dropTableIfExists(table.name);\r\n  };\r\n\r\n  /**\r\n   * Creates a table foreign keys constraints\r\n   */\r\n  const createTableForeignKeys = async (schemaBuilder: Knex.SchemaBuilder, table: Table) => {\r\n    // foreign keys\r\n    await schemaBuilder.table(table.name, (tableBuilder) => {\r\n      (table.foreignKeys || []).forEach((foreignKey) => createForeignKey(tableBuilder, foreignKey));\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Drops a table foreign keys constraints\r\n   */\r\n  const dropTableForeignKeys = async (schemaBuilder: Knex.SchemaBuilder, table: Table) => {\r\n    if (!db.config.settings.forceMigration) {\r\n      return;\r\n    }\r\n\r\n    // foreign keys\r\n    await schemaBuilder.table(table.name, (tableBuilder) => {\r\n      (table.foreignKeys || []).forEach((foreignKey) => dropForeignKey(tableBuilder, foreignKey));\r\n    });\r\n  };\r\n\r\n  return {\r\n    createTable,\r\n    alterTable,\r\n    dropTable,\r\n    createTableForeignKeys,\r\n    dropTableForeignKeys,\r\n  };\r\n};\r\n","import _ from 'lodash/fp';\r\nimport type {\r\n  Schema,\r\n  Table,\r\n  SchemaDiff,\r\n  Index,\r\n  ForeignKey,\r\n  Column,\r\n  IndexDiff,\r\n  IndexesDiff,\r\n  ForeignKeyDiff,\r\n  ForeignKeysDiff,\r\n  ColumnDiff,\r\n  TableDiff,\r\n  ColumnsDiff,\r\n} from './types';\r\nimport type { Database } from '..';\r\n\r\ntype PersistedTable = {\r\n  name: string;\r\n  dependsOn?: Array<{ name: string }>;\r\n};\r\n\r\ntype TableDiffContext = {\r\n  previousTable?: Table;\r\n  databaseTable: Table;\r\n  userSchemaTable: Table;\r\n};\r\n\r\ntype SchemaDiffContext = {\r\n  previousSchema?: Schema;\r\n  databaseSchema: Schema;\r\n  userSchema: Schema;\r\n};\r\n\r\n// TODO: get that list dynamically instead\r\nconst RESERVED_TABLE_NAMES = [\r\n  'strapi_migrations',\r\n  'strapi_migrations_internal',\r\n  'strapi_database_schema',\r\n];\r\n\r\nconst statuses = {\r\n  CHANGED: 'CHANGED',\r\n  UNCHANGED: 'UNCHANGED',\r\n} as const;\r\n\r\n// NOTE:We could move the schema to use maps of tables & columns instead of arrays to make it easier to diff\r\n// => this will make the creation a bit more complicated (ordering, Object.values(tables | columns)) -> not a big pbl\r\n\r\nconst helpers = {\r\n  hasTable(schema: Schema, tableName: string) {\r\n    return schema.tables.findIndex((table) => table.name === tableName) !== -1;\r\n  },\r\n  findTable(schema: Schema, tableName: string) {\r\n    return schema.tables.find((table) => table.name === tableName);\r\n  },\r\n  hasColumn(table: Table, columnName: string) {\r\n    return table.columns.findIndex((column) => column.name === columnName) !== -1;\r\n  },\r\n  findColumn(table: Table, columnName: string) {\r\n    return table.columns.find((column) => column.name === columnName);\r\n  },\r\n\r\n  hasIndex(table: Table, columnName: string) {\r\n    return table.indexes.findIndex((column) => column.name === columnName) !== -1;\r\n  },\r\n  findIndex(table: Table, columnName: string) {\r\n    return table.indexes.find((column) => column.name === columnName);\r\n  },\r\n\r\n  hasForeignKey(table: Table, columnName: string) {\r\n    return table.foreignKeys.findIndex((column) => column.name === columnName) !== -1;\r\n  },\r\n  findForeignKey(table: Table, columnName: string) {\r\n    return table.foreignKeys.find((column) => column.name === columnName);\r\n  },\r\n};\r\n\r\nexport default (db: Database) => {\r\n  const hasChangedStatus = (diff: { status: 'CHANGED' | 'UNCHANGED' }) =>\r\n    diff.status === statuses.CHANGED;\r\n\r\n  /**\r\n   * Compares two indexes info\r\n   * @param {Object} oldIndex - index info read from DB\r\n   * @param {Object} index - newly generate index info\r\n   */\r\n  const diffIndexes = (oldIndex: Index, index: Index): IndexDiff => {\r\n    const changes: string[] = [];\r\n\r\n    // use xor to avoid differences in order\r\n    if (_.xor(oldIndex.columns, index.columns).length > 0) {\r\n      changes.push('columns');\r\n    }\r\n\r\n    if (oldIndex.type && index.type && _.toLower(oldIndex.type) !== _.toLower(index.type)) {\r\n      changes.push('type');\r\n    }\r\n\r\n    return {\r\n      status: changes.length > 0 ? statuses.CHANGED : statuses.UNCHANGED,\r\n      diff: {\r\n        name: index.name,\r\n        object: index,\r\n      },\r\n    };\r\n  };\r\n\r\n  /**\r\n   * Compares two foreign keys info\r\n   * @param {Object} oldForeignKey - foreignKey info read from DB\r\n   * @param {Object} foreignKey - newly generate foreignKey info\r\n   */\r\n  const diffForeignKeys = (oldForeignKey: ForeignKey, foreignKey: ForeignKey): ForeignKeyDiff => {\r\n    const changes: string[] = [];\r\n\r\n    if (_.difference(oldForeignKey.columns, foreignKey.columns).length > 0) {\r\n      changes.push('columns');\r\n    }\r\n\r\n    if (_.difference(oldForeignKey.referencedColumns, foreignKey.referencedColumns).length > 0) {\r\n      changes.push('referencedColumns');\r\n    }\r\n\r\n    if (oldForeignKey.referencedTable !== foreignKey.referencedTable) {\r\n      changes.push('referencedTable');\r\n    }\r\n\r\n    if (_.isNil(oldForeignKey.onDelete) || _.toUpper(oldForeignKey.onDelete) === 'NO ACTION') {\r\n      if (\r\n        !_.isNil(foreignKey.onDelete) &&\r\n        _.toUpper(oldForeignKey.onDelete ?? '') !== 'NO ACTION'\r\n      ) {\r\n        changes.push('onDelete');\r\n      }\r\n    } else if (_.toUpper(oldForeignKey.onDelete) !== _.toUpper(foreignKey.onDelete ?? '')) {\r\n      changes.push('onDelete');\r\n    }\r\n\r\n    if (_.isNil(oldForeignKey.onUpdate) || _.toUpper(oldForeignKey.onUpdate) === 'NO ACTION') {\r\n      if (\r\n        !_.isNil(foreignKey.onUpdate) &&\r\n        _.toUpper(oldForeignKey.onUpdate ?? '') !== 'NO ACTION'\r\n      ) {\r\n        changes.push('onUpdate');\r\n      }\r\n    } else if (_.toUpper(oldForeignKey.onUpdate) !== _.toUpper(foreignKey.onUpdate ?? '')) {\r\n      changes.push('onUpdate');\r\n    }\r\n\r\n    return {\r\n      status: changes.length > 0 ? statuses.CHANGED : statuses.UNCHANGED,\r\n      diff: {\r\n        name: foreignKey.name,\r\n        object: foreignKey,\r\n      },\r\n    };\r\n  };\r\n\r\n  const diffDefault = (oldColumn: Column, column: Column) => {\r\n    const oldDefaultTo = oldColumn.defaultTo;\r\n    const { defaultTo } = column;\r\n\r\n    if (oldDefaultTo === null || _.toLower(oldDefaultTo) === 'null') {\r\n      return _.isNil(defaultTo) || _.toLower(defaultTo) === 'null';\r\n    }\r\n\r\n    return (\r\n      _.toLower(oldDefaultTo) === _.toLower(column.defaultTo) ||\r\n      _.toLower(oldDefaultTo) === _.toLower(`'${column.defaultTo}'`)\r\n    );\r\n  };\r\n\r\n  /**\r\n   * Compares two columns info\r\n   * @param {Object} oldColumn - column info read from DB\r\n   * @param {Object} column - newly generate column info\r\n   */\r\n  const diffColumns = (oldColumn: Column, column: Column): ColumnDiff => {\r\n    const changes: string[] = [];\r\n\r\n    const isIgnoredType = ['increments'].includes(column.type);\r\n    const oldType = oldColumn.type;\r\n    const type = db.dialect.getSqlType(column.type);\r\n\r\n    if (oldType !== type && !isIgnoredType) {\r\n      changes.push('type');\r\n    }\r\n\r\n    // NOTE: compare args at some point and split them into specific properties instead\r\n\r\n    if (oldColumn.notNullable !== column.notNullable) {\r\n      changes.push('notNullable');\r\n    }\r\n\r\n    const hasSameDefault = diffDefault(oldColumn, column);\r\n    if (!hasSameDefault) {\r\n      changes.push('defaultTo');\r\n    }\r\n\r\n    if (oldColumn.unsigned !== column.unsigned && db.dialect.supportsUnsigned()) {\r\n      changes.push('unsigned');\r\n    }\r\n\r\n    return {\r\n      status: changes.length > 0 ? statuses.CHANGED : statuses.UNCHANGED,\r\n      diff: {\r\n        name: column.name,\r\n        object: column,\r\n      },\r\n    };\r\n  };\r\n\r\n  const diffTableColumns = (diffCtx: TableDiffContext): ColumnsDiff => {\r\n    const { databaseTable, userSchemaTable, previousTable } = diffCtx;\r\n\r\n    const addedColumns: Column[] = [];\r\n    const updatedColumns: ColumnDiff['diff'][] = [];\r\n    const unchangedColumns: Column[] = [];\r\n    const removedColumns: Column[] = [];\r\n\r\n    for (const userSchemaColumn of userSchemaTable.columns) {\r\n      const databaseColumn = helpers.findColumn(databaseTable, userSchemaColumn.name);\r\n\r\n      if (databaseColumn) {\r\n        const { status, diff } = diffColumns(databaseColumn, userSchemaColumn);\r\n\r\n        if (status === statuses.CHANGED) {\r\n          updatedColumns.push(diff);\r\n        } else {\r\n          unchangedColumns.push(databaseColumn);\r\n        }\r\n      } else {\r\n        addedColumns.push(userSchemaColumn);\r\n      }\r\n    }\r\n\r\n    for (const databaseColumn of databaseTable.columns) {\r\n      if (\r\n        !helpers.hasColumn(userSchemaTable, databaseColumn.name) &&\r\n        previousTable &&\r\n        helpers.hasColumn(previousTable, databaseColumn.name)\r\n      ) {\r\n        removedColumns.push(databaseColumn);\r\n      }\r\n    }\r\n\r\n    const hasChanged = [addedColumns, updatedColumns, removedColumns].some((arr) => arr.length > 0);\r\n\r\n    return {\r\n      status: hasChanged ? statuses.CHANGED : statuses.UNCHANGED,\r\n      diff: {\r\n        added: addedColumns,\r\n        updated: updatedColumns,\r\n        unchanged: unchangedColumns,\r\n        removed: removedColumns,\r\n      },\r\n    };\r\n  };\r\n\r\n  const diffTableIndexes = (diffCtx: TableDiffContext): IndexesDiff => {\r\n    const { databaseTable, userSchemaTable, previousTable } = diffCtx;\r\n\r\n    const addedIndexes: Index[] = [];\r\n    const updatedIndexes: IndexDiff['diff'][] = [];\r\n    const unchangedIndexes: Index[] = [];\r\n    const removedIndexes: Index[] = [];\r\n\r\n    for (const userSchemaIndex of userSchemaTable.indexes) {\r\n      const databaseIndex = helpers.findIndex(databaseTable, userSchemaIndex.name);\r\n      if (databaseIndex) {\r\n        const { status, diff } = diffIndexes(databaseIndex, userSchemaIndex);\r\n\r\n        if (status === statuses.CHANGED) {\r\n          updatedIndexes.push(diff);\r\n        } else {\r\n          unchangedIndexes.push(databaseIndex);\r\n        }\r\n      } else {\r\n        addedIndexes.push(userSchemaIndex);\r\n      }\r\n    }\r\n\r\n    for (const databaseIndex of databaseTable.indexes) {\r\n      if (\r\n        !helpers.hasIndex(userSchemaTable, databaseIndex.name) &&\r\n        previousTable &&\r\n        helpers.hasIndex(previousTable, databaseIndex.name)\r\n      ) {\r\n        removedIndexes.push(databaseIndex);\r\n      }\r\n    }\r\n\r\n    const hasChanged = [addedIndexes, updatedIndexes, removedIndexes].some((arr) => arr.length > 0);\r\n\r\n    return {\r\n      status: hasChanged ? statuses.CHANGED : statuses.UNCHANGED,\r\n      diff: {\r\n        added: addedIndexes,\r\n        updated: updatedIndexes,\r\n        unchanged: unchangedIndexes,\r\n        removed: removedIndexes,\r\n      },\r\n    };\r\n  };\r\n\r\n  const diffTableForeignKeys = (diffCtx: TableDiffContext): ForeignKeysDiff => {\r\n    const { databaseTable, userSchemaTable, previousTable } = diffCtx;\r\n\r\n    const addedForeignKeys: ForeignKey[] = [];\r\n    const updatedForeignKeys: ForeignKeyDiff['diff'][] = [];\r\n    const unchangedForeignKeys: ForeignKey[] = [];\r\n    const removedForeignKeys: ForeignKey[] = [];\r\n\r\n    if (!db.dialect.usesForeignKeys()) {\r\n      return {\r\n        status: statuses.UNCHANGED,\r\n        diff: {\r\n          added: addedForeignKeys,\r\n          updated: updatedForeignKeys,\r\n          unchanged: unchangedForeignKeys,\r\n          removed: removedForeignKeys,\r\n        },\r\n      };\r\n    }\r\n\r\n    for (const userSchemaForeignKeys of userSchemaTable.foreignKeys) {\r\n      const databaseForeignKeys = helpers.findForeignKey(databaseTable, userSchemaForeignKeys.name);\r\n      if (databaseForeignKeys) {\r\n        const { status, diff } = diffForeignKeys(databaseForeignKeys, userSchemaForeignKeys);\r\n\r\n        if (status === statuses.CHANGED) {\r\n          updatedForeignKeys.push(diff);\r\n        } else {\r\n          unchangedForeignKeys.push(databaseForeignKeys);\r\n        }\r\n      } else {\r\n        addedForeignKeys.push(userSchemaForeignKeys);\r\n      }\r\n    }\r\n\r\n    for (const databaseForeignKeys of databaseTable.foreignKeys) {\r\n      if (\r\n        !helpers.hasForeignKey(userSchemaTable, databaseForeignKeys.name) &&\r\n        previousTable &&\r\n        helpers.hasForeignKey(previousTable, databaseForeignKeys.name)\r\n      ) {\r\n        removedForeignKeys.push(databaseForeignKeys);\r\n      }\r\n    }\r\n\r\n    const hasChanged = [addedForeignKeys, updatedForeignKeys, removedForeignKeys].some(\r\n      (arr) => arr.length > 0\r\n    );\r\n\r\n    return {\r\n      status: hasChanged ? statuses.CHANGED : statuses.UNCHANGED,\r\n      diff: {\r\n        added: addedForeignKeys,\r\n        updated: updatedForeignKeys,\r\n        unchanged: unchangedForeignKeys,\r\n        removed: removedForeignKeys,\r\n      },\r\n    };\r\n  };\r\n\r\n  const diffTables = (diffCtx: TableDiffContext): TableDiff => {\r\n    const { databaseTable } = diffCtx;\r\n\r\n    const columnsDiff = diffTableColumns(diffCtx);\r\n    const indexesDiff = diffTableIndexes(diffCtx);\r\n    const foreignKeysDiff = diffTableForeignKeys(diffCtx);\r\n\r\n    const hasChanged = [columnsDiff, indexesDiff, foreignKeysDiff].some(hasChangedStatus);\r\n\r\n    return {\r\n      status: hasChanged ? statuses.CHANGED : statuses.UNCHANGED,\r\n      diff: {\r\n        name: databaseTable.name,\r\n        indexes: indexesDiff.diff,\r\n        foreignKeys: foreignKeysDiff.diff,\r\n        columns: columnsDiff.diff,\r\n      },\r\n    };\r\n  };\r\n\r\n  const diffSchemas = async (schemaDiffCtx: SchemaDiffContext): Promise<SchemaDiff> => {\r\n    const { previousSchema, databaseSchema, userSchema } = schemaDiffCtx;\r\n\r\n    const addedTables: Table[] = [];\r\n    const updatedTables: TableDiff['diff'][] = [];\r\n    const unchangedTables: Table[] = [];\r\n    const removedTables: Table[] = [];\r\n\r\n    // for each table in the user schema, check if it already exists in the database schema\r\n    for (const userSchemaTable of userSchema.tables) {\r\n      const databaseTable = helpers.findTable(databaseSchema, userSchemaTable.name);\r\n      const previousTable =\r\n        previousSchema && helpers.findTable(previousSchema, userSchemaTable.name);\r\n\r\n      if (databaseTable) {\r\n        const { status, diff } = diffTables({\r\n          previousTable,\r\n          databaseTable,\r\n          userSchemaTable,\r\n        });\r\n\r\n        if (status === statuses.CHANGED) {\r\n          updatedTables.push(diff);\r\n        } else {\r\n          unchangedTables.push(databaseTable);\r\n        }\r\n      } else {\r\n        addedTables.push(userSchemaTable);\r\n      }\r\n    }\r\n\r\n    // maintain audit logs table from EE -> CE\r\n    const parsePersistedTable = (persistedTable: string | Table) => {\r\n      if (typeof persistedTable === 'string') {\r\n        return persistedTable;\r\n      }\r\n      return persistedTable.name;\r\n    };\r\n\r\n    const persistedTables = helpers.hasTable(databaseSchema, 'strapi_core_store_settings')\r\n      ? // TODO: replace with low level db query instead\r\n        ((await strapi.store.get({\r\n          type: 'core',\r\n          key: 'persisted_tables',\r\n        })) ?? [])\r\n      : [];\r\n\r\n    const reservedTables = [...RESERVED_TABLE_NAMES, ...persistedTables.map(parsePersistedTable)];\r\n\r\n    // for all tables in the database schema, check if they are not in the user schema\r\n    for (const databaseTable of databaseSchema.tables) {\r\n      const isInUserSchema = helpers.hasTable(userSchema, databaseTable.name);\r\n      const wasTracked = previousSchema && helpers.hasTable(previousSchema, databaseTable.name);\r\n      const isReserved = reservedTables.includes(databaseTable.name);\r\n\r\n      // NOTE: if db table is not in the user schema and is not in the previous stored schema leave it alone. it is a user custom table that we should not touch\r\n      if (!isInUserSchema && !wasTracked) {\r\n        continue;\r\n      }\r\n\r\n      // if a db table is not in the user schema I want to delete it\r\n      if (!isInUserSchema && wasTracked && !isReserved) {\r\n        const dependencies = persistedTables\r\n          .filter((table: PersistedTable) => {\r\n            const dependsOn = table?.dependsOn;\r\n\r\n            if (!_.isArray(dependsOn)) {\r\n              return;\r\n            }\r\n\r\n            return dependsOn.some((table) => table.name === databaseTable.name);\r\n          })\r\n          .map((dependsOnTable: PersistedTable) => {\r\n            return databaseSchema.tables.find(\r\n              (databaseTable) => databaseTable.name === dependsOnTable.name\r\n            );\r\n          })\r\n          // In case the table is not found, filter undefined values\r\n          .filter((table: PersistedTable) => !_.isNil(table));\r\n\r\n        removedTables.push(databaseTable, ...dependencies);\r\n      }\r\n    }\r\n\r\n    const hasChanged = [addedTables, updatedTables, removedTables].some((arr) => arr.length > 0);\r\n\r\n    return {\r\n      status: hasChanged ? statuses.CHANGED : statuses.UNCHANGED,\r\n      diff: {\r\n        tables: {\r\n          added: addedTables,\r\n          updated: updatedTables,\r\n          unchanged: unchangedTables,\r\n          removed: removedTables,\r\n        },\r\n      },\r\n    };\r\n  };\r\n\r\n  return {\r\n    diff: diffSchemas,\r\n  };\r\n};\r\n","import crypto from 'crypto';\r\n\r\nimport type { Database } from '..';\r\nimport type { Schema } from './types';\r\n\r\nconst TABLE_NAME = 'strapi_database_schema';\r\n\r\nexport default (db: Database) => {\r\n  const hasSchemaTable = () => db.getSchemaConnection().hasTable(TABLE_NAME);\r\n\r\n  const createSchemaTable = () => {\r\n    return db.getSchemaConnection().createTable(TABLE_NAME, (t) => {\r\n      t.increments('id');\r\n      t.json('schema');\r\n      t.datetime('time', { useTz: false });\r\n      t.string('hash');\r\n    });\r\n  };\r\n\r\n  const checkTableExists = async () => {\r\n    if (!(await hasSchemaTable())) {\r\n      await createSchemaTable();\r\n    }\r\n  };\r\n\r\n  return {\r\n    async read(): Promise<{\r\n      id: number;\r\n      time: Date;\r\n      hash: string;\r\n      schema: Schema;\r\n    } | null> {\r\n      await checkTableExists();\r\n\r\n      const res = await db\r\n        .getConnection()\r\n        .select('*')\r\n        .from(TABLE_NAME)\r\n        .orderBy('time', 'DESC')\r\n        .first();\r\n\r\n      if (!res) {\r\n        return null;\r\n      }\r\n\r\n      const parsedSchema = typeof res.schema === 'object' ? res.schema : JSON.parse(res.schema);\r\n\r\n      return {\r\n        ...res,\r\n        schema: parsedSchema,\r\n      };\r\n    },\r\n\r\n    hashSchema(schema: Schema) {\r\n      return crypto.createHash('md5').update(JSON.stringify(schema)).digest('hex');\r\n    },\r\n\r\n    async add(schema: Schema) {\r\n      await checkTableExists();\r\n\r\n      // NOTE: we can remove this to add history\r\n      await db.getConnection(TABLE_NAME).delete();\r\n\r\n      const time = new Date();\r\n\r\n      await db\r\n        .getConnection()\r\n        .insert({\r\n          schema: JSON.stringify(schema),\r\n          hash: this.hashSchema(schema),\r\n          time,\r\n        })\r\n        .into(TABLE_NAME);\r\n    },\r\n\r\n    async clear() {\r\n      await checkTableExists();\r\n\r\n      await db.getConnection(TABLE_NAME).truncate();\r\n    },\r\n  };\r\n};\r\n","import type { Attribute, ScalarAttribute, RelationalAttribute } from '../types';\r\n\r\nconst SCALAR_TYPES = [\r\n  'increments',\r\n  'password',\r\n  'email',\r\n  'string',\r\n  'uid',\r\n  'richtext',\r\n  'text',\r\n  'json',\r\n  'enumeration',\r\n  'integer',\r\n  'biginteger',\r\n  'float',\r\n  'decimal',\r\n  'date',\r\n  'time',\r\n  'datetime',\r\n  'timestamp',\r\n  'boolean',\r\n  'blocks',\r\n];\r\n\r\nconst STRING_TYPES = ['string', 'text', 'uid', 'email', 'enumeration', 'richtext'];\r\nconst NUMBER_TYPES = ['biginteger', 'integer', 'decimal', 'float'];\r\n\r\nexport const isString = (type: string) => STRING_TYPES.includes(type);\r\nexport const isNumber = (type: string) => NUMBER_TYPES.includes(type);\r\nexport const isScalar = (type: string) => SCALAR_TYPES.includes(type);\r\nexport const isRelation = (type: string) => type === 'relation';\r\nexport const isScalarAttribute = (attribute: Attribute): attribute is ScalarAttribute =>\r\n  isScalar(attribute.type);\r\nexport const isRelationalAttribute = (attribute: Attribute): attribute is RelationalAttribute =>\r\n  isRelation(attribute.type);\r\n","/**\r\n * @fileoverview This file contains utility functions for shortening identifiers for use in a database schema.\r\n * The functions in this file are used to generate shorter names for database tables and columns\r\n * to avoid breaking the constraints of databases.\r\n *\r\n * IMPORTANT\r\n * Any changes here that result in a different output string from any of the naming methods will\r\n * cause the schema creation to delete data it doesn't recognize because the name\r\n * is different.\r\n *\r\n * If there are any test failures after updating this code, it means there is a breaking change that\r\n * will cause data loss, so beware; do not update the test to match your changes\r\n *\r\n * @internal\r\n */\r\n\r\nimport crypto from 'node:crypto';\r\nimport { isInteger } from 'lodash/fp';\r\n\r\n/**\r\n * Creates a hash of the given data with the specified string length as a string of hex characters\r\n *\r\n * @example\r\n * createHash(\"myData\", 5); // \"03f85\"\r\n * createHash(\"myData\", 2); // \"03\"\r\n * createHash(\"myData\", 1); // \"0\"\r\n *\r\n * @param data - The data to be hashed\r\n * @param len - The length of the hash\r\n * @returns The generated hash\r\n * @throws Error if the length is not a positive integer\r\n * @internal\r\n */\r\nexport function createHash(data: string, len: number): string {\r\n  if (!isInteger(len) || len <= 0) {\r\n    throw new Error(`createHash length must be a positive integer, received ${len}`);\r\n  }\r\n\r\n  const hash = crypto.createHash('shake256', { outputLength: Math.ceil(len / 2) }).update(data);\r\n  return hash.digest('hex').substring(0, len);\r\n}\r\n","/**\r\n * This file contains utility functions for generating names used in the database.\r\n * These names include table names, column names, join table names, index names, and more.\r\n * The generated names can be customized with prefixes, suffixes, and maximum length.\r\n * These utility functions are used throughout the codebase to ensure consistent and standardized naming conventions in the database.\r\n *\r\n * The reason for checking maxLength for suffixes and prefixes and using the long ones from Strapi 4 is so that we always\r\n * have access to the full length names, in particular for migration purposes, but also so that (in theory) the feature\r\n * could be disabled and stay compatible with v4 database structure.\r\n */\r\nimport _, { isInteger, partition, snakeCase, sumBy } from 'lodash/fp';\r\nimport { createHash } from './hash';\r\nimport {\r\n  IdentifiersOptions,\r\n  NameInput,\r\n  NameOptions,\r\n  NameToken,\r\n  NameTokenWithAllocation,\r\n} from './types';\r\n\r\nconst IDENTIFIER_MAX_LENGTH = 55 as const;\r\n\r\nexport class Identifiers {\r\n  ID_COLUMN = 'id' as const;\r\n\r\n  ORDER_COLUMN = 'order' as const;\r\n\r\n  FIELD_COLUMN = 'field' as const;\r\n\r\n  HASH_LENGTH = 5 as const;\r\n\r\n  HASH_SEPARATOR = '' as const; // no separator is needed, we will just attach hash directly to shortened name\r\n\r\n  IDENTIFIER_SEPARATOR = '_' as const;\r\n\r\n  MIN_TOKEN_LENGTH = 3 as const; // the min characters required at the beginning of a name part\r\n\r\n  // Fixed compression map for suffixes and prefixes\r\n  #replacementMap = {\r\n    links: 'lnk',\r\n    order_inv_fk: 'oifk',\r\n    order: 'ord',\r\n    morphs: 'mph',\r\n    index: 'idx',\r\n    inv_fk: 'ifk',\r\n    order_fk: 'ofk',\r\n    id_column_index: 'idix',\r\n    order_index: 'oidx',\r\n    unique: 'uq',\r\n    primary: 'pk',\r\n  };\r\n\r\n  #options: IdentifiersOptions;\r\n\r\n  constructor(options: { maxLength: number }) {\r\n    this.#options = options;\r\n  }\r\n\r\n  get replacementMap() {\r\n    return this.#replacementMap;\r\n  }\r\n\r\n  get options() {\r\n    return this.#options;\r\n  }\r\n\r\n  mapshortNames = (name: string): string | undefined => {\r\n    if (name in this.replacementMap) {\r\n      return (this.replacementMap as any)[name];\r\n    }\r\n    return undefined;\r\n  };\r\n\r\n  // Generic name handler that must be used by all helper functions\r\n  /**\r\n   * TODO: we should be requiring snake_case inputs for all names here, but we\r\n   * aren't and it will require some refactoring to make it work. Currently if\r\n   * we get names 'myModel' and 'my_model' they would be converted to the same\r\n   * final string my_model which generally works but is not entirely safe\r\n   * */\r\n  getName = (names: NameInput, options?: NameOptions) => {\r\n    const tokens: NameToken[] = _.castArray(names).map((name) => {\r\n      return {\r\n        name,\r\n        compressible: true,\r\n      };\r\n    });\r\n\r\n    if (options?.suffix) {\r\n      tokens.push({\r\n        name: options.suffix,\r\n        compressible: false,\r\n        shortName: this.mapshortNames(options.suffix),\r\n      });\r\n    }\r\n\r\n    if (options?.prefix) {\r\n      tokens.unshift({\r\n        name: options.prefix,\r\n        compressible: false,\r\n        shortName: this.mapshortNames(options.prefix),\r\n      });\r\n    }\r\n\r\n    return this.getNameFromTokens(tokens);\r\n  };\r\n\r\n  /**\r\n   * TABLES\r\n   */\r\n\r\n  getTableName = (name: string, options?: NameOptions) => {\r\n    return this.getName(name, options);\r\n  };\r\n\r\n  getJoinTableName = (collectionName: string, attributeName: string, options?: NameOptions) => {\r\n    return this.getName([collectionName, attributeName], {\r\n      suffix: 'links',\r\n      ...options,\r\n    });\r\n  };\r\n\r\n  getMorphTableName = (collectionName: string, attributeName: string, options?: NameOptions) => {\r\n    return this.getName([snakeCase(collectionName), snakeCase(attributeName)], {\r\n      suffix: 'morphs',\r\n      ...options,\r\n    });\r\n  };\r\n\r\n  /**\r\n   * COLUMNS\r\n   */\r\n\r\n  getColumnName = (attributeName: string, options?: NameOptions) => {\r\n    return this.getName(attributeName, options);\r\n  };\r\n\r\n  getJoinColumnAttributeIdName = (attributeName: string, options?: NameOptions) => {\r\n    return this.getName(attributeName, { suffix: 'id', ...options });\r\n  };\r\n\r\n  getInverseJoinColumnAttributeIdName = (attributeName: string, options?: NameOptions) => {\r\n    return this.getName(snakeCase(attributeName), { suffix: 'id', prefix: 'inv', ...options });\r\n  };\r\n\r\n  getOrderColumnName = (singularName: string, options?: NameOptions) => {\r\n    return this.getName(singularName, { suffix: 'order', ...options });\r\n  };\r\n\r\n  getInverseOrderColumnName = (singularName: string, options?: NameOptions) => {\r\n    return this.getName(singularName, {\r\n      suffix: 'order',\r\n      prefix: 'inv',\r\n      ...options,\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Morph Join Tables\r\n   */\r\n  getMorphColumnJoinTableIdName = (singularName: string, options?: NameOptions) => {\r\n    return this.getName(snakeCase(singularName), { suffix: 'id', ...options });\r\n  };\r\n\r\n  getMorphColumnAttributeIdName = (attributeName: string, options?: NameOptions) => {\r\n    return this.getName(snakeCase(attributeName), { suffix: 'id', ...options });\r\n  };\r\n\r\n  getMorphColumnTypeName = (attributeName: string, options?: NameOptions) => {\r\n    return this.getName(snakeCase(attributeName), { suffix: 'type', ...options });\r\n  };\r\n\r\n  /**\r\n   * INDEXES\r\n   * Note that these methods are generally used to reference full table names + attribute(s), which\r\n   * may already be shortened strings rather than individual parts.\r\n   * That is fine and expected to compress the previously incompressible parts of those strings,\r\n   * because in these cases the relevant information is the table name and we can't really do\r\n   * any better; shortening the individual parts again might make it even more confusing.\r\n   *\r\n   * So for example, the fk for the table `mytable_myattr4567d_localizations` will become\r\n   * mytable_myattr4567d_loc63bf2_fk\r\n   */\r\n\r\n  // base index types\r\n  getIndexName = (names: NameInput, options?: NameOptions) => {\r\n    return this.getName(names, { suffix: 'index', ...options });\r\n  };\r\n\r\n  getFkIndexName = (names: NameInput, options?: NameOptions) => {\r\n    return this.getName(names, { suffix: 'fk', ...options });\r\n  };\r\n\r\n  getUniqueIndexName = (names: NameInput, options?: NameOptions) => {\r\n    return this.getName(names, { suffix: 'unique', ...options });\r\n  };\r\n\r\n  getPrimaryIndexName = (names: NameInput, options?: NameOptions) => {\r\n    return this.getName(names, { suffix: 'primary', ...options });\r\n  };\r\n\r\n  // custom index types\r\n  getInverseFkIndexName = (names: NameInput, options?: NameOptions) => {\r\n    return this.getName(names, { suffix: 'inv_fk', ...options });\r\n  };\r\n\r\n  getOrderFkIndexName = (names: NameInput, options?: NameOptions) => {\r\n    return this.getName(names, { suffix: 'order_fk', ...options });\r\n  };\r\n\r\n  getOrderInverseFkIndexName = (names: NameInput, options?: NameOptions) => {\r\n    return this.getName(names, { suffix: 'order_inv_fk', ...options });\r\n  };\r\n\r\n  getIdColumnIndexName = (names: NameInput, options?: NameOptions) => {\r\n    return this.getName(names, { suffix: 'id_column_index', ...options });\r\n  };\r\n\r\n  getOrderIndexName = (names: NameInput, options?: NameOptions) => {\r\n    return this.getName(names, { suffix: 'order_index', ...options });\r\n  };\r\n\r\n  /**\r\n   * Generates a string with a max length, appending a hash at the end if necessary to keep it unique\r\n   *\r\n   * @example\r\n   * // if we have strings such as \"longstring1\" and \"longstring2\" with a max length of 9,\r\n   * // we don't want to end up with \"longstrin\" and \"longstrin\"\r\n   * // we want something such as    \"longs0b23\" and \"longs953f\"\r\n   * const token1 = generateToken(\"longstring1\", 9); // \"longs0b23\"\r\n   * const token2 = generateToken(\"longstring2\", 9); // \"longs953f\"\r\n   *\r\n   * @param name - The base name\r\n   * @param len - The desired length of the token.\r\n   * @returns The generated token with hash.\r\n   * @throws Error if the length is not a positive integer, or if the length is too short for the token.\r\n   * @internal\r\n   */\r\n  getShortenedName = (name: string, len: number) => {\r\n    if (!isInteger(len) || len <= 0) {\r\n      throw new Error(`tokenWithHash length must be a positive integer, received ${len}`);\r\n    }\r\n    if (name.length <= len) {\r\n      return name;\r\n    }\r\n    if (len < this.MIN_TOKEN_LENGTH + this.HASH_LENGTH) {\r\n      throw new Error(\r\n        `length for part of identifier too short, minimum is hash length (${this.HASH_LENGTH}) plus min token length (${this.MIN_TOKEN_LENGTH}), received ${len} for token ${name}`\r\n      );\r\n    }\r\n\r\n    const availableLength = len - this.HASH_LENGTH - this.HASH_SEPARATOR.length;\r\n    if (availableLength < this.MIN_TOKEN_LENGTH) {\r\n      throw new Error(\r\n        `length for part of identifier minimum is less than min token length (${this.MIN_TOKEN_LENGTH}), received ${len} for token ${name}`\r\n      );\r\n    }\r\n\r\n    return `${name.substring(0, availableLength)}${this.HASH_SEPARATOR}${createHash(\r\n      name,\r\n      this.HASH_LENGTH\r\n    )}`;\r\n  };\r\n\r\n  /**\r\n   * Constructs a name from an array of name tokens within a specified maximum length. It ensures the final name does not exceed\r\n   * this limit by selectively compressing tokens marked as compressible. If the name exceeds the maximum length and cannot be\r\n   * compressed sufficiently, an error is thrown. This function supports dynamic adjustment of token lengths to fit within the\r\n   * maxLength constraint (that is, it will always make use of all available space), while also ensuring the preservation of\r\n   * incompressible tokens.\r\n   * @internal\r\n   */\r\n  getNameFromTokens = (nameTokens: NameToken[]): string => {\r\n    const { maxLength } = this.options;\r\n\r\n    if (!isInteger(maxLength) || maxLength < 0) {\r\n      throw new Error('maxLength must be a positive integer or 0 (for unlimited length)');\r\n    }\r\n\r\n    const unshortenedName = nameTokens\r\n      .map((token) => {\r\n        return token.name;\r\n      })\r\n      .join(this.IDENTIFIER_SEPARATOR);\r\n\r\n    // if maxLength == 0 we want the legacy v4 name without any shortening\r\n    if (maxLength === 0) {\r\n      this.setUnshortenedName(unshortenedName, unshortenedName);\r\n      return unshortenedName;\r\n    }\r\n\r\n    // check the full length name (but with incompressible tokens using shortNames if available)\r\n    const fullLengthName = nameTokens\r\n      .map((token) => {\r\n        if (token.compressible) {\r\n          return token.name;\r\n        }\r\n        return token.shortName ?? token.name;\r\n      })\r\n      .join(this.IDENTIFIER_SEPARATOR);\r\n\r\n    if (fullLengthName.length <= maxLength) {\r\n      this.setUnshortenedName(fullLengthName, unshortenedName);\r\n      return fullLengthName;\r\n    }\r\n\r\n    // Split tokens by compressibility\r\n    const [compressible, incompressible] = partition(\r\n      (token: NameToken) => token.compressible,\r\n      nameTokens\r\n    );\r\n\r\n    const totalIncompressibleLength = sumBy((token: NameToken) =>\r\n      token.compressible === false && token.shortName !== undefined\r\n        ? token.shortName.length\r\n        : token.name.length\r\n    )(incompressible);\r\n    const totalSeparatorsLength = nameTokens.length * this.IDENTIFIER_SEPARATOR.length - 1;\r\n    const available = maxLength - totalIncompressibleLength - totalSeparatorsLength;\r\n    const availablePerToken = Math.floor(available / compressible.length);\r\n\r\n    if (\r\n      totalIncompressibleLength + totalSeparatorsLength > maxLength ||\r\n      availablePerToken < this.MIN_TOKEN_LENGTH\r\n    ) {\r\n      throw new Error('Maximum length is too small to accommodate all tokens');\r\n    }\r\n\r\n    // Calculate the remainder from the division and add it to the surplus\r\n    let surplus = available % compressible.length;\r\n\r\n    // Check that it's even possible to proceed\r\n    const minHashedLength = this.HASH_LENGTH + this.HASH_SEPARATOR.length + this.MIN_TOKEN_LENGTH;\r\n    const totalLength = nameTokens.reduce(\r\n      (total, token) => {\r\n        if (token.compressible) {\r\n          if (token.name.length < availablePerToken) {\r\n            return total + token.name.length;\r\n          }\r\n          return total + minHashedLength;\r\n        }\r\n        const tokenName = token.shortName ?? token.name;\r\n        return total + tokenName.length;\r\n      },\r\n      nameTokens.length * this.IDENTIFIER_SEPARATOR.length - 1\r\n    );\r\n\r\n    // TODO: this is the weakest thing of the shortener, but fortunately it can be improved later without a breaking change if it turns out to be a problem (for example, if there is some case we need 6+ name parts in one identifier). We could take this \"shortest string we could generate\" that is too long and apply the hash directly to that, which would work fine even though it would be very difficult to determine what it was actually referring to\r\n    // Check if the maximum length is less than the total length\r\n    if (maxLength < totalLength) {\r\n      throw new Error('Maximum length is too small to accommodate all tokens');\r\n    }\r\n\r\n    // Calculate total surplus length from shorter strings and total deficit length from longer strings\r\n    let deficits: NameTokenWithAllocation[] = [];\r\n    compressible.forEach((token) => {\r\n      const actualLength = token.name.length;\r\n      if (actualLength < availablePerToken) {\r\n        surplus += availablePerToken - actualLength;\r\n        token.allocatedLength = actualLength;\r\n      } else {\r\n        token.allocatedLength = availablePerToken;\r\n        deficits.push(token as NameTokenWithAllocation);\r\n      }\r\n    });\r\n\r\n    // Redistribute surplus length to longer strings, one character at a time\r\n    // This way we avoid issues with greed and trying to handle floating points by dividing available length\r\n    function filterAndIncreaseLength(token: NameTokenWithAllocation) {\r\n      if (token.allocatedLength < token.name.length && surplus > 0) {\r\n        token.allocatedLength += 1;\r\n        surplus -= 1;\r\n        // if it hasn't reached its full length, keep it in array for next round\r\n        return token.allocatedLength < token.name.length;\r\n      }\r\n      return false; // Remove this token from the deficits array\r\n    }\r\n\r\n    // Redistribute surplus length to longer strings, one character at a time\r\n    let previousSurplus = surplus + 1; // infinite loop protection\r\n    while (surplus > 0 && deficits.length > 0) {\r\n      deficits = deficits.filter((token) => filterAndIncreaseLength(token));\r\n\r\n      // infinite loop protection; if the surplus hasn't changed, there was nothing left to distribute it to\r\n      if (surplus === previousSurplus) {\r\n        break;\r\n      }\r\n      previousSurplus = surplus;\r\n    }\r\n\r\n    // Build final string\r\n    const shortenedName = nameTokens\r\n      .map((token) => {\r\n        // if it is compressible, shorten it\r\n        if (\r\n          token.compressible &&\r\n          'allocatedLength' in token &&\r\n          token.allocatedLength !== undefined\r\n        ) {\r\n          return this.getShortenedName(token.name, token.allocatedLength);\r\n        }\r\n\r\n        // if is is only compressible as a fixed value, use that\r\n        if (token.compressible === false && token.shortName) {\r\n          return token.shortName;\r\n        }\r\n\r\n        // otherwise return it as-is\r\n        return token.name;\r\n      })\r\n      .join(this.IDENTIFIER_SEPARATOR);\r\n\r\n    // this should be unreachable, but add a final check for potential edge cases we missed\r\n    if (shortenedName.length > maxLength) {\r\n      throw new Error(\r\n        `name shortening failed to generate a name of the correct maxLength; name ${shortenedName}`\r\n      );\r\n    }\r\n\r\n    this.setUnshortenedName(shortenedName, unshortenedName);\r\n    return shortenedName;\r\n  };\r\n\r\n  // We need to be able to find the full-length name for any shortened name, primarily for migration purposes\r\n  // Therefore we store every name that passes through so we can retrieve the original later\r\n  nameMap = new Map<string, string>();\r\n\r\n  getUnshortenedName = (shortName: string) => {\r\n    return this.nameMap.get(this.serializeKey(shortName)) ?? shortName;\r\n  };\r\n\r\n  setUnshortenedName = (shortName: string, fullName: string) => {\r\n    // This is protection against cases where a name is shortened twice, for example shortened in a model outside of createMetadata\r\n    // and then run through the shortener against inside createMetadata, which would do nothing at all but replace the original\r\n    // name in this mapping\r\n    if (this.nameMap.get(this.serializeKey(shortName)) && shortName === fullName) {\r\n      return;\r\n    }\r\n\r\n    // set the name\r\n    this.nameMap.set(this.serializeKey(shortName), fullName);\r\n  };\r\n\r\n  serializeKey = (shortName: string) => {\r\n    return `${shortName}.${this.options.maxLength}`;\r\n  };\r\n}\r\n\r\n// TODO: instead of instantiating this here as a global metadata should create its own to use\r\n// However, that would require refactoring all of the metadata methods to be instantiated to keep a centralized identifiers\r\nexport const identifiers = new Identifiers({ maxLength: IDENTIFIER_MAX_LENGTH });\r\n","import * as types from '../utils/types';\r\nimport { identifiers } from '../utils/identifiers';\r\nimport type { Metadata, Meta } from '../metadata';\r\nimport type { Column, Schema, Table } from './types';\r\nimport type { Attribute } from '../types';\r\n\r\n/**\r\n * TODO: This needs to be refactored to support incoming names such as\r\n * (column, table, index) that are of the form string | NameToken[] so\r\n * that pieces can be passed through and shortened here.\r\n *\r\n * Currently, we are potentially shortening twice, although in reality\r\n * that won't happen since the shortened attribute column names will\r\n * fit here because they are already shortened to the max identifier\r\n * length\r\n *\r\n * That is the reason we use getName() here and not getColumnName();\r\n * we just want the exact shortened name for the value without doing\r\n * any other potential manipulation to it\r\n * */\r\n\r\nconst createColumn = (name: string, attribute: Attribute): Column => {\r\n  const { type, args = [], ...opts } = getColumnType(attribute);\r\n\r\n  return {\r\n    name: identifiers.getName(name),\r\n    type,\r\n    args,\r\n    defaultTo: null,\r\n    notNullable: false,\r\n    unsigned: false,\r\n    ...opts,\r\n    ...('column' in attribute ? (attribute.column ?? {}) : {}),\r\n  };\r\n};\r\n\r\nconst createTable = (meta: Meta): Table => {\r\n  const table: Table = {\r\n    name: meta.tableName,\r\n    indexes: meta.indexes || [],\r\n    foreignKeys: meta.foreignKeys || [],\r\n    columns: [],\r\n  };\r\n\r\n  for (const key of Object.keys(meta.attributes)) {\r\n    const attribute = meta.attributes[key];\r\n\r\n    // if (types.isRelation(attribute.type)) {\r\n    if (attribute.type === 'relation') {\r\n      if ('morphColumn' in attribute && attribute.morphColumn && attribute.owner) {\r\n        const { idColumn, typeColumn } = attribute.morphColumn;\r\n\r\n        const idColumnName = identifiers.getName(idColumn.name);\r\n        const typeColumnName = identifiers.getName(typeColumn.name);\r\n\r\n        table.columns.push(\r\n          createColumn(idColumnName, {\r\n            type: 'integer',\r\n            column: {\r\n              unsigned: true,\r\n            },\r\n          })\r\n        );\r\n\r\n        table.columns.push(createColumn(typeColumnName, { type: 'string' }));\r\n      } else if (\r\n        'joinColumn' in attribute &&\r\n        attribute.joinColumn &&\r\n        attribute.owner &&\r\n        attribute.joinColumn.referencedTable\r\n      ) {\r\n        // NOTE: we could pass uniquness for oneToOne to avoid creating more than one to one\r\n\r\n        const {\r\n          name: columnNameFull,\r\n          referencedColumn,\r\n          referencedTable,\r\n          columnType = 'integer',\r\n        } = attribute.joinColumn;\r\n\r\n        const columnName = identifiers.getName(columnNameFull);\r\n\r\n        const column = createColumn(columnName, {\r\n          // TODO: find the column type automatically, or allow passing all the column params\r\n          type: columnType,\r\n          column: {\r\n            unsigned: true,\r\n          },\r\n        });\r\n\r\n        table.columns.push(column);\r\n\r\n        const fkName = identifiers.getFkIndexName([table.name, columnName]);\r\n        table.foreignKeys.push({\r\n          name: fkName,\r\n          columns: [column.name],\r\n          referencedTable,\r\n          referencedColumns: [referencedColumn],\r\n          // NOTE: could allow configuration\r\n          onDelete: 'SET NULL',\r\n        });\r\n\r\n        table.indexes.push({\r\n          name: fkName,\r\n          columns: [column.name],\r\n        });\r\n      }\r\n    } else if (types.isScalarAttribute(attribute)) {\r\n      const columnName = identifiers.getName(attribute.columnName || key);\r\n\r\n      const column = createColumn(columnName, attribute);\r\n\r\n      if (column.unique) {\r\n        table.indexes.push({\r\n          type: 'unique',\r\n          name: identifiers.getUniqueIndexName([table.name, column.name]),\r\n          columns: [columnName],\r\n        });\r\n      }\r\n\r\n      if (column.primary) {\r\n        table.indexes.push({\r\n          type: 'primary',\r\n          name: identifiers.getPrimaryIndexName([table.name, column.name]),\r\n          columns: [columnName],\r\n        });\r\n      }\r\n\r\n      table.columns.push(column);\r\n    }\r\n  }\r\n\r\n  return table;\r\n};\r\n\r\nconst getColumnType = (attribute: Attribute) => {\r\n  if ('columnType' in attribute && attribute.columnType) {\r\n    return attribute.columnType;\r\n  }\r\n\r\n  switch (attribute.type) {\r\n    case 'increments': {\r\n      return {\r\n        type: 'increments',\r\n        args: [{ primary: true, primaryKey: true }],\r\n        notNullable: true,\r\n      };\r\n    }\r\n\r\n    // We might want to convert email/password to string types before going into the orm with specific validators & transformers\r\n    case 'password':\r\n    case 'email':\r\n    case 'string':\r\n    case 'enumeration': {\r\n      return { type: 'string' };\r\n    }\r\n    case 'uid': {\r\n      return {\r\n        type: 'string',\r\n      };\r\n    }\r\n    case 'richtext':\r\n    case 'text': {\r\n      return {\r\n        type: 'text',\r\n        args: ['longtext'],\r\n      };\r\n    }\r\n    case 'blocks':\r\n    case 'json': {\r\n      return { type: 'jsonb' };\r\n    }\r\n    case 'integer': {\r\n      return { type: 'integer' };\r\n    }\r\n    case 'biginteger': {\r\n      return { type: 'bigInteger' };\r\n    }\r\n    case 'float': {\r\n      return { type: 'double' };\r\n    }\r\n    case 'decimal': {\r\n      return { type: 'decimal', args: [10, 2] };\r\n    }\r\n    case 'date': {\r\n      return { type: 'date' };\r\n    }\r\n    case 'time': {\r\n      return { type: 'time', args: [{ precision: 3 }] };\r\n    }\r\n    case 'datetime': {\r\n      return {\r\n        type: 'datetime',\r\n        args: [\r\n          {\r\n            useTz: false,\r\n            precision: 6,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n    case 'timestamp': {\r\n      return {\r\n        type: 'timestamp',\r\n        args: [\r\n          {\r\n            useTz: false,\r\n            precision: 6,\r\n          },\r\n        ],\r\n      };\r\n    }\r\n    case 'boolean': {\r\n      return { type: 'boolean' };\r\n    }\r\n    default: {\r\n      throw new Error(`Unknown type ${attribute.type}`);\r\n    }\r\n  }\r\n};\r\n\r\nexport const metadataToSchema = (metadata: Metadata): Schema => {\r\n  const schema: Schema = {\r\n    tables: [],\r\n  };\r\n\r\n  metadata.forEach((metadata) => {\r\n    schema.tables.push(createTable(metadata));\r\n  });\r\n\r\n  return schema;\r\n};\r\n","import createDebug from 'debug';\r\n\r\nimport createSchemaBuilder from './builder';\r\nimport createSchemaDiff from './diff';\r\nimport createSchemaStorage from './storage';\r\nimport { metadataToSchema } from './schema';\r\n\r\nimport type { Schema } from './types';\r\nimport type { Database } from '..';\r\n\r\nexport type * from './types';\r\n\r\nconst debug = createDebug('strapi::database');\r\n\r\nexport interface SchemaProvider {\r\n  builder: ReturnType<typeof createSchemaBuilder>;\r\n  schemaDiff: ReturnType<typeof createSchemaDiff>;\r\n  schemaStorage: ReturnType<typeof createSchemaStorage>;\r\n  sync(): Promise<void>;\r\n  syncSchema(): Promise<void>;\r\n  reset(): Promise<void>;\r\n  create(): Promise<void>;\r\n  drop(): Promise<void>;\r\n  schema: Schema;\r\n}\r\n\r\ninterface State {\r\n  schema?: Schema;\r\n}\r\n\r\nexport const createSchemaProvider = (db: Database): SchemaProvider => {\r\n  const state: State = {};\r\n\r\n  return {\r\n    get schema() {\r\n      if (!state.schema) {\r\n        debug('Converting metadata to database schema');\r\n        state.schema = metadataToSchema(db.metadata);\r\n      }\r\n\r\n      return state.schema;\r\n    },\r\n    builder: createSchemaBuilder(db),\r\n    schemaDiff: createSchemaDiff(db),\r\n    schemaStorage: createSchemaStorage(db),\r\n\r\n    /**\r\n     * Drops the database schema\r\n     */\r\n    async drop() {\r\n      debug('Dropping database schema');\r\n\r\n      const DBSchema = await db.dialect.schemaInspector.getSchema();\r\n      await this.builder.dropSchema(DBSchema);\r\n    },\r\n\r\n    /**\r\n     * Creates the database schema\r\n     */\r\n    async create() {\r\n      debug('Created database schema');\r\n      await this.builder.createSchema(this.schema);\r\n    },\r\n\r\n    /**\r\n     * Resets the database schema\r\n     */\r\n    async reset() {\r\n      debug('Resetting database schema');\r\n      await this.drop();\r\n      await this.create();\r\n    },\r\n\r\n    async syncSchema() {\r\n      debug('Synchronizing database schema');\r\n\r\n      const databaseSchema = await db.dialect.schemaInspector.getSchema();\r\n      const storedSchema = await this.schemaStorage.read();\r\n\r\n      /*\r\n        3way diff - DB schema / previous metadataSchema / new metadataSchema\r\n\r\n        - When something doesn't exist in the previous metadataSchema -> It's not tracked by us and should be ignored\r\n        - If no previous metadataSchema => use new metadataSchema so we start tracking them and ignore everything else\r\n        - Apply this logic to Tables / Columns / Indexes / FKs ...\r\n        - Handle errors (indexes or fks on incompatible stuff ...)\r\n\r\n      */\r\n\r\n      const { status, diff } = await this.schemaDiff.diff({\r\n        previousSchema: storedSchema?.schema,\r\n        databaseSchema,\r\n        userSchema: this.schema,\r\n      });\r\n\r\n      if (status === 'CHANGED') {\r\n        await this.builder.updateSchema(diff);\r\n      }\r\n\r\n      await this.schemaStorage.add(this.schema);\r\n    },\r\n\r\n    // TODO: support options to migrate softly or forcefully\r\n    // TODO: support option to disable auto migration & run a CLI command instead to avoid doing it at startup\r\n    // TODO: Allow keeping extra indexes / extra tables / extra columns (globally or on a per table basis)\r\n    async sync() {\r\n      if (await db.migrations.shouldRun()) {\r\n        debug('Found migrations to run');\r\n        await db.migrations.up();\r\n\r\n        return this.syncSchema();\r\n      }\r\n\r\n      const oldSchema = await this.schemaStorage.read();\r\n\r\n      if (!oldSchema) {\r\n        debug('Schema not persisted yet');\r\n        return this.syncSchema();\r\n      }\r\n\r\n      const { hash: oldHash } = oldSchema;\r\n      const hash = await this.schemaStorage.hashSchema(this.schema);\r\n\r\n      if (oldHash !== hash) {\r\n        debug('Schema changed');\r\n\r\n        return this.syncSchema();\r\n      }\r\n\r\n      debug('Schema unchanged');\r\n    },\r\n  };\r\n};\r\n","import _, { snakeCase } from 'lodash/fp';\r\n\r\nimport { identifiers } from '../utils/identifiers';\r\nimport type { Meta, Metadata } from './metadata';\r\nimport type { RelationalAttribute, Relation, MorphJoinTable } from '../types';\r\n\r\ninterface JoinColumnOptions {\r\n  attribute: (Relation.OneToOne | Relation.ManyToOne) & Relation.Owner;\r\n  attributeName: string;\r\n  meta: Meta;\r\n}\r\n\r\ninterface JoinTableOptions {\r\n  attribute: RelationalAttribute & Relation.WithTarget & Relation.Bidirectional;\r\n  attributeName: string;\r\n  meta: Meta;\r\n}\r\n\r\nconst ID = identifiers.ID_COLUMN;\r\nconst ORDER = identifiers.ORDER_COLUMN;\r\nconst FIELD = identifiers.FIELD_COLUMN;\r\n\r\nconst hasInversedBy = (\r\n  attr: RelationalAttribute\r\n): attr is RelationalAttribute & { inversedBy: boolean } => 'inversedBy' in attr;\r\nconst hasMappedBy = (\r\n  attr: RelationalAttribute\r\n): attr is RelationalAttribute & { inversedBy: boolean } => 'mappedBy' in attr;\r\n\r\n// TODO: use strapi/utils relations for all of these\r\nexport const isPolymorphic = (attribute: RelationalAttribute): attribute is Relation.Morph =>\r\n  ['morphOne', 'morphMany', 'morphToOne', 'morphToMany'].includes(attribute.relation);\r\n\r\nexport const isOneToAny = (\r\n  attribute: RelationalAttribute\r\n): attribute is Relation.OneToOne | Relation.OneToMany =>\r\n  ['oneToOne', 'oneToMany'].includes(attribute.relation);\r\n\r\nexport const isManyToAny = (\r\n  attribute: RelationalAttribute\r\n): attribute is Relation.ManyToOne | Relation.ManyToMany =>\r\n  ['manyToMany', 'manyToOne'].includes(attribute.relation);\r\n\r\nexport const isAnyToOne = (\r\n  attribute: RelationalAttribute\r\n): attribute is Relation.OneToOne | Relation.ManyToOne =>\r\n  ['oneToOne', 'manyToOne'].includes(attribute.relation);\r\n\r\nexport const isAnyToMany = (\r\n  attribute: RelationalAttribute\r\n): attribute is Relation.OneToMany | Relation.ManyToMany =>\r\n  ['oneToMany', 'manyToMany'].includes(attribute.relation);\r\n\r\nexport const isBidirectional = (\r\n  attribute: RelationalAttribute\r\n): attribute is Relation.Bidirectional => hasInversedBy(attribute) || hasMappedBy(attribute);\r\n\r\nconst isOwner = (\r\n  attribute: RelationalAttribute\r\n): attribute is RelationalAttribute & Relation.Owner =>\r\n  !isBidirectional(attribute) || hasInversedBy(attribute);\r\n\r\nconst shouldUseJoinTable = (attribute: RelationalAttribute) =>\r\n  !('useJoinTable' in attribute) || attribute.useJoinTable !== false;\r\n\r\nexport const hasOrderColumn = (attribute: RelationalAttribute) => isAnyToMany(attribute);\r\nexport const hasInverseOrderColumn = (attribute: RelationalAttribute) =>\r\n  isBidirectional(attribute) && isManyToAny(attribute);\r\n\r\n/**\r\n * Creates a oneToOne relation metadata\r\n *\r\n * if owner then\r\n *   if with join table then\r\n *     create join table\r\n *   else\r\n *     create joinColumn\r\n *   if bidirectional then\r\n *     set inverse attribute joinCol or joinTable info correctly\r\n * else\r\n *   this property must be set by the owner side\r\n *   verify the owner side is valid // should be done before or at the same time ?\r\n */\r\nconst createOneToOne = (\r\n  attributeName: string,\r\n  attribute: Relation.OneToOne,\r\n  meta: Meta,\r\n  metadata: Metadata\r\n) => {\r\n  if (isOwner(attribute)) {\r\n    if (shouldUseJoinTable(attribute)) {\r\n      createJoinTable(metadata, {\r\n        attribute,\r\n        attributeName,\r\n        meta,\r\n      });\r\n    } else {\r\n      createJoinColumn(metadata, {\r\n        attribute,\r\n        attributeName,\r\n        meta,\r\n      });\r\n    }\r\n  } else {\r\n    // TODO: verify other side is valid\r\n  }\r\n};\r\n\r\n/**\r\n * Creates a oneToMany relation metadata\r\n *\r\n * if unidirectional then\r\n *   create join table\r\n * if bidirectional then\r\n *   cannot be owning side\r\n *   do nothing\r\n */\r\nconst createOneToMany = (\r\n  attributeName: string,\r\n  attribute: Relation.OneToMany,\r\n  meta: Meta,\r\n  metadata: Metadata\r\n) => {\r\n  if (shouldUseJoinTable(attribute) && !isBidirectional(attribute)) {\r\n    createJoinTable(metadata, {\r\n      attribute,\r\n      attributeName,\r\n      meta,\r\n    });\r\n  } else if (isOwner(attribute)) {\r\n    throw new Error('one side of a oneToMany cannot be the owner side in a bidirectional relation');\r\n  }\r\n};\r\n\r\n/**\r\n * Creates a manyToOne relation metadata\r\n *\r\n * if unidirectional then\r\n *   if with join table then\r\n *     create join table\r\n *   else\r\n *     create join column\r\n * else\r\n *   must be the owner side\r\n *   if with join table then\r\n *     create join table\r\n *   else\r\n *     create join column\r\n *   set inverse attribute joinCol or joinTable info correctly\r\n */\r\nconst createManyToOne = (\r\n  attributeName: string,\r\n  attribute: Relation.ManyToOne,\r\n  meta: Meta,\r\n  metadata: Metadata\r\n) => {\r\n  if (isBidirectional(attribute) && !isOwner(attribute)) {\r\n    throw new Error('The many side of a manyToOne must be the owning side');\r\n  }\r\n\r\n  if (shouldUseJoinTable(attribute)) {\r\n    createJoinTable(metadata, {\r\n      attribute,\r\n      attributeName,\r\n      meta,\r\n    });\r\n  } else {\r\n    createJoinColumn(metadata, {\r\n      attribute,\r\n      attributeName,\r\n      meta,\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * Creates a manyToMany relation metadata\r\n *\r\n * if unidirectional\r\n *   create join table\r\n * else\r\n *   if owner then\r\n *     if with join table then\r\n *       create join table\r\n *   else\r\n *     do nothing\r\n */\r\nconst createManyToMany = (\r\n  attributeName: string,\r\n  attribute: Relation.ManyToMany,\r\n  meta: Meta,\r\n  metadata: Metadata\r\n) => {\r\n  if (shouldUseJoinTable(attribute) && (!isBidirectional(attribute) || isOwner(attribute))) {\r\n    createJoinTable(metadata, {\r\n      attribute,\r\n      attributeName,\r\n      meta,\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * Creates a morphToOne relation metadata\r\n *\r\n * if with join table then\r\n *   create join table\r\n * else\r\n *  create join columnsa\r\n *\r\n * if bidirectionnal\r\n *  set info in the traget\r\n */\r\nconst createMorphToOne = (attributeName: string, attribute: Relation.MorphToOne) => {\r\n  const idColumnName = identifiers.getJoinColumnAttributeIdName('target');\r\n  const typeColumnName = identifiers.getMorphColumnTypeName('target');\r\n\r\n  Object.assign(attribute, {\r\n    owner: true,\r\n    morphColumn: attribute.morphColumn ?? {\r\n      typeColumn: {\r\n        name: typeColumnName,\r\n      },\r\n      idColumn: {\r\n        name: idColumnName,\r\n        referencedColumn: ID,\r\n      },\r\n    },\r\n  });\r\n};\r\n\r\n/**\r\n * Creates a morphToMany relation metadata\r\n */\r\nconst createMorphToMany = (\r\n  attributeName: string,\r\n  attribute: Relation.MorphToMany,\r\n  meta: Meta,\r\n  metadata: Metadata\r\n) => {\r\n  if ('joinTable' in attribute && attribute.joinTable && !attribute.joinTable.__internal__) {\r\n    return;\r\n  }\r\n\r\n  const joinTableName = identifiers.getMorphTableName(meta.tableName, attributeName);\r\n  const joinColumnName = identifiers.getMorphColumnJoinTableIdName(snakeCase(meta.singularName));\r\n  const idColumnName = identifiers.getMorphColumnAttributeIdName(attributeName);\r\n  const typeColumnName = identifiers.getMorphColumnTypeName(attributeName);\r\n\r\n  const fkIndexName = identifiers.getFkIndexName(joinTableName);\r\n\r\n  metadata.add({\r\n    singularName: joinTableName,\r\n    uid: joinTableName,\r\n    tableName: joinTableName,\r\n    attributes: {\r\n      [ID]: {\r\n        type: 'increments',\r\n      },\r\n      [joinColumnName]: {\r\n        type: 'integer',\r\n        column: {\r\n          unsigned: true,\r\n        },\r\n        // This must be set explicitly so that it is used instead of shortening the attribute name, which is already shortened\r\n        columnName: joinColumnName,\r\n      },\r\n      [idColumnName]: {\r\n        type: 'integer',\r\n        column: {\r\n          unsigned: true,\r\n        },\r\n      },\r\n      [typeColumnName]: {\r\n        type: 'string',\r\n      },\r\n      [FIELD]: {\r\n        type: 'string',\r\n      },\r\n      [ORDER]: {\r\n        type: 'float',\r\n        column: {\r\n          unsigned: true,\r\n        },\r\n      },\r\n    },\r\n    indexes: [\r\n      {\r\n        name: fkIndexName,\r\n        columns: [joinColumnName],\r\n      },\r\n      {\r\n        name: identifiers.getOrderIndexName(joinTableName),\r\n        columns: [ORDER],\r\n      },\r\n      {\r\n        name: identifiers.getIdColumnIndexName(joinTableName),\r\n        columns: [idColumnName],\r\n      },\r\n    ],\r\n    foreignKeys: [\r\n      {\r\n        name: fkIndexName,\r\n        columns: [joinColumnName],\r\n        referencedColumns: [ID],\r\n        referencedTable: meta.tableName,\r\n        onDelete: 'CASCADE',\r\n      },\r\n    ],\r\n    lifecycles: {},\r\n    columnToAttribute: {},\r\n  });\r\n\r\n  const joinTable: MorphJoinTable = {\r\n    __internal__: true,\r\n    name: joinTableName,\r\n    joinColumn: {\r\n      name: joinColumnName,\r\n      referencedColumn: ID,\r\n    },\r\n    morphColumn: {\r\n      typeColumn: {\r\n        name: typeColumnName,\r\n      },\r\n      idColumn: {\r\n        name: idColumnName,\r\n        referencedColumn: ID,\r\n      },\r\n    },\r\n    orderBy: {\r\n      order: 'asc' as const,\r\n    },\r\n    pivotColumns: [joinColumnName, typeColumnName, idColumnName],\r\n  };\r\n\r\n  attribute.joinTable = joinTable;\r\n};\r\n\r\n/**\r\n * Creates a morphOne relation metadata\r\n */\r\nconst createMorphOne = (\r\n  attributeName: string,\r\n  attribute: Relation.MorphOne,\r\n  meta: Meta,\r\n  metadata: Metadata\r\n) => {\r\n  const targetMeta = metadata.get(attribute.target);\r\n\r\n  if (!targetMeta) {\r\n    throw new Error(`Morph target not found. Looking for ${attribute.target}`);\r\n  }\r\n\r\n  if (attribute.morphBy && !_.has(attribute.morphBy, targetMeta.attributes)) {\r\n    throw new Error(`Morph target attribute not found. Looking for ${attribute.morphBy}`);\r\n  }\r\n};\r\n\r\n/**\r\n * Creates a morphMany relation metadata\r\n */\r\nconst createMorphMany = (\r\n  attributeName: string,\r\n  attribute: Relation.MorphMany,\r\n  meta: Meta,\r\n  metadata: Metadata\r\n) => {\r\n  const targetMeta = metadata.get(attribute.target);\r\n\r\n  if (!targetMeta) {\r\n    throw new Error(`Morph target not found. Looking for ${attribute.target}`);\r\n  }\r\n\r\n  if (attribute.morphBy && !_.has(attribute.morphBy, targetMeta.attributes)) {\r\n    throw new Error(`Morph target attribute not found. Looking for ${attribute.morphBy}`);\r\n  }\r\n};\r\n\r\n/**\r\n * Creates a join column info and add them to the attribute meta\r\n */\r\nconst createJoinColumn = (metadata: Metadata, { attribute, attributeName }: JoinColumnOptions) => {\r\n  const targetMeta = metadata.get(attribute.target);\r\n\r\n  if (!targetMeta) {\r\n    throw new Error(`Unknown target ${attribute.target}`);\r\n  }\r\n\r\n  const joinColumnName = identifiers.getJoinColumnAttributeIdName(snakeCase(attributeName));\r\n  const joinColumn = {\r\n    name: joinColumnName,\r\n    referencedColumn: ID,\r\n    referencedTable: targetMeta.tableName,\r\n  };\r\n\r\n  if ('joinColumn' in attribute) {\r\n    Object.assign(joinColumn, attribute.joinColumn);\r\n  }\r\n\r\n  Object.assign(attribute, { owner: true, joinColumn });\r\n\r\n  if (isBidirectional(attribute)) {\r\n    const inverseAttribute = targetMeta.attributes[attribute.inversedBy];\r\n\r\n    Object.assign(inverseAttribute, {\r\n      joinColumn: {\r\n        name: joinColumn.referencedColumn,\r\n        referencedColumn: joinColumnName,\r\n      },\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * Creates a join table and add it to the attribute meta\r\n */\r\nconst createJoinTable = (\r\n  metadata: Metadata,\r\n  { attributeName, attribute, meta }: JoinTableOptions\r\n) => {\r\n  if (!shouldUseJoinTable(attribute)) {\r\n    throw new Error('Attempted to create join table when useJoinTable is false');\r\n  }\r\n\r\n  const targetMeta = metadata.get(attribute.target);\r\n\r\n  if (!targetMeta) {\r\n    throw new Error(`Unknown target ${attribute.target}`);\r\n  }\r\n\r\n  // TODO: implement overwrite logic instead\r\n  if ('joinTable' in attribute && attribute.joinTable && !attribute.joinTable.__internal__) {\r\n    return;\r\n  }\r\n\r\n  const joinTableName = identifiers.getJoinTableName(\r\n    snakeCase(meta.tableName),\r\n    snakeCase(attributeName)\r\n  );\r\n\r\n  const joinColumnName = identifiers.getJoinColumnAttributeIdName(snakeCase(meta.singularName));\r\n\r\n  let inverseJoinColumnName = identifiers.getJoinColumnAttributeIdName(\r\n    snakeCase(targetMeta.singularName)\r\n  );\r\n\r\n  // if relation is self referencing\r\n  if (joinColumnName === inverseJoinColumnName) {\r\n    inverseJoinColumnName = identifiers.getInverseJoinColumnAttributeIdName(\r\n      snakeCase(targetMeta.singularName)\r\n    );\r\n  }\r\n\r\n  const orderColumnName = identifiers.getOrderColumnName(snakeCase(targetMeta.singularName));\r\n  // TODO: should this plus the conditional below be rolled into one method?\r\n  let inverseOrderColumnName = identifiers.getOrderColumnName(snakeCase(meta.singularName));\r\n\r\n  // if relation is self referencing\r\n  if (attribute.relation === 'manyToMany' && orderColumnName === inverseOrderColumnName) {\r\n    inverseOrderColumnName = identifiers.getInverseOrderColumnName(snakeCase(meta.singularName));\r\n  }\r\n\r\n  const fkIndexName = identifiers.getFkIndexName(joinTableName);\r\n  const invFkIndexName = identifiers.getInverseFkIndexName(joinTableName);\r\n\r\n  const metadataSchema: Meta = {\r\n    singularName: joinTableName,\r\n    uid: joinTableName,\r\n    tableName: joinTableName,\r\n    attributes: {\r\n      [ID]: {\r\n        type: 'increments',\r\n      },\r\n      [joinColumnName]: {\r\n        type: 'integer',\r\n        column: {\r\n          unsigned: true,\r\n        },\r\n        // This must be set explicitly so that it is used instead of shortening the attribute name, which is already shortened\r\n        columnName: joinColumnName,\r\n      },\r\n      [inverseJoinColumnName]: {\r\n        type: 'integer',\r\n        column: {\r\n          unsigned: true,\r\n        },\r\n        // This must be set explicitly so that it is used instead of shortening the attribute name, which is already shortened\r\n        columnName: inverseJoinColumnName,\r\n      },\r\n      // TODO: add extra pivot attributes -> user should use an intermediate entity\r\n    },\r\n    indexes: [\r\n      {\r\n        name: fkIndexName,\r\n        columns: [joinColumnName],\r\n      },\r\n      {\r\n        name: invFkIndexName,\r\n        columns: [inverseJoinColumnName],\r\n      },\r\n      {\r\n        name: identifiers.getUniqueIndexName(joinTableName),\r\n        columns: [joinColumnName, inverseJoinColumnName],\r\n        type: 'unique',\r\n      },\r\n    ],\r\n    foreignKeys: [\r\n      {\r\n        name: fkIndexName,\r\n        columns: [joinColumnName],\r\n        referencedColumns: [ID],\r\n        referencedTable: meta.tableName,\r\n        onDelete: 'CASCADE',\r\n      },\r\n      {\r\n        name: invFkIndexName,\r\n        columns: [inverseJoinColumnName],\r\n        referencedColumns: [ID],\r\n        referencedTable: targetMeta.tableName,\r\n        onDelete: 'CASCADE',\r\n      },\r\n    ],\r\n    lifecycles: {},\r\n    columnToAttribute: {},\r\n  };\r\n\r\n  const joinTable = {\r\n    __internal__: true,\r\n    name: joinTableName,\r\n    joinColumn: {\r\n      name: joinColumnName,\r\n      referencedColumn: ID,\r\n      referencedTable: meta.tableName,\r\n    },\r\n    inverseJoinColumn: {\r\n      name: inverseJoinColumnName,\r\n      referencedColumn: ID,\r\n      referencedTable: targetMeta.tableName,\r\n    },\r\n    pivotColumns: [joinColumnName, inverseJoinColumnName],\r\n  } as any;\r\n\r\n  // order\r\n  if (isAnyToMany(attribute)) {\r\n    metadataSchema.attributes[orderColumnName] = {\r\n      type: 'float',\r\n      column: {\r\n        unsigned: true,\r\n        defaultTo: null,\r\n      },\r\n      columnName: orderColumnName,\r\n    };\r\n    metadataSchema.indexes.push({\r\n      name: identifiers.getOrderFkIndexName(joinTableName),\r\n      columns: [orderColumnName],\r\n    });\r\n    joinTable.orderColumnName = orderColumnName;\r\n    joinTable.orderBy = { [orderColumnName]: 'asc' };\r\n  }\r\n\r\n  // inv order\r\n  if (isBidirectional(attribute) && isManyToAny(attribute)) {\r\n    metadataSchema.attributes[inverseOrderColumnName] = {\r\n      type: 'float',\r\n      column: {\r\n        unsigned: true,\r\n        defaultTo: null,\r\n      },\r\n      columnName: inverseOrderColumnName,\r\n    };\r\n\r\n    metadataSchema.indexes.push({\r\n      name: identifiers.getOrderInverseFkIndexName(joinTableName),\r\n      columns: [inverseOrderColumnName],\r\n    });\r\n\r\n    joinTable.inverseOrderColumnName = inverseOrderColumnName;\r\n  }\r\n\r\n  metadata.add(metadataSchema);\r\n\r\n  attribute.joinTable = joinTable;\r\n\r\n  if (isBidirectional(attribute)) {\r\n    const inverseAttribute = attribute.inversedBy\r\n      ? (targetMeta.attributes[attribute.inversedBy] as Relation.Bidirectional)\r\n      : null;\r\n\r\n    if (!inverseAttribute) {\r\n      throw new Error(\r\n        `inversedBy attribute ${attribute.inversedBy} not found target ${targetMeta.uid}`\r\n      );\r\n    }\r\n\r\n    if (inverseAttribute.type !== 'relation') {\r\n      throw new Error(\r\n        `inversedBy attribute ${attribute.inversedBy} targets non relational attribute in ${targetMeta.uid}`\r\n      );\r\n    }\r\n\r\n    inverseAttribute.joinTable = {\r\n      __internal__: true,\r\n      name: joinTableName,\r\n      joinColumn: joinTable.inverseJoinColumn,\r\n      inverseJoinColumn: joinTable.joinColumn,\r\n      pivotColumns: joinTable.pivotColumns,\r\n    } as any;\r\n\r\n    if (isManyToAny(attribute)) {\r\n      inverseAttribute.joinTable.orderColumnName = inverseOrderColumnName;\r\n      inverseAttribute.joinTable.orderBy = { [inverseOrderColumnName]: 'asc' };\r\n    }\r\n    if (isAnyToMany(attribute)) {\r\n      inverseAttribute.joinTable.inverseOrderColumnName = orderColumnName;\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Creates a relation metadata\r\n */\r\nexport const createRelation = (\r\n  attributeName: string,\r\n  attribute: RelationalAttribute,\r\n  meta: Meta,\r\n  metadata: Metadata\r\n) => {\r\n  switch (attribute.relation) {\r\n    case 'oneToOne':\r\n      return createOneToOne(attributeName, attribute, meta, metadata);\r\n    case 'oneToMany':\r\n      return createOneToMany(attributeName, attribute, meta, metadata);\r\n    case 'manyToOne':\r\n      return createManyToOne(attributeName, attribute, meta, metadata);\r\n    case 'manyToMany':\r\n      return createManyToMany(attributeName, attribute, meta, metadata);\r\n    case 'morphToOne':\r\n      return createMorphToOne(attributeName, attribute);\r\n    case 'morphToMany':\r\n      return createMorphToMany(attributeName, attribute, meta, metadata);\r\n    case 'morphOne':\r\n      return createMorphOne(attributeName, attribute, meta, metadata);\r\n    case 'morphMany':\r\n      return createMorphMany(attributeName, attribute, meta, metadata);\r\n    default: {\r\n      throw new Error(`Unknown relation`);\r\n    }\r\n  }\r\n};\r\n","import { cloneDeep, snakeCase } from 'lodash/fp';\r\nimport { identifiers } from '../utils/identifiers';\r\nimport * as types from '../utils/types';\r\nimport { createRelation } from './relations';\r\nimport type { Attribute, Model } from '../types';\r\nimport type { ForeignKey, Index } from '../schema/types';\r\nimport type { Action, SubscriberFn } from '../lifecycles';\r\n\r\nexport interface Meta extends Model {\r\n  columnToAttribute: Record<string, string>;\r\n  indexes: Index[];\r\n  foreignKeys: ForeignKey[];\r\n  lifecycles: Partial<Record<Action, SubscriberFn>>;\r\n}\r\n\r\nexport class Metadata extends Map<string, Meta> {\r\n  // TODO: we expose the global identifiers in this way so that in the future we can instantiate our own\r\n  // However, it should NOT be done until all the methods used by metadata can be part of this metadata object\r\n  // and access this one; currently they all access the global identifiers directly.\r\n  get identifiers() {\r\n    return identifiers;\r\n  }\r\n\r\n  get(key: string): Meta {\r\n    if (!super.has(key)) {\r\n      throw new Error(`Metadata for \"${key}\" not found`);\r\n    }\r\n\r\n    return super.get(key) as Meta;\r\n  }\r\n\r\n  add(meta: Meta) {\r\n    return this.set(meta.uid, meta);\r\n  }\r\n\r\n  /**\r\n   * Validate the DB metadata, throwing an error if a duplicate DB table name is detected\r\n   */\r\n  validate() {\r\n    const seenTables = new Map();\r\n    for (const meta of this.values()) {\r\n      if (seenTables.get(meta.tableName)) {\r\n        throw new Error(\r\n          `DB table \"${meta.tableName}\" already exists. Change the collectionName of the related content type.`\r\n        );\r\n      }\r\n      seenTables.set(meta.tableName, true);\r\n    }\r\n  }\r\n\r\n  loadModels(models: Model[]) {\r\n    // init pass\r\n    for (const model of cloneDeep(models ?? [])) {\r\n      const tableName = identifiers.getTableName(model.tableName);\r\n      this.add({\r\n        ...model,\r\n        tableName,\r\n        attributes: {\r\n          ...model.attributes,\r\n        },\r\n        lifecycles: model.lifecycles ?? {},\r\n        indexes: model.indexes ?? [],\r\n        foreignKeys: model.foreignKeys ?? [],\r\n        columnToAttribute: {},\r\n      });\r\n    }\r\n\r\n    // build compos / relations\r\n    for (const meta of this.values()) {\r\n      for (const [attributeName, attribute] of Object.entries(meta.attributes)) {\r\n        try {\r\n          if (attribute.unstable_virtual) {\r\n            continue;\r\n          }\r\n\r\n          if (types.isRelationalAttribute(attribute)) {\r\n            createRelation(attributeName, attribute, meta, this);\r\n            continue;\r\n          }\r\n\r\n          createAttribute(attributeName, attribute);\r\n        } catch (error) {\r\n          if (error instanceof Error) {\r\n            throw new Error(\r\n              `Error on attribute ${attributeName} in model ${meta.singularName}(${meta.uid}): ${error.message}`\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    for (const meta of this.values()) {\r\n      const columnToAttribute = Object.keys(meta.attributes).reduce((acc, key) => {\r\n        const attribute = meta.attributes[key];\r\n        if ('columnName' in attribute) {\r\n          return Object.assign(acc, { [attribute.columnName || key]: key });\r\n        }\r\n\r\n        return Object.assign(acc, { [key]: key });\r\n      }, {});\r\n\r\n      meta.columnToAttribute = columnToAttribute;\r\n    }\r\n\r\n    this.validate();\r\n  }\r\n}\r\n\r\nconst createAttribute = (attributeName: string, attribute: Attribute) => {\r\n  // if the attribute has already set its own column name, use that\r\n  // this will prevent us from shortening a name twice\r\n  if ('columnName' in attribute && attribute.columnName) {\r\n    return;\r\n  }\r\n\r\n  const columnName = identifiers.getColumnName(snakeCase(attributeName));\r\n\r\n  Object.assign(attribute, { columnName });\r\n};\r\n","import {\r\n  isPolymorphic,\r\n  isBidirectional,\r\n  isAnyToOne,\r\n  isOneToAny,\r\n  hasOrderColumn,\r\n  hasInverseOrderColumn,\r\n  isManyToAny,\r\n} from './relations';\r\nimport { Metadata, Meta } from './metadata';\r\nimport type { Model } from '../types';\r\n\r\nexport type { Metadata, Meta };\r\nexport {\r\n  isPolymorphic,\r\n  isBidirectional,\r\n  isAnyToOne,\r\n  isOneToAny,\r\n  hasOrderColumn,\r\n  hasInverseOrderColumn,\r\n  isManyToAny,\r\n};\r\n\r\n// TODO: check if there isn't an attribute with an id already\r\n/**\r\n * Create Metadata from models configurations\r\n */\r\nexport const createMetadata = (models: Model[]): Metadata => {\r\n  const metadata = new Metadata();\r\n\r\n  if (models.length) {\r\n    metadata.loadModels(models);\r\n  }\r\n\r\n  return metadata;\r\n};\r\n","export default class Field {\r\n  config: unknown;\r\n\r\n  constructor(config: unknown) {\r\n    this.config = config;\r\n  }\r\n\r\n  toDB(value: unknown) {\r\n    return value;\r\n  }\r\n\r\n  fromDB(value: unknown) {\r\n    return value;\r\n  }\r\n}\r\n","import { toString } from 'lodash/fp';\r\nimport Field from './field';\r\n\r\nexport default class StringField extends Field {\r\n  toDB(value: unknown) {\r\n    return toString(value);\r\n  }\r\n\r\n  fromDB(value: unknown) {\r\n    return toString(value);\r\n  }\r\n}\r\n","import Field from './field';\r\n\r\nexport default class JSONField extends Field {\r\n  toDB(value: unknown) {\r\n    if (value == null) {\r\n      return null;\r\n    }\r\n\r\n    if (typeof value === 'object') {\r\n      return JSON.stringify(value);\r\n    }\r\n\r\n    return value;\r\n  }\r\n\r\n  fromDB(value: unknown) {\r\n    try {\r\n      if (typeof value === 'string') {\r\n        const parsedValue = JSON.parse(value);\r\n\r\n        /**\r\n         * On Strapi 5 until 5.0.0-rc.7, the values were accidentally stringified twice when saved,\r\n         * so in those cases we need to parse them twice to retrieve the actual value.\r\n         */\r\n        if (typeof parsedValue === 'string') {\r\n          return JSON.parse(parsedValue);\r\n        }\r\n\r\n        return parsedValue;\r\n      }\r\n    } catch (error) {\r\n      // Just return the value if it's not a valid JSON string\r\n      return value;\r\n    }\r\n\r\n    return value;\r\n  }\r\n}\r\n","import StringField from './string';\r\n\r\nexport default class BigIntegerField extends StringField {}\r\n","import { toNumber } from 'lodash/fp';\r\nimport Field from './field';\r\n\r\nexport default class NumberField extends Field {\r\n  toDB(value: unknown) {\r\n    const numberValue = toNumber(value);\r\n\r\n    if (Number.isNaN(numberValue)) {\r\n      throw new Error(`Expected a valid Number, got ${value}`);\r\n    }\r\n\r\n    return numberValue;\r\n  }\r\n\r\n  fromDB(value: unknown) {\r\n    return toNumber(value);\r\n  }\r\n}\r\n","import { padCharsEnd, isString, toString } from 'lodash/fp';\r\nimport * as dateFns from 'date-fns';\r\n\r\nimport { InvalidDateTimeError, InvalidDateError, InvalidTimeError } from '../../errors';\r\n\r\nconst isDate = (value: unknown): value is Date => {\r\n  return dateFns.isDate(value);\r\n};\r\n\r\nconst DATE_REGEX = /^\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;\r\nconst PARTIAL_DATE_REGEX = /^\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])/g;\r\nconst TIME_REGEX = /^(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(.[0-9]{1,3})?$/;\r\n\r\nexport const parseDateTimeOrTimestamp = (value: unknown): Date => {\r\n  if (isDate(value)) {\r\n    return value;\r\n  }\r\n\r\n  try {\r\n    const date = dateFns.parseISO(toString(value));\r\n    if (dateFns.isValid(date)) {\r\n      return date;\r\n    }\r\n\r\n    const milliUnixDate = dateFns.parse(toString(value), 'T', new Date());\r\n    if (dateFns.isValid(milliUnixDate)) {\r\n      return milliUnixDate;\r\n    }\r\n\r\n    throw new InvalidDateTimeError(`Invalid format, expected a timestamp or an ISO date`);\r\n  } catch (error) {\r\n    throw new InvalidDateTimeError(`Invalid format, expected a timestamp or an ISO date`);\r\n  }\r\n};\r\n\r\nexport const parseDate = (value: unknown) => {\r\n  if (isDate(value)) {\r\n    return dateFns.format(value, 'yyyy-MM-dd');\r\n  }\r\n\r\n  const found = isString(value) ? value.match(PARTIAL_DATE_REGEX) || [] : [];\r\n  const extractedValue = found[0];\r\n\r\n  if (extractedValue && !DATE_REGEX.test(toString(value))) {\r\n    // TODO V5: throw an error when format yyyy-MM-dd is not respected\r\n    // throw new InvalidDateError(`Invalid format, expected yyyy-MM-dd`);\r\n    process.emitWarning(\r\n      `[deprecated] Using a date format other than YYYY-MM-DD will be removed in future versions. Date received: ${value}. Date stored: ${extractedValue}.`\r\n    );\r\n  }\r\n\r\n  if (!extractedValue) {\r\n    throw new InvalidDateError(`Invalid format, expected yyyy-MM-dd`);\r\n  }\r\n\r\n  const date = dateFns.parseISO(extractedValue);\r\n  if (!dateFns.isValid(date)) {\r\n    throw new InvalidDateError(`Invalid date`);\r\n  }\r\n\r\n  return extractedValue;\r\n};\r\n\r\nexport const parseTime = (value: unknown) => {\r\n  if (isDate(value)) {\r\n    return dateFns.format(value, 'HH:mm:ss.SSS');\r\n  }\r\n\r\n  if (typeof value !== 'string') {\r\n    throw new InvalidTimeError(`Expected a string, got a ${typeof value}`);\r\n  }\r\n\r\n  const result = value.match(TIME_REGEX);\r\n\r\n  if (result === null) {\r\n    throw new InvalidTimeError('Invalid time format, expected HH:mm:ss.SSS');\r\n  }\r\n\r\n  const [, hours, minutes, seconds, fraction = '.000'] = result;\r\n  const fractionPart = padCharsEnd('0', 3, fraction.slice(1));\r\n\r\n  return `${hours}:${minutes}:${seconds}.${fractionPart}`;\r\n};\r\n","import { parseDate } from './shared/parsers';\r\nimport Field from './field';\r\n\r\nexport default class DateField extends Field {\r\n  toDB(value: unknown) {\r\n    return parseDate(value);\r\n  }\r\n\r\n  fromDB(value: unknown) {\r\n    return value;\r\n  }\r\n}\r\n","import { parseTime } from './shared/parsers';\r\nimport Field from './field';\r\n\r\nexport default class TimeField extends Field {\r\n  toDB(value: unknown) {\r\n    return parseTime(value);\r\n  }\r\n\r\n  fromDB(value: unknown) {\r\n    // make sure that's a string with valid format ?\r\n    return value;\r\n  }\r\n}\r\n","import * as dateFns from 'date-fns';\r\n\r\nimport { parseDateTimeOrTimestamp } from './shared/parsers';\r\nimport Field from './field';\r\n\r\nexport default class DatetimeField extends Field {\r\n  toDB(value: unknown) {\r\n    return parseDateTimeOrTimestamp(value);\r\n  }\r\n\r\n  fromDB(value: unknown) {\r\n    const cast = new Date(value as any);\r\n    return dateFns.isValid(cast) ? cast.toISOString() : null;\r\n  }\r\n}\r\n","import * as dateFns from 'date-fns';\r\n\r\nimport { parseDateTimeOrTimestamp } from './shared/parsers';\r\nimport Field from './field';\r\n\r\nexport default class TimestampField extends Field {\r\n  toDB(value: unknown) {\r\n    return parseDateTimeOrTimestamp(value);\r\n  }\r\n\r\n  fromDB(value: unknown) {\r\n    const cast = new Date(value as any);\r\n    return dateFns.isValid(cast) ? dateFns.format(cast, 'T') : null;\r\n  }\r\n}\r\n","import { toString } from 'lodash/fp';\r\nimport Field from './field';\r\n\r\nfunction isStringOrNumber(value: unknown): value is string | number {\r\n  return typeof value === 'string' || typeof value === 'number';\r\n}\r\n\r\nexport default class BooleanField extends Field {\r\n  toDB(value: unknown) {\r\n    if (typeof value === 'boolean') {\r\n      return value;\r\n    }\r\n\r\n    if (isStringOrNumber(value) && ['true', 't', '1', 1].includes(value)) {\r\n      return true;\r\n    }\r\n\r\n    if (isStringOrNumber(value) && ['false', 'f', '0', 0].includes(value)) {\r\n      return false;\r\n    }\r\n\r\n    return Boolean(value);\r\n  }\r\n\r\n  fromDB(value: unknown) {\r\n    if (typeof value === 'boolean') {\r\n      return value;\r\n    }\r\n\r\n    const strVal = toString(value);\r\n\r\n    if (strVal === '1') {\r\n      return true;\r\n    }\r\n    if (strVal === '0') {\r\n      return false;\r\n    }\r\n    return null;\r\n  }\r\n}\r\n","import _ from 'lodash/fp';\r\n\r\nimport Field from './field';\r\nimport StringField from './string';\r\nimport JSONField from './json';\r\nimport BigIntegerField from './biginteger';\r\nimport NumberField from './number';\r\nimport DateField from './date';\r\nimport TimeField from './time';\r\nimport DatetimeField from './datetime';\r\nimport TimestampField from './timestamp';\r\nimport BooleanField from './boolean';\r\n\r\nimport type { Attribute } from '../types';\r\n\r\nconst typeToFieldMap: Record<string, typeof Field> = {\r\n  increments: Field,\r\n  password: StringField,\r\n  email: StringField,\r\n  string: StringField,\r\n  uid: StringField,\r\n  richtext: StringField,\r\n  text: StringField,\r\n  enumeration: StringField,\r\n  json: JSONField,\r\n  biginteger: BigIntegerField,\r\n  integer: NumberField,\r\n  float: NumberField,\r\n  decimal: NumberField,\r\n  date: DateField,\r\n  time: TimeField,\r\n  datetime: DatetimeField,\r\n  timestamp: TimestampField,\r\n  boolean: BooleanField,\r\n  blocks: JSONField,\r\n};\r\n\r\nexport const createField = (attribute: Attribute): Field => {\r\n  const { type } = attribute;\r\n\r\n  if (_.has(type, typeToFieldMap)) {\r\n    return new typeToFieldMap[type]({});\r\n  }\r\n\r\n  throw new Error(`Undefined field for type ${type}`);\r\n};\r\n","import { AsyncLocalStorage } from 'node:async_hooks';\r\nimport { Knex } from 'knex';\r\n\r\nexport type Callback = (...args: any[]) => Promise<any> | any;\r\n\r\nexport interface TransactionObject {\r\n  commit: () => Promise<void>;\r\n  rollback: () => Promise<void>;\r\n  get: () => Knex.Transaction;\r\n}\r\nexport interface Store {\r\n  trx: Knex.Transaction | null;\r\n  commitCallbacks: Callback[];\r\n  rollbackCallbacks: Callback[];\r\n}\r\n\r\nconst storage = new AsyncLocalStorage<Store>();\r\n\r\nconst transactionCtx = {\r\n  async run<TCallback extends Callback>(trx: Knex.Transaction, cb: TCallback) {\r\n    const store = storage.getStore();\r\n    return storage.run<ReturnType<TCallback>, void[]>(\r\n      {\r\n        trx,\r\n        // Fill with existing callbacks if nesting transactions\r\n        commitCallbacks: store?.commitCallbacks || [],\r\n        rollbackCallbacks: store?.rollbackCallbacks || [],\r\n      },\r\n      cb\r\n    );\r\n  },\r\n\r\n  get() {\r\n    const store = storage.getStore();\r\n    return store?.trx;\r\n  },\r\n\r\n  async commit(trx: Knex.Transaction) {\r\n    const store = storage.getStore();\r\n\r\n    // Clear transaction from store\r\n    if (store?.trx) {\r\n      store.trx = null;\r\n    }\r\n\r\n    // Commit transaction\r\n    await trx.commit();\r\n\r\n    if (!store?.commitCallbacks.length) {\r\n      return;\r\n    }\r\n\r\n    // Run callbacks\r\n    store.commitCallbacks.forEach((cb) => cb());\r\n    store.commitCallbacks = [];\r\n  },\r\n\r\n  async rollback(trx: Knex.Transaction) {\r\n    const store = storage.getStore();\r\n\r\n    // Clear transaction from store\r\n    if (store?.trx) {\r\n      store.trx = null;\r\n    }\r\n\r\n    // Rollback transaction\r\n    await trx.rollback();\r\n\r\n    if (!store?.rollbackCallbacks.length) {\r\n      return;\r\n    }\r\n\r\n    // Run callbacks\r\n    store.rollbackCallbacks.forEach((cb) => cb());\r\n    store.rollbackCallbacks = [];\r\n  },\r\n\r\n  onCommit(cb: Callback) {\r\n    const store = storage.getStore();\r\n    if (store?.commitCallbacks) {\r\n      store.commitCallbacks.push(cb);\r\n    }\r\n  },\r\n\r\n  onRollback(cb: Callback) {\r\n    const store = storage.getStore();\r\n    if (store?.rollbackCallbacks) {\r\n      store.rollbackCallbacks.push(cb);\r\n    }\r\n  },\r\n};\r\n\r\nexport { transactionCtx };\r\n","import type { Knex } from 'knex';\r\n\r\nimport KnexBuilder from 'knex/lib/query/querybuilder';\r\nimport KnexRaw from 'knex/lib/raw';\r\n\r\nimport type { Database } from '..';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function isKnexQuery(value: unknown): value is Knex.Raw | Knex.QueryBuilder {\r\n  return value instanceof KnexBuilder || value instanceof KnexRaw;\r\n}\r\n\r\n/**\r\n * Adds the name of the schema to the table name if the schema was defined by the user.\r\n * Users can set the db schema only for Postgres in strapi database config.\r\n */\r\nexport const addSchema = (db: Database, tableName: string): string => {\r\n  const schemaName = db.getSchemaName();\r\n  return schemaName ? `${schemaName}.${tableName}` : tableName;\r\n};\r\n","import _ from 'lodash/fp';\r\n\r\nimport * as types from '../../utils/types';\r\nimport { createField } from '../../fields';\r\n\r\nimport type { Meta } from '../../metadata';\r\n\r\ntype Row = Record<string, unknown> | null;\r\nexport type Rec = Record<string, unknown> | null;\r\n\r\nconst fromSingleRow = (meta: Meta, row: Row): Rec => {\r\n  const { attributes } = meta;\r\n\r\n  if (_.isNil(row)) {\r\n    return null;\r\n  }\r\n\r\n  const obj: Rec = {};\r\n\r\n  for (const column in row) {\r\n    if (!_.has(column, meta.columnToAttribute)) {\r\n      continue;\r\n    }\r\n\r\n    const attributeName = meta.columnToAttribute[column];\r\n    const attribute = attributes[attributeName];\r\n\r\n    if (types.isScalar(attribute.type)) {\r\n      const field = createField(attribute);\r\n\r\n      const val = row[column] === null ? null : field.fromDB(row[column]);\r\n\r\n      obj[attributeName] = val;\r\n    }\r\n\r\n    if (types.isRelation(attribute.type)) {\r\n      obj[attributeName] = row[column];\r\n    }\r\n  }\r\n\r\n  return obj;\r\n};\r\n\r\nconst fromRow = (meta: Meta, row: Row | Row[] | undefined) => {\r\n  if (_.isNil(row)) {\r\n    return null;\r\n  }\r\n\r\n  if (Array.isArray(row)) {\r\n    return row.map((singleRow) => fromSingleRow(meta, singleRow));\r\n  }\r\n\r\n  return fromSingleRow(meta, row);\r\n};\r\n\r\nconst toSingleRow = (meta: Meta, data: Rec = {}): Row => {\r\n  if (_.isNil(data)) {\r\n    return data;\r\n  }\r\n\r\n  const { attributes } = meta;\r\n\r\n  for (const key of Object.keys(data)) {\r\n    const attribute = attributes[key];\r\n\r\n    if (\r\n      !attribute ||\r\n      !('columnName' in attribute) ||\r\n      !attribute.columnName ||\r\n      attribute.columnName === key\r\n    ) {\r\n      continue;\r\n    }\r\n\r\n    data[attribute.columnName] = data[key];\r\n    delete data[key];\r\n  }\r\n\r\n  return data;\r\n};\r\n\r\nfunction toRow<TData extends Rec | Rec[] | null>(\r\n  meta: Meta,\r\n  data: TData\r\n): TData extends null ? null : TData extends Rec[] ? Row[] : Rec;\r\nfunction toRow(meta: Meta, data: Rec | Rec[] | null): Row | Row[] | null {\r\n  if (_.isNil(data)) {\r\n    return data;\r\n  }\r\n\r\n  if (_.isArray(data)) {\r\n    return data.map((datum) => toSingleRow(meta, datum));\r\n  }\r\n\r\n  return toSingleRow(meta, data);\r\n}\r\n\r\nconst toColumnName = (meta: Meta, name: null | string) => {\r\n  if (!name) {\r\n    throw new Error('Name cannot be null');\r\n  }\r\n\r\n  const attribute = meta.attributes[name];\r\n\r\n  if (!attribute) {\r\n    return name;\r\n  }\r\n\r\n  return ('columnName' in attribute && attribute.columnName) || name;\r\n};\r\n\r\nexport { toRow, fromRow, toColumnName };\r\n","import _ from 'lodash/fp';\r\nimport type { Knex } from 'knex';\r\n\r\nimport * as types from '../../utils/types';\r\nimport { toColumnName } from './transform';\r\nimport type { Ctx } from '../types';\r\n\r\nexport const applySearch = (knex: Knex.QueryBuilder, query: string, ctx: Ctx) => {\r\n  const { qb, uid, db } = ctx;\r\n  const meta = db.metadata.get(uid);\r\n\r\n  const { attributes } = meta;\r\n\r\n  const searchColumns = ['id'];\r\n\r\n  const stringColumns = Object.keys(attributes).filter((attributeName) => {\r\n    const attribute = attributes[attributeName];\r\n    return (\r\n      types.isScalarAttribute(attribute) &&\r\n      types.isString(attribute.type) &&\r\n      attribute.searchable !== false\r\n    );\r\n  });\r\n\r\n  searchColumns.push(...stringColumns);\r\n\r\n  if (!_.isNaN(_.toNumber(query))) {\r\n    const numberColumns = Object.keys(attributes).filter((attributeName) => {\r\n      const attribute = attributes[attributeName];\r\n      return (\r\n        types.isScalarAttribute(attribute) &&\r\n        types.isNumber(attribute.type) &&\r\n        attribute.searchable !== false\r\n      );\r\n    });\r\n\r\n    searchColumns.push(...numberColumns);\r\n  }\r\n\r\n  switch (db.dialect.client) {\r\n    case 'postgres': {\r\n      searchColumns.forEach((attr) => {\r\n        const columnName = toColumnName(meta, attr);\r\n        return knex.orWhereRaw(`??::text ILIKE ?`, [\r\n          qb.aliasColumn(columnName),\r\n          `%${escapeQuery(query, '*%\\\\')}%`,\r\n        ]);\r\n      });\r\n\r\n      break;\r\n    }\r\n    case 'sqlite': {\r\n      searchColumns.forEach((attr) => {\r\n        const columnName = toColumnName(meta, attr);\r\n        return knex.orWhereRaw(`?? LIKE ? ESCAPE '\\\\'`, [\r\n          qb.aliasColumn(columnName),\r\n          `%${escapeQuery(query, '*%\\\\')}%`,\r\n        ]);\r\n      });\r\n      break;\r\n    }\r\n    case 'mysql': {\r\n      searchColumns.forEach((attr) => {\r\n        const columnName = toColumnName(meta, attr);\r\n        return knex.orWhereRaw(`?? LIKE ?`, [\r\n          qb.aliasColumn(columnName),\r\n          `%${escapeQuery(query, '*%\\\\')}%`,\r\n        ]);\r\n      });\r\n      break;\r\n    }\r\n    default: {\r\n      // do nothing\r\n    }\r\n  }\r\n};\r\n\r\nconst escapeQuery = (query: string, charsToEscape: string, escapeChar = '\\\\') => {\r\n  return query\r\n    .split('')\r\n    .reduce(\r\n      (escapedQuery, char) =>\r\n        charsToEscape.includes(char)\r\n          ? `${escapedQuery}${escapeChar}${char}`\r\n          : `${escapedQuery}${char}`,\r\n      ''\r\n    );\r\n};\r\n","import type { Knex } from 'knex';\r\nimport type { Ctx } from '../types';\r\n\r\nexport interface Join {\r\n  method?: 'leftJoin' | 'innerJoin';\r\n  alias: string;\r\n  referencedTable: string;\r\n  referencedColumn: string;\r\n  rootColumn: string;\r\n  rootTable?: string;\r\n  on?: Record<string, any>;\r\n  orderBy?: Record<string, 'asc' | 'desc'>;\r\n}\r\n\r\ninterface JoinOptions {\r\n  alias: string;\r\n  refAlias?: string;\r\n  attributeName: string;\r\n  attribute: any;\r\n}\r\n\r\ninterface PivotJoinOptions {\r\n  alias: string;\r\n  refAlias?: string;\r\n  joinTable: any;\r\n  targetMeta: any;\r\n}\r\n\r\nconst createPivotJoin = (\r\n  ctx: Ctx,\r\n  { alias, refAlias, joinTable, targetMeta }: PivotJoinOptions\r\n) => {\r\n  const { qb } = ctx;\r\n  const joinAlias = qb.getAlias();\r\n  qb.join({\r\n    alias: joinAlias,\r\n    referencedTable: joinTable.name,\r\n    referencedColumn: joinTable.joinColumn.name,\r\n    rootColumn: joinTable.joinColumn.referencedColumn,\r\n    rootTable: alias,\r\n    on: joinTable.on,\r\n  });\r\n\r\n  const subAlias = refAlias || qb.getAlias();\r\n  qb.join({\r\n    alias: subAlias,\r\n    referencedTable: targetMeta.tableName,\r\n    referencedColumn: joinTable.inverseJoinColumn.referencedColumn,\r\n    rootColumn: joinTable.inverseJoinColumn.name,\r\n    rootTable: joinAlias,\r\n  });\r\n\r\n  return subAlias;\r\n};\r\n\r\nconst createJoin = (ctx: Ctx, { alias, refAlias, attributeName, attribute }: JoinOptions) => {\r\n  const { db, qb, uid } = ctx;\r\n\r\n  if (attribute.type !== 'relation') {\r\n    throw new Error(`Cannot join on non relational field ${attributeName}`);\r\n  }\r\n\r\n  const targetMeta = db.metadata.get(attribute.target);\r\n\r\n  if (['morphOne', 'morphMany'].includes(attribute.relation)) {\r\n    const targetAttribute = targetMeta.attributes[attribute.morphBy];\r\n\r\n    // @ts-expect-error - morphBy is not defined on the attribute\r\n    const { joinTable, morphColumn } = targetAttribute;\r\n\r\n    if (morphColumn) {\r\n      const subAlias = refAlias || qb.getAlias();\r\n\r\n      qb.join({\r\n        alias: subAlias,\r\n        referencedTable: targetMeta.tableName,\r\n        referencedColumn: morphColumn.idColumn.name,\r\n        rootColumn: morphColumn.idColumn.referencedColumn,\r\n        rootTable: alias,\r\n        on: {\r\n          [morphColumn.typeColumn.name]: uid,\r\n          ...morphColumn.on,\r\n        },\r\n      });\r\n\r\n      return subAlias;\r\n    }\r\n\r\n    if (joinTable) {\r\n      const joinAlias = qb.getAlias();\r\n\r\n      qb.join({\r\n        alias: joinAlias,\r\n        referencedTable: joinTable.name,\r\n        referencedColumn: joinTable.morphColumn.idColumn.name,\r\n        rootColumn: joinTable.morphColumn.idColumn.referencedColumn,\r\n        rootTable: alias,\r\n        on: {\r\n          [joinTable.morphColumn.typeColumn.name]: uid,\r\n          field: attributeName,\r\n        },\r\n      });\r\n\r\n      const subAlias = refAlias || qb.getAlias();\r\n\r\n      qb.join({\r\n        alias: subAlias,\r\n        referencedTable: targetMeta.tableName,\r\n        referencedColumn: joinTable.joinColumn.referencedColumn,\r\n        rootColumn: joinTable.joinColumn.name,\r\n        rootTable: joinAlias,\r\n      });\r\n\r\n      return subAlias;\r\n    }\r\n\r\n    return alias;\r\n  }\r\n\r\n  const { joinColumn } = attribute;\r\n\r\n  if (joinColumn) {\r\n    const subAlias = refAlias || qb.getAlias();\r\n    qb.join({\r\n      alias: subAlias,\r\n      referencedTable: targetMeta.tableName,\r\n      referencedColumn: joinColumn.referencedColumn,\r\n      rootColumn: joinColumn.name,\r\n      rootTable: alias,\r\n    });\r\n    return subAlias;\r\n  }\r\n\r\n  const { joinTable } = attribute;\r\n  if (joinTable) {\r\n    return createPivotJoin(ctx, { alias, refAlias, joinTable, targetMeta });\r\n  }\r\n\r\n  return alias;\r\n};\r\n\r\n// TODO: toColumnName for orderBy & on\r\nconst applyJoin = (qb: Knex.QueryBuilder, join: Join) => {\r\n  const {\r\n    method = 'leftJoin',\r\n    alias,\r\n    referencedTable,\r\n    referencedColumn,\r\n    rootColumn,\r\n    // FIXME: qb.alias can't exist here\r\n    rootTable, // = qb.alias\r\n    on,\r\n    orderBy,\r\n  } = join;\r\n\r\n  qb[method](`${referencedTable} as ${alias}`, (inner) => {\r\n    inner.on(`${rootTable}.${rootColumn}`, `${alias}.${referencedColumn}`);\r\n\r\n    if (on) {\r\n      for (const key of Object.keys(on)) {\r\n        inner.onVal(`${alias}.${key}`, on[key]);\r\n      }\r\n    }\r\n  });\r\n\r\n  if (orderBy) {\r\n    Object.keys(orderBy).forEach((column) => {\r\n      const direction = orderBy[column];\r\n      qb.orderBy(`${alias}.${column}`, direction);\r\n    });\r\n  }\r\n};\r\n\r\nconst applyJoins = (qb: Knex.QueryBuilder, joins: Join[]) => {\r\n  return joins.forEach((join) => applyJoin(qb, join));\r\n};\r\n\r\nexport { createJoin, createPivotJoin, applyJoins, applyJoin };\r\n","import _ from 'lodash/fp';\r\nimport knex from 'knex';\r\n\r\nimport * as types from '../../utils/types';\r\nimport { createJoin } from './join';\r\nimport { toColumnName } from './transform';\r\n\r\nimport type { Ctx } from '../types';\r\n\r\ntype OrderByCtx = Ctx & { alias?: string };\r\ntype OrderBy = string | { [key: string]: 'asc' | 'desc' } | OrderBy[];\r\ntype OrderByValue = { column: string; order?: 'asc' | 'desc' };\r\n\r\nconst COL_STRAPI_ROW_NUMBER = '__strapi_row_number';\r\nconst COL_STRAPI_ORDER_BY_PREFIX = '__strapi_order_by';\r\n\r\nexport const processOrderBy = (orderBy: OrderBy, ctx: OrderByCtx): OrderByValue[] => {\r\n  const { db, uid, qb, alias } = ctx;\r\n  const meta = db.metadata.get(uid);\r\n  const { attributes } = meta;\r\n\r\n  if (typeof orderBy === 'string') {\r\n    const attribute = attributes[orderBy];\r\n\r\n    if (!attribute) {\r\n      throw new Error(`Attribute ${orderBy} not found on model ${uid}`);\r\n    }\r\n\r\n    const columnName = toColumnName(meta, orderBy);\r\n\r\n    return [{ column: qb.aliasColumn(columnName, alias) }];\r\n  }\r\n\r\n  if (Array.isArray(orderBy)) {\r\n    return orderBy.flatMap((value) => processOrderBy(value, ctx));\r\n  }\r\n\r\n  if (_.isPlainObject(orderBy)) {\r\n    return Object.entries(orderBy).flatMap(([key, direction]) => {\r\n      const value = orderBy[key];\r\n      const attribute = attributes[key];\r\n\r\n      if (!attribute) {\r\n        throw new Error(`Attribute ${key} not found on model ${uid}`);\r\n      }\r\n\r\n      if (types.isScalar(attribute.type)) {\r\n        const columnName = toColumnName(meta, key);\r\n\r\n        return { column: qb.aliasColumn(columnName, alias), order: direction };\r\n      }\r\n\r\n      if (attribute.type === 'relation' && 'target' in attribute) {\r\n        const subAlias = createJoin(ctx, {\r\n          alias: alias || qb.alias,\r\n          attributeName: key,\r\n          attribute,\r\n        });\r\n\r\n        return processOrderBy(value, {\r\n          db,\r\n          qb,\r\n          alias: subAlias,\r\n          uid: attribute.target,\r\n        });\r\n      }\r\n\r\n      throw new Error(`You cannot order on ${attribute.type} types`);\r\n    });\r\n  }\r\n\r\n  throw new Error('Invalid orderBy syntax');\r\n};\r\n\r\nexport const getStrapiOrderColumnAlias = (column: string) => {\r\n  const trimmedColumnName = column.replaceAll('.', '_');\r\n\r\n  return `${COL_STRAPI_ORDER_BY_PREFIX}__${trimmedColumnName}`;\r\n};\r\n\r\n/**\r\n * Wraps the original Knex query with deep sorting functionality.\r\n *\r\n * The function takes an original query and an OrderByCtx object as parameters and returns a new Knex query with deep sorting applied.\r\n */\r\nexport const wrapWithDeepSort = (originalQuery: knex.Knex.QueryBuilder, ctx: OrderByCtx) => {\r\n  /**\r\n   * Notes:\r\n   * - The generated query has the following flow: baseQuery (filtered unsorted data) -> T (partitioned/sorted data) --> resultQuery (distinct, paginated, sorted data)\r\n   * - Pagination and selection are transferred from the original query to the outer one to avoid pruning rows too early\r\n   * - Filtering (where) has to be done in the deepest sub query possible to avoid processing invalid rows and corrupting the final results\r\n   * - We assume that all necessary joins are done in the original query (`originalQuery`), and every needed column is available with the right name and alias.\r\n   */\r\n\r\n  const { db, qb, uid } = ctx;\r\n\r\n  const { tableName } = db.metadata.get(uid);\r\n\r\n  // The orderBy is cloned to avoid unwanted mutations of the original object\r\n  const orderBy = _.cloneDeep<OrderByValue[]>(qb.state.orderBy);\r\n\r\n  // 0. Init a new Knex query instance (referenced as resultQuery) using the DB connection\r\n  //    The connection reuse the original table name (aliased if needed)\r\n  const resultQueryAlias = qb.getAlias();\r\n  const aliasedTableName = qb.mustUseAlias() ? alias(resultQueryAlias, tableName) : tableName;\r\n\r\n  const resultQuery = db.getConnection(aliasedTableName);\r\n\r\n  // 1. Clone the original query to create the sub-query (referenced as baseQuery) and avoid any mutation on the initial object\r\n  const baseQuery = originalQuery.clone();\r\n  const baseQueryAlias = qb.getAlias();\r\n\r\n  // Clear unwanted statements from the sub-query 'baseQuery'\r\n  // Note: `first()` is cleared through the combination of `baseQuery.clear('limit')` and calling `baseQuery.select(...)` again\r\n  // Note: Those statements will be re-applied when duplicates are removed from the final selection\r\n  baseQuery\r\n    // Columns selection\r\n    .clear('select')\r\n    // Pagination and sorting\r\n    .clear('order')\r\n    .clear('limit')\r\n    .clear('offset');\r\n\r\n  // Override the initial select and return only the columns needed for the partitioning.\r\n  baseQuery.select(\r\n    // Always select the row id for future manipulation\r\n    prefix(qb.alias, 'id'),\r\n    // Select every column used in an order by clause, but alias it for future reference\r\n    // i.e. if t2.name is present in an order by clause:\r\n    //      Then, \"t2.name\" will become \"t2.name as __strapi_order_by__t2_name\"\r\n    ...orderBy.map((orderByClause) =>\r\n      alias(getStrapiOrderColumnAlias(orderByClause.column), orderByClause.column)\r\n    )\r\n  );\r\n\r\n  // 2. Create a sub-query callback to extract and sort the partitions using row number\r\n  const partitionedQueryAlias = qb.getAlias();\r\n\r\n  const selectRowsAsNumberedPartitions = (partitionedQuery: knex.Knex.QueryBuilder) => {\r\n    // Transform order by clause to their alias to reference them from baseQuery\r\n    const prefixedOrderBy = orderBy.map((orderByClause) => ({\r\n      column: prefix(baseQueryAlias, getStrapiOrderColumnAlias(orderByClause.column)),\r\n      order: orderByClause.order,\r\n    }));\r\n\r\n    // partitionedQuery select must contain every column used for sorting\r\n    const orderByColumns = prefixedOrderBy.map<string>(_.prop('column'));\r\n\r\n    partitionedQuery\r\n      .select(\r\n        // Always select baseQuery.id\r\n        prefix(baseQueryAlias, 'id'),\r\n        // Sort columns\r\n        ...orderByColumns\r\n      )\r\n      // The row number is used to assign an index to every row in every partition\r\n      .rowNumber(COL_STRAPI_ROW_NUMBER, (subQuery) => {\r\n        for (const orderByClause of prefixedOrderBy) {\r\n          subQuery.orderBy(orderByClause.column, orderByClause.order, 'last');\r\n        }\r\n\r\n        // And each partition/group is created based on baseQuery.id\r\n        subQuery.partitionBy(`${baseQueryAlias}.id`);\r\n      })\r\n      .from(baseQuery.as(baseQueryAlias))\r\n      .as(partitionedQueryAlias);\r\n  };\r\n\r\n  // 3. Create the final resultQuery query, that select and sort the wanted data using T\r\n\r\n  const originalSelect = _.difference(\r\n    qb.state.select,\r\n    // Remove order by columns from the initial select\r\n    qb.state.orderBy.map(_.prop('column'))\r\n  )\r\n    // Alias everything in resultQuery\r\n    .map(prefix(resultQueryAlias));\r\n\r\n  resultQuery\r\n    .select(originalSelect)\r\n    // Join T to resultQuery to access sorted data\r\n    // Notes:\r\n    // - Only select the first row for each partition\r\n    // - Since we're applying the \"where\" statement directly on baseQuery (and not on resultQuery), we're using an inner join to avoid unwanted rows\r\n    .innerJoin(selectRowsAsNumberedPartitions, function () {\r\n      this\r\n        // Only select rows that are returned by T\r\n        .on(`${partitionedQueryAlias}.id`, `${resultQueryAlias}.id`)\r\n        // By only selecting the rows number equal to 1, we make sure we don't have duplicate, and that\r\n        // we're selecting rows in the correct order amongst the groups created by the \"partition by\"\r\n        .andOnVal(`${partitionedQueryAlias}.${COL_STRAPI_ROW_NUMBER}`, '=', 1);\r\n    });\r\n\r\n  // Re-apply pagination params\r\n\r\n  if (qb.state.limit) {\r\n    resultQuery.limit(qb.state.limit);\r\n  }\r\n\r\n  if (qb.state.offset) {\r\n    resultQuery.offset(qb.state.offset);\r\n  }\r\n\r\n  if (qb.state.first) {\r\n    resultQuery.first();\r\n  }\r\n\r\n  // Re-apply the sort using T values\r\n  resultQuery.orderBy([\r\n    // Transform \"order by\" clause to their T alias and prefix them with T alias\r\n    ...orderBy.map((orderByClause) => ({\r\n      column: prefix(partitionedQueryAlias, getStrapiOrderColumnAlias(orderByClause.column)),\r\n      order: orderByClause.order,\r\n    })),\r\n    // Add T.id to the order by clause to get consistent results in case several rows have the exact same order\r\n    { column: `${partitionedQueryAlias}.id`, order: 'asc' },\r\n  ]);\r\n\r\n  return resultQuery;\r\n};\r\n\r\n// Utils\r\nconst alias = _.curry((alias: string, value: string) => `${value} as ${alias}`);\r\nconst prefix = _.curry((prefix: string, value: string) => `${prefix}.${value}`);\r\n","import _ from 'lodash/fp';\r\n\r\nimport { fromRow } from '../transform';\r\nimport type { QueryBuilder } from '../../query-builder';\r\nimport type { Database } from '../../..';\r\nimport type { Meta } from '../../../metadata';\r\nimport { ID, RelationalAttribute, Relation } from '../../../types';\r\n\r\n// We must select the join column id, however whatever it is named will overwrite an attribute of the same name\r\n// Therefore, we will prefix with something unlikely to conflict with a user attribute\r\n// TODO: ...and completely restrict the strapi_ prefix for an attribute name in the future\r\nconst joinColPrefix = '__strapi' as const;\r\n\r\ntype Context = {\r\n  db: Database;\r\n  qb: QueryBuilder;\r\n  uid: string;\r\n};\r\n\r\ntype Input<TRelationAttribute extends RelationalAttribute = RelationalAttribute> = {\r\n  attribute: TRelationAttribute;\r\n  attributeName: string;\r\n  results: Row[];\r\n  populateValue: {\r\n    on?: Record<string, Record<string, unknown>>;\r\n  } & Record<string, unknown>;\r\n\r\n  isCount: boolean;\r\n};\r\n\r\ntype InputWithTarget<TRelationAttribute extends RelationalAttribute = RelationalAttribute> =\r\n  Input<TRelationAttribute> & {\r\n    targetMeta: Meta;\r\n  };\r\n\r\ntype MorphIdMap = Record<string, Record<ID, Row[]>>;\r\n\r\ntype Row = Record<string, unknown>;\r\n\r\n/**\r\n * Populate oneToOne and manyToOne relation\r\n * @param {*} input\r\n * @param {*} ctx\r\n * @returns\r\n */\r\nconst XtoOne = async (\r\n  input: InputWithTarget<Relation.OneToOne | Relation.ManyToOne>,\r\n  ctx: Context\r\n) => {\r\n  const { attribute, attributeName, results, populateValue, targetMeta, isCount } = input;\r\n  const { db, qb } = ctx;\r\n\r\n  const fromTargetRow = (rowOrRows: Row | Row[] | undefined) => fromRow(targetMeta, rowOrRows);\r\n\r\n  if ('joinColumn' in attribute && attribute.joinColumn) {\r\n    const { name: joinColumnName, referencedColumn: referencedColumnName } = attribute.joinColumn;\r\n\r\n    const referencedValues = _.uniq(\r\n      results.map((r) => r[joinColumnName]).filter((value) => !_.isNil(value))\r\n    );\r\n\r\n    if (_.isEmpty(referencedValues)) {\r\n      results.forEach((result) => {\r\n        result[attributeName] = null;\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    const rows = await db.entityManager\r\n      .createQueryBuilder(targetMeta.uid)\r\n      .init(populateValue)\r\n      .addSelect(`${qb.alias}.${referencedColumnName}`)\r\n      .where({ [referencedColumnName]: referencedValues })\r\n      .execute<Row[]>({ mapResults: false });\r\n\r\n    const map = _.groupBy<Row[]>(referencedColumnName)(rows);\r\n\r\n    results.forEach((result) => {\r\n      result[attributeName] = fromTargetRow(_.first(map[result[joinColumnName] as string]));\r\n    });\r\n\r\n    return;\r\n  }\r\n\r\n  if ('joinTable' in attribute && attribute.joinTable) {\r\n    const { joinTable } = attribute;\r\n\r\n    const qb = db.entityManager.createQueryBuilder(targetMeta.uid);\r\n\r\n    const { name: joinColumnName, referencedColumn: referencedColumnName } = joinTable.joinColumn;\r\n\r\n    const alias = qb.getAlias();\r\n    const joinColAlias = `${alias}.${joinColumnName}`;\r\n    const joinColRenameAs = `${joinColPrefix}${joinColumnName}`;\r\n    const joinColSelect = `${joinColAlias} as ${joinColRenameAs}`;\r\n\r\n    const referencedValues = _.uniq(\r\n      results.map((r) => r[referencedColumnName]).filter((value) => !_.isNil(value))\r\n    );\r\n\r\n    if (isCount) {\r\n      if (_.isEmpty(referencedValues)) {\r\n        results.forEach((result) => {\r\n          result[attributeName] = { count: 0 };\r\n        });\r\n        return;\r\n      }\r\n\r\n      const rows = await qb\r\n        .init(populateValue)\r\n        .join({\r\n          alias,\r\n          referencedTable: joinTable.name,\r\n          referencedColumn: joinTable.inverseJoinColumn.name,\r\n          rootColumn: joinTable.inverseJoinColumn.referencedColumn,\r\n          rootTable: qb.alias,\r\n          on: joinTable.on,\r\n        })\r\n        .select([joinColAlias, qb.raw('count(*) AS count')])\r\n        .where({ [joinColAlias]: referencedValues })\r\n        .groupBy(joinColAlias)\r\n        .execute<Array<{ count: number } & { [key: string]: string }>>({ mapResults: false });\r\n\r\n      const map = rows.reduce(\r\n        (map, row) => {\r\n          map[row[joinColumnName]] = { count: Number(row.count) };\r\n          return map;\r\n        },\r\n        {} as Record<string, { count: number }>\r\n      );\r\n\r\n      results.forEach((result) => {\r\n        result[attributeName] = map[result[referencedColumnName] as string] || { count: 0 };\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    if (_.isEmpty(referencedValues)) {\r\n      results.forEach((result) => {\r\n        result[attributeName] = null;\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    const rows = await qb\r\n      .init(populateValue)\r\n      .join({\r\n        alias,\r\n        referencedTable: joinTable.name,\r\n        referencedColumn: joinTable.inverseJoinColumn.name,\r\n        rootColumn: joinTable.inverseJoinColumn.referencedColumn,\r\n        rootTable: qb.alias,\r\n        on: joinTable.on,\r\n        orderBy: joinTable.orderBy,\r\n      })\r\n      .addSelect(joinColSelect)\r\n      .where({ [joinColAlias]: referencedValues })\r\n      .execute<Row[]>({ mapResults: false });\r\n\r\n    const map = _.groupBy<Row>(joinColRenameAs)(rows);\r\n\r\n    results.forEach((result) => {\r\n      result[attributeName] = fromTargetRow(_.first(map[result[referencedColumnName] as string]));\r\n    });\r\n  }\r\n};\r\n\r\nconst oneToMany = async (input: InputWithTarget<Relation.OneToMany>, ctx: Context) => {\r\n  const { attribute, attributeName, results, populateValue, targetMeta, isCount } = input;\r\n  const { db, qb } = ctx;\r\n\r\n  const fromTargetRow = (rowOrRows: Row | Row[] | undefined) => fromRow(targetMeta, rowOrRows);\r\n\r\n  if ('joinColumn' in attribute && attribute.joinColumn) {\r\n    const {\r\n      name: joinColumnName,\r\n      referencedColumn: referencedColumnName,\r\n      on,\r\n    } = attribute.joinColumn;\r\n\r\n    const referencedValues = _.uniq(\r\n      results.map((r) => r[joinColumnName]).filter((value) => !_.isNil(value))\r\n    );\r\n\r\n    if (_.isEmpty(referencedValues)) {\r\n      results.forEach((result) => {\r\n        result[attributeName] = null;\r\n      });\r\n      return;\r\n    }\r\n\r\n    const rows = await db.entityManager\r\n      .createQueryBuilder(targetMeta.uid)\r\n      .init(populateValue)\r\n      .addSelect(`${qb.alias}.${referencedColumnName}`)\r\n      .where({\r\n        [referencedColumnName]: referencedValues,\r\n        ...(on && typeof on === 'function' ? on({ populateValue, results }) : {}),\r\n      })\r\n      .execute<Row[]>({ mapResults: false });\r\n\r\n    const map = _.groupBy<Row>(referencedColumnName)(rows);\r\n\r\n    results.forEach((result) => {\r\n      result[attributeName] = fromTargetRow(map[result[joinColumnName] as string] || []);\r\n    });\r\n\r\n    return;\r\n  }\r\n\r\n  if ('joinTable' in attribute && attribute.joinTable) {\r\n    const { joinTable } = attribute;\r\n\r\n    const qb = db.entityManager.createQueryBuilder(targetMeta.uid);\r\n\r\n    const { name: joinColumnName, referencedColumn: referencedColumnName } = joinTable.joinColumn;\r\n\r\n    const alias = qb.getAlias();\r\n    const joinColAlias = `${alias}.${joinColumnName}`;\r\n    const joinColRenameAs = `${joinColPrefix}${joinColumnName}`;\r\n    const joinColSelect = `${joinColAlias} as ${joinColRenameAs}`;\r\n\r\n    const referencedValues = _.uniq(\r\n      results.map((r) => r[referencedColumnName]).filter((value) => !_.isNil(value))\r\n    );\r\n\r\n    if (isCount) {\r\n      if (_.isEmpty(referencedValues)) {\r\n        results.forEach((result) => {\r\n          result[attributeName] = { count: 0 };\r\n        });\r\n        return;\r\n      }\r\n\r\n      const rows = await qb\r\n        .init(populateValue)\r\n        .join({\r\n          alias,\r\n          referencedTable: joinTable.name,\r\n          referencedColumn: joinTable.inverseJoinColumn.name,\r\n          rootColumn: joinTable.inverseJoinColumn.referencedColumn,\r\n          rootTable: qb.alias,\r\n          on: joinTable.on,\r\n        })\r\n        .select([joinColSelect, qb.raw('count(*) AS count')])\r\n        .where({ [joinColAlias]: referencedValues })\r\n        .groupBy(joinColAlias)\r\n        .execute<Array<{ count: number } & { [key: string]: string }>>({ mapResults: false });\r\n\r\n      const map = rows.reduce(\r\n        (map, row) => {\r\n          map[row[joinColRenameAs]] = { count: Number(row.count) };\r\n          return map;\r\n        },\r\n        {} as Record<string, { count: number }>\r\n      );\r\n\r\n      results.forEach((result) => {\r\n        result[attributeName] = map[result[referencedColumnName] as string] || { count: 0 };\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    if (_.isEmpty(referencedValues)) {\r\n      results.forEach((result) => {\r\n        result[attributeName] = [];\r\n      });\r\n      return;\r\n    }\r\n\r\n    const rows = await qb\r\n      .init(populateValue)\r\n      .join({\r\n        alias,\r\n        referencedTable: joinTable.name,\r\n        referencedColumn: joinTable.inverseJoinColumn.name,\r\n        rootColumn: joinTable.inverseJoinColumn.referencedColumn,\r\n        rootTable: qb.alias,\r\n        on: joinTable.on,\r\n        orderBy: _.mapValues((v) => populateValue.ordering || v, joinTable.orderBy),\r\n      })\r\n      .addSelect(joinColSelect)\r\n      .where({ [joinColAlias]: referencedValues })\r\n      .execute<Row[]>({ mapResults: false });\r\n\r\n    const map = _.groupBy<Row>(joinColRenameAs)(rows);\r\n\r\n    results.forEach((r) => {\r\n      r[attributeName] = fromTargetRow(map[r[referencedColumnName] as string] || []);\r\n    });\r\n  }\r\n};\r\n\r\nconst manyToMany = async (input: InputWithTarget<Relation.ManyToMany>, ctx: Context) => {\r\n  const { attribute, attributeName, results, populateValue, targetMeta, isCount } = input;\r\n  const { db } = ctx;\r\n\r\n  const fromTargetRow = (rowOrRows: Row | Row[] | undefined) => fromRow(targetMeta, rowOrRows);\r\n\r\n  const { joinTable } = attribute;\r\n\r\n  const populateQb = db.entityManager.createQueryBuilder(targetMeta.uid);\r\n\r\n  const { name: joinColumnName, referencedColumn: referencedColumnName } = joinTable.joinColumn;\r\n\r\n  const alias = populateQb.getAlias();\r\n  const joinColAlias = `${alias}.${joinColumnName}`;\r\n  const joinColRenameAs = `${joinColPrefix}${joinColumnName}`;\r\n  const joinColSelect = `${joinColAlias} as ${joinColRenameAs}`;\r\n\r\n  const referencedValues = _.uniq(\r\n    results.map((r) => r[referencedColumnName]).filter((value) => !_.isNil(value))\r\n  );\r\n\r\n  if (isCount) {\r\n    if (_.isEmpty(referencedValues)) {\r\n      results.forEach((result) => {\r\n        result[attributeName] = { count: 0 };\r\n      });\r\n      return;\r\n    }\r\n\r\n    const rows = await populateQb\r\n      .init(populateValue)\r\n      .join({\r\n        alias,\r\n        referencedTable: joinTable.name,\r\n        referencedColumn: joinTable.inverseJoinColumn.name,\r\n        rootColumn: joinTable.inverseJoinColumn.referencedColumn,\r\n        rootTable: populateQb.alias,\r\n        on: joinTable.on,\r\n      })\r\n      .select([joinColAlias, populateQb.raw('count(*) AS count')])\r\n      .where({ [joinColAlias]: referencedValues })\r\n      .groupBy(joinColAlias)\r\n      .execute<Array<{ count: number } & { [key: string]: string }>>({ mapResults: false });\r\n\r\n    const map = rows.reduce(\r\n      (map, row) => {\r\n        map[row[joinColumnName]] = { count: Number(row.count) };\r\n        return map;\r\n      },\r\n      {} as Record<string, { count: number }>\r\n    );\r\n\r\n    results.forEach((result) => {\r\n      result[attributeName] = map[result[referencedColumnName] as string] || { count: 0 };\r\n    });\r\n\r\n    return;\r\n  }\r\n\r\n  if (_.isEmpty(referencedValues)) {\r\n    results.forEach((result) => {\r\n      result[attributeName] = [];\r\n    });\r\n    return;\r\n  }\r\n\r\n  const rows = await populateQb\r\n    .init(populateValue)\r\n    .join({\r\n      alias,\r\n      referencedTable: joinTable.name,\r\n      referencedColumn: joinTable.inverseJoinColumn.name,\r\n      rootColumn: joinTable.inverseJoinColumn.referencedColumn,\r\n      rootTable: populateQb.alias,\r\n      on: joinTable.on,\r\n      orderBy: _.mapValues((v) => populateValue.ordering || v, joinTable.orderBy),\r\n    })\r\n    .addSelect(joinColSelect)\r\n    .where({ [joinColAlias]: referencedValues })\r\n    .execute<Row[]>({ mapResults: false });\r\n\r\n  const map = _.groupBy<Row>(joinColRenameAs)(rows);\r\n\r\n  results.forEach((result) => {\r\n    result[attributeName] = fromTargetRow(map[result[referencedColumnName] as string] || []);\r\n  });\r\n};\r\n\r\nconst morphX = async (\r\n  input: InputWithTarget<Relation.MorphMany | Relation.MorphOne>,\r\n  ctx: Context\r\n) => {\r\n  const { attribute, attributeName, results, populateValue, targetMeta } = input;\r\n  const { db, uid } = ctx;\r\n\r\n  const fromTargetRow = (rowOrRows: Row | Row[] | undefined) => fromRow(targetMeta, rowOrRows);\r\n\r\n  const { target, morphBy } = attribute;\r\n\r\n  const targetAttribute = db.metadata.get(target).attributes[morphBy];\r\n\r\n  if (targetAttribute.type === 'relation' && targetAttribute.relation === 'morphToOne') {\r\n    const { idColumn, typeColumn } = targetAttribute.morphColumn;\r\n\r\n    const referencedValues = _.uniq(\r\n      results.map((r) => r[idColumn.referencedColumn]).filter((value) => !_.isNil(value))\r\n    );\r\n\r\n    if (_.isEmpty(referencedValues)) {\r\n      results.forEach((result) => {\r\n        result[attributeName] = null;\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    const rows = await db.entityManager\r\n      .createQueryBuilder(target)\r\n      .init(populateValue)\r\n      // .addSelect(`${qb.alias}.${idColumn.referencedColumn}`)\r\n      .where({ [idColumn.name]: referencedValues, [typeColumn.name]: uid })\r\n      .execute<Row>({ mapResults: false });\r\n\r\n    const map = _.groupBy<Row>(idColumn.name)(rows);\r\n\r\n    results.forEach((result) => {\r\n      const matchingRows = map[result[idColumn.referencedColumn] as string];\r\n\r\n      const matchingValue =\r\n        attribute.relation === 'morphOne' ? _.first(matchingRows) : matchingRows;\r\n\r\n      result[attributeName] = fromTargetRow(matchingValue);\r\n    });\r\n  } else if (targetAttribute.type === 'relation' && targetAttribute.relation === 'morphToMany') {\r\n    const { joinTable } = targetAttribute;\r\n\r\n    const { joinColumn, morphColumn } = joinTable;\r\n\r\n    const { idColumn, typeColumn } = morphColumn;\r\n\r\n    const referencedValues = _.uniq(\r\n      results.map((r) => r[idColumn.referencedColumn]).filter((value) => !_.isNil(value))\r\n    );\r\n\r\n    if (_.isEmpty(referencedValues)) {\r\n      results.forEach((result) => {\r\n        result[attributeName] = attribute.relation === 'morphOne' ? null : [];\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    // find with join table\r\n    const qb = db.entityManager.createQueryBuilder(target);\r\n\r\n    const alias = qb.getAlias();\r\n\r\n    const rows = await qb\r\n      .init(populateValue)\r\n      .join({\r\n        alias,\r\n        referencedTable: joinTable.name,\r\n        referencedColumn: joinColumn.name,\r\n        rootColumn: joinColumn.referencedColumn,\r\n        rootTable: qb.alias,\r\n        on: {\r\n          ...(joinTable.on || {}),\r\n          field: attributeName,\r\n        },\r\n        orderBy: _.mapValues((v) => populateValue.ordering || v, joinTable.orderBy),\r\n      })\r\n      .addSelect([`${alias}.${idColumn.name}`, `${alias}.${typeColumn.name}`])\r\n      .where({\r\n        [`${alias}.${idColumn.name}`]: referencedValues,\r\n        [`${alias}.${typeColumn.name}`]: uid,\r\n      })\r\n      .execute<Row[]>({ mapResults: false });\r\n\r\n    const map = _.groupBy<Row>(idColumn.name)(rows);\r\n\r\n    results.forEach((result) => {\r\n      const matchingRows = map[result[idColumn.referencedColumn] as string];\r\n\r\n      const matchingValue =\r\n        attribute.relation === 'morphOne' ? _.first(matchingRows) : matchingRows;\r\n\r\n      result[attributeName] = fromTargetRow(matchingValue);\r\n    });\r\n  }\r\n};\r\n\r\nconst morphToMany = async (input: Input<Relation.MorphToMany>, ctx: Context) => {\r\n  const { attribute, attributeName, results, populateValue } = input;\r\n  const { db } = ctx;\r\n\r\n  // find with join table\r\n  const { joinTable } = attribute;\r\n\r\n  const { joinColumn, morphColumn } = joinTable;\r\n  const { idColumn, typeColumn, typeField = '__type' } = morphColumn;\r\n\r\n  // fetch join table to create the ids map then do the same as morphToOne without the first\r\n\r\n  const referencedValues = _.uniq(\r\n    results.map((r) => r[joinColumn.referencedColumn]).filter((value) => !_.isNil(value))\r\n  );\r\n\r\n  const qb = db.entityManager.createQueryBuilder(joinTable.name);\r\n\r\n  const joinRows = await qb\r\n    .where({\r\n      [joinColumn.name]: referencedValues,\r\n      ...(joinTable.on || {}),\r\n      // If the populateValue contains an \"on\" property,\r\n      // only populate the types defined in it\r\n      ...('on' in populateValue\r\n        ? { [morphColumn.typeColumn.name]: Object.keys(populateValue.on ?? {}) }\r\n        : {}),\r\n    })\r\n    .orderBy([joinColumn.name, 'order'])\r\n    .execute<Row[]>({ mapResults: false });\r\n\r\n  const joinMap = _.groupBy(joinColumn.name, joinRows);\r\n\r\n  const idsByType = joinRows.reduce<Record<string, ID[]>>((acc, result) => {\r\n    const idValue = result[morphColumn.idColumn.name] as ID;\r\n    const typeValue = result[morphColumn.typeColumn.name] as string;\r\n\r\n    if (!idValue || !typeValue) {\r\n      return acc;\r\n    }\r\n\r\n    if (!_.has(typeValue, acc)) {\r\n      acc[typeValue] = [];\r\n    }\r\n\r\n    acc[typeValue].push(idValue);\r\n\r\n    return acc;\r\n  }, {});\r\n\r\n  const map: MorphIdMap = {};\r\n  const { on, ...typePopulate } = populateValue;\r\n\r\n  for (const type of Object.keys(idsByType)) {\r\n    const ids = idsByType[type];\r\n\r\n    // type was removed but still in morph relation\r\n    if (!db.metadata.get(type)) {\r\n      map[type] = {};\r\n\r\n      continue;\r\n    }\r\n\r\n    const qb = db.entityManager.createQueryBuilder(type);\r\n\r\n    const rows = await qb\r\n      .init(on?.[type] ?? typePopulate)\r\n      .addSelect(`${qb.alias}.${idColumn.referencedColumn}`)\r\n      .where({ [idColumn.referencedColumn]: ids })\r\n      .execute<Row[]>({ mapResults: false });\r\n\r\n    map[type] = _.groupBy<Row>(idColumn.referencedColumn)(rows);\r\n  }\r\n\r\n  results.forEach((result) => {\r\n    const joinResults = joinMap[result[joinColumn.referencedColumn] as string] || [];\r\n\r\n    const matchingRows = joinResults.flatMap((joinResult) => {\r\n      const id = joinResult[idColumn.name] as ID;\r\n      const type = joinResult[typeColumn.name] as string;\r\n\r\n      const targetMeta = db.metadata.get(type);\r\n\r\n      const fromTargetRow = (rowOrRows: Row | Row[] | undefined) => fromRow(targetMeta, rowOrRows);\r\n\r\n      return (map[type][id] || []).map((row) => {\r\n        return {\r\n          [typeField]: type,\r\n          ...fromTargetRow(row),\r\n        };\r\n      });\r\n    });\r\n\r\n    result[attributeName] = matchingRows;\r\n  });\r\n};\r\n\r\nconst morphToOne = async (input: Input<Relation.MorphToOne>, ctx: Context) => {\r\n  const { attribute, attributeName, results, populateValue } = input;\r\n  const { db } = ctx;\r\n\r\n  const { morphColumn } = attribute;\r\n  const { idColumn, typeColumn } = morphColumn;\r\n\r\n  // make a map for each type what ids to return\r\n  // make a nested map per id\r\n\r\n  const idsByType = results.reduce<Record<string, ID[]>>((acc, result) => {\r\n    const idValue = result[morphColumn.idColumn.name] as ID;\r\n    const typeValue = result[morphColumn.typeColumn.name] as string;\r\n\r\n    if (!idValue || !typeValue) {\r\n      return acc;\r\n    }\r\n\r\n    if (!(typeValue in acc)) {\r\n      acc[typeValue] = [];\r\n    }\r\n\r\n    acc[typeValue].push(idValue);\r\n\r\n    return acc;\r\n  }, {});\r\n\r\n  const map: MorphIdMap = {};\r\n  const { on, ...typePopulate } = populateValue;\r\n\r\n  for (const type of Object.keys(idsByType)) {\r\n    const ids = idsByType[type];\r\n\r\n    // type was removed but still in morph relation\r\n    if (!db.metadata.get(type)) {\r\n      map[type] = {};\r\n      return;\r\n    }\r\n\r\n    const qb = db.entityManager.createQueryBuilder(type);\r\n\r\n    const rows = await qb\r\n      .init(on?.[type] ?? typePopulate)\r\n      .addSelect(`${qb.alias}.${idColumn.referencedColumn}`)\r\n      .where({ [idColumn.referencedColumn]: ids })\r\n      .execute<Row[]>({ mapResults: false });\r\n\r\n    map[type] = _.groupBy<Row>(idColumn.referencedColumn)(rows);\r\n  }\r\n\r\n  results.forEach((result) => {\r\n    const id = result[idColumn.name] as ID;\r\n    const type = result[typeColumn.name] as string;\r\n\r\n    if (!type || !id) {\r\n      result[attributeName] = null;\r\n      return;\r\n    }\r\n\r\n    const matchingRows = map[type][id];\r\n\r\n    const fromTargetRow = (rowOrRows: Row | Row[] | undefined) =>\r\n      fromRow(db.metadata.get(type), rowOrRows);\r\n\r\n    result[attributeName] = fromTargetRow(_.first(matchingRows));\r\n  });\r\n};\r\n\r\n//  TODO: Omit limit & offset to avoid needing a query per result to avoid making too many queries\r\nconst pickPopulateParams = (populate: Record<string, unknown>) => {\r\n  const fieldsToPick = [\r\n    'select',\r\n    'count',\r\n    'where',\r\n    'populate',\r\n    'orderBy',\r\n    'filters',\r\n    'ordering',\r\n    'on',\r\n  ];\r\n\r\n  if (populate.count !== true) {\r\n    fieldsToPick.push('limit', 'offset');\r\n  }\r\n\r\n  return _.pick(fieldsToPick, populate);\r\n};\r\n\r\nconst applyPopulate = async (results: Row[], populate: Record<string, any>, ctx: Context) => {\r\n  const { db, uid, qb } = ctx;\r\n  const meta = db.metadata.get(uid);\r\n\r\n  if (_.isEmpty(results)) {\r\n    return results;\r\n  }\r\n\r\n  for (const attributeName of Object.keys(populate)) {\r\n    const attribute = meta.attributes[attributeName];\r\n\r\n    if (attribute.type !== 'relation') {\r\n      throw new Error(`Invalid populate attribute ${attributeName}`);\r\n    }\r\n\r\n    const populateValue = {\r\n      filters: qb.state.filters,\r\n      ...pickPopulateParams(populate[attributeName]),\r\n    };\r\n\r\n    const isCount = 'count' in populateValue && populateValue.count === true;\r\n\r\n    switch (attribute.relation) {\r\n      case 'oneToOne':\r\n      case 'manyToOne': {\r\n        const targetMeta = db.metadata.get(attribute.target);\r\n        const input = { attribute, attributeName, results, populateValue, targetMeta, isCount };\r\n        await XtoOne(input, ctx);\r\n        break;\r\n      }\r\n      case 'oneToMany': {\r\n        const targetMeta = db.metadata.get(attribute.target);\r\n        const input = { attribute, attributeName, results, populateValue, targetMeta, isCount };\r\n        await oneToMany(input, ctx);\r\n        break;\r\n      }\r\n      case 'manyToMany': {\r\n        const targetMeta = db.metadata.get(attribute.target);\r\n        const input = { attribute, attributeName, results, populateValue, targetMeta, isCount };\r\n        await manyToMany(input, ctx);\r\n        break;\r\n      }\r\n      case 'morphOne':\r\n      case 'morphMany': {\r\n        const targetMeta = db.metadata.get(attribute.target);\r\n        const input = { attribute, attributeName, results, populateValue, targetMeta, isCount };\r\n        await morphX(input, ctx);\r\n        break;\r\n      }\r\n      case 'morphToMany': {\r\n        const input = { attribute, attributeName, results, populateValue, isCount };\r\n        await morphToMany(input, ctx);\r\n        break;\r\n      }\r\n      case 'morphToOne': {\r\n        const input = { attribute, attributeName, results, populateValue, isCount };\r\n        await morphToOne(input, ctx);\r\n        break;\r\n      }\r\n      default: {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nexport default applyPopulate;\r\n","import _ from 'lodash/fp';\r\n\r\nimport * as types from '../../../utils/types';\r\nimport type { Meta } from '../../../metadata';\r\nimport type { QueryBuilder } from '../../query-builder';\r\nimport type { Database } from '../../..';\r\n\r\nconst getRootLevelPopulate = (meta: Meta) => {\r\n  const populate: PopulateMap = {};\r\n\r\n  for (const attributeName of Object.keys(meta.attributes)) {\r\n    const attribute = meta.attributes[attributeName];\r\n    if (attribute.type === 'relation') {\r\n      populate[attributeName] = true;\r\n    }\r\n  }\r\n\r\n  return populate;\r\n};\r\n\r\ntype Context = {\r\n  qb: QueryBuilder;\r\n  db: Database;\r\n  uid: string;\r\n};\r\n\r\ntype PopulateMap = {\r\n  [key: string]:\r\n    | true\r\n    | {\r\n        populate?: PopulateMap | true | string[];\r\n      };\r\n};\r\n\r\n/**\r\n * Converts and prepares the query for populate\r\n *\r\n * @param {boolean|string[]|object} populate populate param\r\n * @param {object} ctx query context\r\n * @param {object} ctx.db database instance\r\n * @param {object} ctx.qb query builder instance\r\n * @param {string} ctx.uid model uid\r\n */\r\nconst processPopulate = (populate: unknown, ctx: Context) => {\r\n  const { qb, db, uid } = ctx;\r\n  const meta = db.metadata.get(uid);\r\n\r\n  let populateMap: PopulateMap = {};\r\n\r\n  if (populate === false || _.isNil(populate)) {\r\n    return null;\r\n  }\r\n\r\n  if (populate === true) {\r\n    populateMap = getRootLevelPopulate(meta);\r\n  } else if (Array.isArray(populate)) {\r\n    for (const key of populate) {\r\n      const [root, ...rest] = key.split('.');\r\n\r\n      if (rest.length > 0) {\r\n        const subPopulate = rest.join('.');\r\n        if (populateMap[root]) {\r\n          const populateValue = populateMap[root];\r\n\r\n          if (populateValue === true) {\r\n            populateMap[root] = {\r\n              populate: [subPopulate],\r\n            };\r\n          } else {\r\n            populateValue.populate = [subPopulate].concat(populateValue.populate ?? []);\r\n          }\r\n        } else {\r\n          populateMap[root] = {\r\n            populate: [subPopulate],\r\n          };\r\n        }\r\n      } else {\r\n        populateMap[root] = populateMap[root] ? populateMap[root] : true;\r\n      }\r\n    }\r\n  } else {\r\n    populateMap = populate as PopulateMap;\r\n  }\r\n\r\n  if (!_.isPlainObject(populateMap)) {\r\n    throw new Error('Populate must be an object');\r\n  }\r\n\r\n  const finalPopulate: PopulateMap = {};\r\n  for (const key of Object.keys(populateMap)) {\r\n    const attribute = meta.attributes[key];\r\n\r\n    if (!attribute) {\r\n      continue;\r\n    }\r\n\r\n    if (!types.isRelation(attribute.type)) {\r\n      continue;\r\n    }\r\n\r\n    // Make sure to query the join column value if needed,\r\n    // so that we can apply the populate later on\r\n    if ('joinColumn' in attribute && attribute.joinColumn) {\r\n      qb.addSelect(attribute.joinColumn.name);\r\n    }\r\n\r\n    // Make sure id is present for future populate queries\r\n    if (_.has('id', meta.attributes)) {\r\n      qb.addSelect('id');\r\n    }\r\n\r\n    finalPopulate[key] = populateMap[key];\r\n  }\r\n\r\n  return finalPopulate;\r\n};\r\n\r\nexport default processPopulate;\r\n","/* eslint-disable @typescript-eslint/ban-ts-comment */\r\nimport { isArray, castArray, isPlainObject } from 'lodash/fp';\r\nimport type { Knex } from 'knex';\r\n\r\nimport { isOperator, isOperatorOfType } from '@strapi/utils';\r\nimport * as types from '../../utils/types';\r\nimport { createField } from '../../fields';\r\nimport { createJoin } from './join';\r\nimport { toColumnName } from './transform';\r\nimport { isKnexQuery } from '../../utils/knex';\r\n\r\nimport type { Ctx } from '../types';\r\nimport type { Attribute } from '../../types';\r\n\r\ntype WhereCtx = Ctx & { alias?: string; isGroupRoot?: boolean };\r\n\r\nconst isRecord = (value: unknown): value is Record<string, unknown> => isPlainObject(value);\r\n\r\nconst castValue = (value: unknown, attribute: Attribute | null) => {\r\n  if (!attribute) {\r\n    return value;\r\n  }\r\n\r\n  if (types.isScalar(attribute.type) && !isKnexQuery(value)) {\r\n    const field = createField(attribute);\r\n\r\n    return value === null ? null : field.toDB(value);\r\n  }\r\n\r\n  return value;\r\n};\r\n\r\nconst processSingleAttributeWhere = (\r\n  attribute: Attribute | null,\r\n  where: unknown,\r\n  operator = '$eq'\r\n) => {\r\n  if (!isRecord(where)) {\r\n    if (isOperatorOfType('cast', operator)) {\r\n      return castValue(where, attribute);\r\n    }\r\n\r\n    return where;\r\n  }\r\n\r\n  const filters: Record<string, unknown> = {};\r\n\r\n  for (const key of Object.keys(where)) {\r\n    const value = where[key];\r\n\r\n    if (!isOperatorOfType('where', key)) {\r\n      throw new Error(`Undefined attribute level operator ${key}`);\r\n    }\r\n\r\n    filters[key] = processAttributeWhere(attribute, value, key);\r\n  }\r\n\r\n  return filters;\r\n};\r\n\r\nconst processAttributeWhere = (attribute: Attribute | null, where: unknown, operator = '$eq') => {\r\n  if (isArray(where)) {\r\n    return where.map((sub) => processSingleAttributeWhere(attribute, sub, operator));\r\n  }\r\n\r\n  return processSingleAttributeWhere(attribute, where, operator);\r\n};\r\n\r\nconst processNested = (where: unknown, ctx: WhereCtx) => {\r\n  if (!isRecord(where)) {\r\n    return where;\r\n  }\r\n\r\n  return processWhere(where, ctx);\r\n};\r\n\r\nconst processRelationWhere = (where: unknown, ctx: WhereCtx) => {\r\n  const { qb, alias } = ctx;\r\n\r\n  const idAlias = qb.aliasColumn('id', alias);\r\n  if (!isRecord(where)) {\r\n    return { [idAlias]: where };\r\n  }\r\n\r\n  const keys = Object.keys(where);\r\n  const operatorKeys = keys.filter((key) => isOperator(key));\r\n\r\n  if (operatorKeys.length > 0 && operatorKeys.length !== keys.length) {\r\n    throw new Error(`Operator and non-operator keys cannot be mixed in a relation where clause`);\r\n  }\r\n\r\n  if (operatorKeys.length > 1) {\r\n    throw new Error(\r\n      `Only one operator key is allowed in a relation where clause, but found: ${operatorKeys}`\r\n    );\r\n  }\r\n\r\n  if (operatorKeys.length === 1) {\r\n    const operator = operatorKeys[0];\r\n\r\n    if (isOperatorOfType('group', operator)) {\r\n      return processWhere(where, ctx);\r\n    }\r\n\r\n    return { [idAlias]: { [operator]: processNested(where[operator], ctx) } };\r\n  }\r\n\r\n  return processWhere(where, ctx);\r\n};\r\n\r\n/**\r\n * Process where parameter\r\n */\r\nfunction processWhere(where: Record<string, unknown>, ctx: WhereCtx): Record<string, unknown>;\r\nfunction processWhere(where: Record<string, unknown>[], ctx: WhereCtx): Record<string, unknown>[];\r\nfunction processWhere(\r\n  where: Record<string, unknown> | Record<string, unknown>[],\r\n  ctx: WhereCtx\r\n): Record<string, unknown> | Record<string, unknown>[] {\r\n  if (!isArray(where) && !isRecord(where)) {\r\n    throw new Error('Where must be an array or an object');\r\n  }\r\n\r\n  if (isArray(where)) {\r\n    return where.map((sub) => processWhere(sub, ctx));\r\n  }\r\n\r\n  const { db, uid, qb, alias } = ctx;\r\n  const meta = db.metadata.get(uid);\r\n\r\n  const filters: Record<string, unknown> = {};\r\n\r\n  // for each key in where\r\n  for (const key of Object.keys(where)) {\r\n    const value = where[key];\r\n\r\n    // if operator $and $or -> process recursively\r\n    if (isOperatorOfType('group', key)) {\r\n      if (!Array.isArray(value)) {\r\n        throw new Error(`Operator ${key} must be an array`);\r\n      }\r\n\r\n      filters[key] = value.map((sub) => processNested(sub, ctx));\r\n      continue;\r\n    }\r\n\r\n    if (key === '$not') {\r\n      filters[key] = processNested(value, ctx);\r\n      continue;\r\n    }\r\n\r\n    if (isOperatorOfType('where', key)) {\r\n      throw new Error(\r\n        `Only $and, $or and $not can only be used as root level operators. Found ${key}.`\r\n      );\r\n    }\r\n\r\n    const attribute = meta.attributes[key];\r\n\r\n    if (!attribute) {\r\n      filters[qb.aliasColumn(key, alias)] = processAttributeWhere(null, value);\r\n      continue;\r\n    }\r\n\r\n    if (types.isRelation(attribute.type) && 'target' in attribute) {\r\n      // attribute\r\n      const subAlias = createJoin(ctx, {\r\n        alias: alias || qb.alias,\r\n        attributeName: key,\r\n        attribute,\r\n      });\r\n\r\n      const nestedWhere = processRelationWhere(value, {\r\n        db,\r\n        qb,\r\n        alias: subAlias,\r\n        uid: attribute.target,\r\n      });\r\n\r\n      // TODO: use a better merge logic (push to $and when collisions)\r\n      Object.assign(filters, nestedWhere);\r\n\r\n      continue;\r\n    }\r\n\r\n    if (types.isScalar(attribute.type)) {\r\n      const columnName = toColumnName(meta, key);\r\n      const aliasedColumnName = qb.aliasColumn(columnName, alias);\r\n\r\n      filters[aliasedColumnName] = processAttributeWhere(attribute, value);\r\n\r\n      continue;\r\n    }\r\n\r\n    throw new Error(`You cannot filter on ${attribute.type} types`);\r\n  }\r\n\r\n  return filters;\r\n}\r\n\r\ntype Operator =\r\n  | '$eq'\r\n  | '$ne'\r\n  | '$nei'\r\n  | '$in'\r\n  | '$notIn'\r\n  | '$lt'\r\n  | '$lte'\r\n  | '$gt'\r\n  | '$gte'\r\n  | '$between'\r\n  | '$contains'\r\n  | '$notContains'\r\n  | '$containsi'\r\n  | '$notContainsi'\r\n  | '$startsWith'\r\n  | '$endsWith'\r\n  | '$null'\r\n  | '$notNull'\r\n  | '$not'\r\n  | '$eqi'\r\n  | '$startsWithi'\r\n  | '$endsWithi'\r\n  | '$jsonSupersetOf';\r\n\r\n// TODO: add type casting per operator at some point\r\nconst applyOperator = (qb: Knex.QueryBuilder, column: any, operator: Operator, value: any) => {\r\n  if (Array.isArray(value) && !isOperatorOfType('array', operator)) {\r\n    return qb.where((subQB) => {\r\n      value.forEach((subValue) =>\r\n        subQB.orWhere((innerQB) => {\r\n          applyOperator(innerQB, column, operator, subValue);\r\n        })\r\n      );\r\n    });\r\n  }\r\n\r\n  switch (operator) {\r\n    case '$not': {\r\n      qb.whereNot((qb) => applyWhereToColumn(qb, column, value));\r\n      break;\r\n    }\r\n\r\n    case '$in': {\r\n      // @ts-ignore\r\n      // TODO: fix in v5\r\n      qb.whereIn(column, isKnexQuery(value) ? value : castArray(value));\r\n      break;\r\n    }\r\n\r\n    case '$notIn': {\r\n      // @ts-ignore\r\n      // TODO: fix in v5\r\n      qb.whereNotIn(column, isKnexQuery(value) ? value : castArray(value));\r\n      break;\r\n    }\r\n\r\n    case '$eq': {\r\n      if (value === null) {\r\n        qb.whereNull(column);\r\n        break;\r\n      }\r\n\r\n      qb.where(column, value);\r\n      break;\r\n    }\r\n\r\n    case '$eqi': {\r\n      if (value === null) {\r\n        qb.whereNull(column);\r\n        break;\r\n      }\r\n      qb.whereRaw(`${fieldLowerFn(qb)} LIKE LOWER(?)`, [column, `${value}`]);\r\n      break;\r\n    }\r\n    case '$ne': {\r\n      if (value === null) {\r\n        qb.whereNotNull(column);\r\n        break;\r\n      }\r\n\r\n      qb.where(column, '<>', value);\r\n      break;\r\n    }\r\n    case '$nei': {\r\n      if (value === null) {\r\n        qb.whereNotNull(column);\r\n        break;\r\n      }\r\n      qb.whereRaw(`${fieldLowerFn(qb)} NOT LIKE LOWER(?)`, [column, `${value}`]);\r\n      break;\r\n    }\r\n    case '$gt': {\r\n      qb.where(column, '>', value);\r\n      break;\r\n    }\r\n    case '$gte': {\r\n      qb.where(column, '>=', value);\r\n      break;\r\n    }\r\n    case '$lt': {\r\n      qb.where(column, '<', value);\r\n      break;\r\n    }\r\n    case '$lte': {\r\n      qb.where(column, '<=', value);\r\n      break;\r\n    }\r\n    case '$null': {\r\n      if (value) {\r\n        qb.whereNull(column);\r\n      } else {\r\n        qb.whereNotNull(column);\r\n      }\r\n      break;\r\n    }\r\n    case '$notNull': {\r\n      if (value) {\r\n        qb.whereNotNull(column);\r\n      } else {\r\n        qb.whereNull(column);\r\n      }\r\n      break;\r\n    }\r\n    case '$between': {\r\n      qb.whereBetween(column, value);\r\n      break;\r\n    }\r\n    case '$startsWith': {\r\n      qb.where(column, 'like', `${value}%`);\r\n      break;\r\n    }\r\n    case '$startsWithi': {\r\n      qb.whereRaw(`${fieldLowerFn(qb)} LIKE LOWER(?)`, [column, `${value}%`]);\r\n      break;\r\n    }\r\n    case '$endsWith': {\r\n      qb.where(column, 'like', `%${value}`);\r\n      break;\r\n    }\r\n    case '$endsWithi': {\r\n      qb.whereRaw(`${fieldLowerFn(qb)} LIKE LOWER(?)`, [column, `%${value}`]);\r\n      break;\r\n    }\r\n    case '$contains': {\r\n      qb.where(column, 'like', `%${value}%`);\r\n      break;\r\n    }\r\n\r\n    case '$notContains': {\r\n      qb.whereNot(column, 'like', `%${value}%`);\r\n      break;\r\n    }\r\n\r\n    case '$containsi': {\r\n      qb.whereRaw(`${fieldLowerFn(qb)} LIKE LOWER(?)`, [column, `%${value}%`]);\r\n      break;\r\n    }\r\n\r\n    case '$notContainsi': {\r\n      qb.whereRaw(`${fieldLowerFn(qb)} NOT LIKE LOWER(?)`, [column, `%${value}%`]);\r\n      break;\r\n    }\r\n\r\n    // Experimental, only for internal use\r\n    // Only on MySQL, PostgreSQL and CockroachDB.\r\n    // https://knexjs.org/guide/query-builder.html#wherejsonsupersetof\r\n    case '$jsonSupersetOf': {\r\n      qb.whereJsonSupersetOf(column, value);\r\n      break;\r\n    }\r\n\r\n    // TODO: Add more JSON operators: whereJsonObject, whereJsonPath, whereJsonSubsetOf\r\n\r\n    // TODO: relational operators every/some/exists/size ...\r\n\r\n    default: {\r\n      throw new Error(`Undefined attribute level operator ${operator}`);\r\n    }\r\n  }\r\n};\r\n\r\nconst applyWhereToColumn = (\r\n  qb: Knex.QueryBuilder,\r\n  column: string,\r\n  columnWhere: Record<Operator, unknown> | Array<Record<Operator, unknown>>\r\n) => {\r\n  if (!isRecord(columnWhere)) {\r\n    if (Array.isArray(columnWhere)) {\r\n      return qb.whereIn(column, columnWhere);\r\n    }\r\n\r\n    return qb.where(column, columnWhere);\r\n  }\r\n\r\n  const keys = Object.keys(columnWhere) as Operator[];\r\n\r\n  keys.forEach((operator) => {\r\n    const value = columnWhere[operator];\r\n\r\n    applyOperator(qb, column, operator, value);\r\n  });\r\n};\r\n\r\ntype Where =\r\n  | {\r\n      $and?: Where[];\r\n      $or?: Where[];\r\n      $not?: Where;\r\n      [key: string]: any;\r\n    }\r\n  | Array<Where>;\r\n\r\nconst applyWhere = (qb: Knex.QueryBuilder, where: Where) => {\r\n  if (!isArray(where) && !isRecord(where)) {\r\n    throw new Error('Where must be an array or an object');\r\n  }\r\n\r\n  if (isArray(where)) {\r\n    return qb.where((subQB: Knex.QueryBuilder) =>\r\n      where.forEach((subWhere) => applyWhere(subQB, subWhere))\r\n    );\r\n  }\r\n\r\n  Object.keys(where).forEach((key) => {\r\n    if (key === '$and') {\r\n      const value = where[key] ?? [];\r\n\r\n      return qb.where((subQB: Knex.QueryBuilder) => {\r\n        value.forEach((v) => applyWhere(subQB, v));\r\n      });\r\n    }\r\n\r\n    if (key === '$or') {\r\n      const value = where[key] ?? [];\r\n\r\n      return qb.where((subQB: Knex.QueryBuilder) => {\r\n        value.forEach((v) => subQB.orWhere((inner) => applyWhere(inner, v)));\r\n      });\r\n    }\r\n\r\n    if (key === '$not') {\r\n      const value = where[key] ?? {};\r\n\r\n      return qb.whereNot((qb) => applyWhere(qb, value));\r\n    }\r\n\r\n    applyWhereToColumn(qb, key, where[key]);\r\n  });\r\n};\r\n\r\nconst fieldLowerFn = (qb: Knex.QueryBuilder) => {\r\n  // Postgres requires string to be passed\r\n  if (qb.client.dialect === 'postgresql') {\r\n    return 'LOWER(CAST(?? AS VARCHAR))';\r\n  }\r\n\r\n  return 'LOWER(??)';\r\n};\r\n\r\nexport { applyWhere, processWhere };\r\n","import { Readable } from 'stream';\r\nimport { isFinite } from 'lodash/fp';\r\nimport type { Knex } from 'knex';\r\nimport type { QueryBuilder } from '../../query-builder';\r\nimport type { Database } from '../../..';\r\n\r\nimport { applyPopulate } from '../populate';\r\nimport { fromRow } from '../transform';\r\nimport { Meta } from '../../../metadata';\r\n\r\nconst knexQueryDone = Symbol('knexQueryDone');\r\nconst knexPerformingQuery = Symbol('knexPerformingQuery');\r\n\r\ninterface ReadableStrapiQueryOptions {\r\n  qb: QueryBuilder;\r\n  uid: string;\r\n  db: Database;\r\n  mapResults?: boolean;\r\n  batchSize?: number;\r\n}\r\n\r\nclass ReadableStrapiQuery extends Readable {\r\n  _offset: number;\r\n\r\n  _limit: number | null;\r\n\r\n  _fetched: number;\r\n\r\n  _query: Knex.QueryBuilder;\r\n\r\n  _qb: QueryBuilder;\r\n\r\n  _db: Database;\r\n\r\n  _uid: string;\r\n\r\n  _meta: Meta;\r\n\r\n  _batchSize: number;\r\n\r\n  _mapResults: boolean;\r\n\r\n  [knexPerformingQuery]: boolean;\r\n\r\n  constructor({ qb, db, uid, mapResults = true, batchSize = 500 }: ReadableStrapiQueryOptions) {\r\n    super({ objectMode: true, highWaterMark: batchSize });\r\n\r\n    // Extract offset & limit from the query-builder's state\r\n    const { offset, limit } = qb.state;\r\n\r\n    // Original offset value\r\n    this._offset = isFinite(offset) ? Number(offset) : 0;\r\n\r\n    // Max amount of entities to fetch, force null as undefined value\r\n    this._limit = isFinite(limit) ? Number(limit) : null;\r\n\r\n    // Total amount of entities fetched\r\n    this._fetched = 0;\r\n\r\n    /**\r\n     * Original query\r\n     */\r\n    this._query = qb.getKnexQuery();\r\n\r\n    // Query Builder instance\r\n    this._qb = qb;\r\n\r\n    // Database related properties\r\n    this._db = db;\r\n    this._uid = uid;\r\n    this._meta = db.metadata.get(uid);\r\n\r\n    // Stream params\r\n    this._batchSize = batchSize;\r\n    this._mapResults = mapResults;\r\n\r\n    // States\r\n    this[knexPerformingQuery] = false;\r\n  }\r\n\r\n  _destroy(err: Error, cb: (err?: Error) => void) {\r\n    // If the stream is destroyed while a query is being made, then wait for a\r\n    // kQueryDone event to be emitted before actually destroying the stream\r\n    if (this[knexPerformingQuery]) {\r\n      this.once(knexQueryDone, (er) => cb(err || er));\r\n    } else {\r\n      cb(err);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Custom ._read() implementation\r\n   *\r\n   *  NOTE: Here \"size\" means the number of entities to be read from the database.\r\n   *  Not the actual byte size, as it would mean that we need to return partial entities.\r\n   *\r\n   */\r\n  async _read(size: number) {\r\n    const query = this._query;\r\n\r\n    // Remove the original offset & limit properties from the query\r\n    // Theoretically, they would be replaced by calling them again, but this is just to be sure\r\n    query.clear('limit').clear('offset');\r\n\r\n    // Define the maximum read size based on the limit and the requested size\r\n    // NOTE: size is equal to _batchSize by default. Since we want to allow customizing it on\r\n    // the fly, we need to use its value instead of batchSize when computing the maxReadSize value\r\n    const maxReadSize =\r\n      // if no limit is defined in the query, use the given size,\r\n      // otherwise, use the smallest value between the two\r\n      this._limit === null ? size : Math.min(size, this._limit);\r\n\r\n    // Compute the limit for the next query\r\n    const limit =\r\n      // If a limit is defined\r\n      this._limit !== null &&\r\n      // And reading `maxReadSize` would fetch too many entities (> _limit)\r\n      this._fetched + maxReadSize > this._limit\r\n        ? // Then adjust the limit so that it only get the remaining entities\r\n          this._limit - this._fetched\r\n        : // Else, use the max read size\r\n          maxReadSize;\r\n\r\n    // If we don't have anything left to read (_limit === _fetched),\r\n    // don't bother making the query and end the stream by pushing null\r\n    if (limit <= 0) {\r\n      this.push(null);\r\n      return;\r\n    }\r\n\r\n    // Compute the offset (base offset + number of entities already fetched)\r\n    const offset = this._offset + this._fetched;\r\n\r\n    // Update the query with the new values (offset + limit)\r\n    query.offset(offset).limit(limit);\r\n\r\n    // Lock the ._destroy()\r\n    this[knexPerformingQuery] = true;\r\n\r\n    let results;\r\n    let count;\r\n    let err;\r\n\r\n    try {\r\n      // Execute the query and store the results & count\r\n      results = await query;\r\n\r\n      const { populate } = this._qb.state;\r\n\r\n      // Applies the populate if needed\r\n      if (populate) {\r\n        await applyPopulate(results, populate, { qb: this._qb, uid: this._uid, db: this._db });\r\n      }\r\n\r\n      // Map results if asked to\r\n      if (this._mapResults) {\r\n        results = fromRow(this._meta, results);\r\n      }\r\n\r\n      count = results.length;\r\n    } catch (e) {\r\n      err = e;\r\n    }\r\n\r\n    // Unlock the ._destroy()\r\n    this[knexPerformingQuery] = false;\r\n\r\n    // Tell ._destroy() that it's now safe to close the db connection\r\n    if (this.destroyed) {\r\n      this.emit(knexQueryDone);\r\n      return;\r\n    }\r\n\r\n    // If there is an error, destroy with the given error\r\n    if (err) {\r\n      this.destroy(err as Error);\r\n      return;\r\n    }\r\n\r\n    // Update the amount of fetched entities\r\n    this._fetched += count;\r\n\r\n    // While there is at least one value to unpack\r\n    for (const result of results) {\r\n      this.push(result);\r\n    }\r\n\r\n    // If the amount of fetched entities is smaller than the\r\n    // maximum read size, Then push null to close the stream\r\n    if (this._fetched === this._limit || count < this._batchSize) {\r\n      this.push(null);\r\n    }\r\n  }\r\n}\r\n\r\nexport default ReadableStrapiQuery;\r\n","import type { Knex } from 'knex';\r\nimport _ from 'lodash/fp';\r\n\r\nimport type { Database } from '..';\r\n\r\nimport { DatabaseError } from '../errors';\r\nimport { transactionCtx } from '../transaction-context';\r\nimport { isKnexQuery } from '../utils/knex';\r\nimport * as helpers from './helpers';\r\nimport type { Join } from './helpers/join';\r\n\r\ninterface State {\r\n  type: 'select' | 'insert' | 'update' | 'delete' | 'count' | 'max' | 'truncate';\r\n  select: Array<string | Knex.Raw>;\r\n  count: string | null;\r\n  max: string | null;\r\n  first: boolean;\r\n  data: Record<string, unknown> | (null | Record<string, unknown>)[] | null;\r\n  where: Record<string, unknown>[];\r\n  joins: Join[];\r\n  populate: object | null;\r\n  limit: number | null;\r\n  offset: number | null;\r\n  transaction: any;\r\n  forUpdate: boolean;\r\n  onConflict: any;\r\n  merge: any;\r\n  ignore: boolean;\r\n  orderBy: any[];\r\n  groupBy: any[];\r\n  increments: any[];\r\n  decrements: any[];\r\n  aliasCounter: number;\r\n  filters: any;\r\n  search: string;\r\n}\r\n\r\nexport interface QueryBuilder {\r\n  alias: string;\r\n  state: State;\r\n  raw: Knex.RawBuilder;\r\n\r\n  getAlias(): string;\r\n\r\n  clone(): QueryBuilder;\r\n\r\n  select(args: string | Array<string | Knex.Raw>): QueryBuilder;\r\n\r\n  addSelect(args: string | string[]): QueryBuilder;\r\n\r\n  insert<TData extends Record<string, unknown> | Record<string, unknown>[]>(\r\n    data: TData\r\n  ): QueryBuilder;\r\n\r\n  onConflict(args: any): QueryBuilder;\r\n\r\n  merge(args: any): QueryBuilder;\r\n\r\n  ignore(): QueryBuilder;\r\n\r\n  delete(): QueryBuilder;\r\n\r\n  ref(name: string): any;\r\n\r\n  update<TData extends Record<string, unknown>>(data: TData): QueryBuilder;\r\n\r\n  increment(column: string, amount?: number): QueryBuilder;\r\n\r\n  decrement(column: string, amount?: number): QueryBuilder;\r\n\r\n  count(count?: string): QueryBuilder;\r\n\r\n  max(column: string): QueryBuilder;\r\n\r\n  where(where?: object): QueryBuilder;\r\n\r\n  limit(limit: number): QueryBuilder;\r\n\r\n  offset(offset: number): QueryBuilder;\r\n\r\n  orderBy(orderBy: any): QueryBuilder;\r\n\r\n  groupBy(groupBy: any): QueryBuilder;\r\n\r\n  populate(populate: any): QueryBuilder;\r\n\r\n  search(query: string): QueryBuilder;\r\n\r\n  transacting(transaction: any): QueryBuilder;\r\n\r\n  forUpdate(): QueryBuilder;\r\n\r\n  init(params?: any): QueryBuilder;\r\n\r\n  filters(filters: any): void;\r\n\r\n  first(): QueryBuilder;\r\n\r\n  join(join: any): QueryBuilder;\r\n\r\n  mustUseAlias(): boolean;\r\n\r\n  aliasColumn(key: any, alias?: string): any;\r\n\r\n  shouldUseSubQuery(): boolean;\r\n\r\n  runSubQuery(): any;\r\n\r\n  processState(): void;\r\n\r\n  shouldUseDistinct(): boolean;\r\n\r\n  shouldUseDeepSort(): boolean;\r\n\r\n  processSelect(): void;\r\n\r\n  getKnexQuery(): Knex.QueryBuilder;\r\n\r\n  execute<T>(options?: { mapResults?: boolean }): Promise<T>;\r\n\r\n  stream(options?: { mapResults?: boolean }): helpers.ReadableQuery;\r\n}\r\n\r\nconst createQueryBuilder = (\r\n  uid: string,\r\n  db: Database,\r\n  initialState: Partial<State> = {}\r\n): QueryBuilder => {\r\n  const meta = db.metadata.get(uid);\r\n  const { tableName } = meta;\r\n\r\n  const state: State = _.defaults(\r\n    {\r\n      type: 'select',\r\n      select: [],\r\n      count: null,\r\n      max: null,\r\n      first: false,\r\n      data: null,\r\n      where: [],\r\n      joins: [],\r\n      populate: null,\r\n      limit: null,\r\n      offset: null,\r\n      transaction: null,\r\n      forUpdate: false,\r\n      onConflict: null,\r\n      merge: null,\r\n      ignore: false,\r\n      orderBy: [],\r\n      groupBy: [],\r\n      increments: [],\r\n      decrements: [],\r\n      aliasCounter: 0,\r\n      filters: null,\r\n      search: null,\r\n    },\r\n    initialState\r\n  );\r\n\r\n  const getAlias = () => {\r\n    const alias = `t${state.aliasCounter}`;\r\n\r\n    state.aliasCounter += 1;\r\n\r\n    return alias;\r\n  };\r\n\r\n  return {\r\n    alias: getAlias(),\r\n    getAlias,\r\n    state,\r\n\r\n    clone() {\r\n      return createQueryBuilder(uid, db, state);\r\n    },\r\n\r\n    select(args) {\r\n      state.type = 'select';\r\n      state.select = _.uniq(_.castArray(args));\r\n\r\n      return this;\r\n    },\r\n\r\n    addSelect(args) {\r\n      state.select = _.uniq([...state.select, ..._.castArray(args)]);\r\n\r\n      return this;\r\n    },\r\n\r\n    insert(data) {\r\n      state.type = 'insert';\r\n      state.data = data;\r\n\r\n      return this;\r\n    },\r\n\r\n    onConflict(args) {\r\n      state.onConflict = args;\r\n\r\n      return this;\r\n    },\r\n\r\n    merge(args) {\r\n      state.merge = args;\r\n\r\n      return this;\r\n    },\r\n\r\n    ignore() {\r\n      state.ignore = true;\r\n\r\n      return this;\r\n    },\r\n\r\n    delete() {\r\n      state.type = 'delete';\r\n\r\n      return this;\r\n    },\r\n\r\n    ref(name) {\r\n      return db.connection.ref(helpers.toColumnName(meta, name));\r\n    },\r\n\r\n    update(data) {\r\n      state.type = 'update';\r\n      state.data = data;\r\n\r\n      return this;\r\n    },\r\n\r\n    increment(column, amount = 1) {\r\n      state.type = 'update';\r\n      state.increments.push({ column, amount });\r\n\r\n      return this;\r\n    },\r\n\r\n    decrement(column, amount = 1) {\r\n      state.type = 'update';\r\n      state.decrements.push({ column, amount });\r\n\r\n      return this;\r\n    },\r\n\r\n    count(count = 'id') {\r\n      state.type = 'count';\r\n      state.count = count;\r\n\r\n      return this;\r\n    },\r\n\r\n    max(column: string) {\r\n      state.type = 'max';\r\n      state.max = column;\r\n\r\n      return this;\r\n    },\r\n\r\n    where(where: Record<string, unknown> = {}) {\r\n      if (!_.isPlainObject(where)) {\r\n        throw new Error('Where must be an object');\r\n      }\r\n\r\n      state.where.push(where);\r\n\r\n      return this;\r\n    },\r\n\r\n    limit(limit) {\r\n      state.limit = limit;\r\n      return this;\r\n    },\r\n\r\n    offset(offset) {\r\n      state.offset = offset;\r\n      return this;\r\n    },\r\n\r\n    orderBy(orderBy) {\r\n      state.orderBy = orderBy;\r\n      return this;\r\n    },\r\n\r\n    groupBy(groupBy) {\r\n      state.groupBy = groupBy;\r\n      return this;\r\n    },\r\n\r\n    populate(populate) {\r\n      state.populate = populate;\r\n      return this;\r\n    },\r\n\r\n    search(query) {\r\n      state.search = query;\r\n      return this;\r\n    },\r\n\r\n    transacting(transaction) {\r\n      state.transaction = transaction;\r\n      return this;\r\n    },\r\n\r\n    forUpdate() {\r\n      state.forUpdate = true;\r\n      return this;\r\n    },\r\n\r\n    init(params = {}) {\r\n      const { _q, filters, where, select, limit, offset, orderBy, groupBy, populate } = params;\r\n\r\n      if (!_.isNil(where)) {\r\n        this.where(where);\r\n      }\r\n\r\n      if (!_.isNil(_q)) {\r\n        this.search(_q);\r\n      }\r\n\r\n      if (!_.isNil(select)) {\r\n        this.select(select);\r\n      } else {\r\n        this.select('*');\r\n      }\r\n\r\n      if (!_.isNil(limit)) {\r\n        this.limit(limit);\r\n      }\r\n\r\n      if (!_.isNil(offset)) {\r\n        this.offset(offset);\r\n      }\r\n\r\n      if (!_.isNil(orderBy)) {\r\n        this.orderBy(orderBy);\r\n      }\r\n\r\n      if (!_.isNil(groupBy)) {\r\n        this.groupBy(groupBy);\r\n      }\r\n\r\n      if (!_.isNil(populate)) {\r\n        this.populate(populate);\r\n      }\r\n\r\n      if (!_.isNil(filters)) {\r\n        this.filters(filters);\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    filters(filters) {\r\n      state.filters = filters;\r\n    },\r\n\r\n    first() {\r\n      state.first = true;\r\n      return this;\r\n    },\r\n\r\n    join(join) {\r\n      if (!join.targetField) {\r\n        state.joins.push(join);\r\n        return this;\r\n      }\r\n\r\n      const model = db.metadata.get(uid);\r\n      const attribute = model.attributes[join.targetField];\r\n\r\n      helpers.createJoin(\r\n        { db, qb: this, uid },\r\n        {\r\n          alias: this.alias,\r\n          refAlias: join.alias,\r\n          attributeName: join.targetField,\r\n          attribute,\r\n        }\r\n      );\r\n\r\n      return this;\r\n    },\r\n\r\n    mustUseAlias() {\r\n      return ['select', 'count'].includes(state.type);\r\n    },\r\n\r\n    aliasColumn(key: string | unknown, alias: string): string | unknown {\r\n      if (typeof key !== 'string') {\r\n        return key;\r\n      }\r\n\r\n      if (key.indexOf('.') >= 0) {\r\n        return key;\r\n      }\r\n\r\n      if (!_.isNil(alias)) {\r\n        return `${alias}.${key}`;\r\n      }\r\n\r\n      return this.mustUseAlias() ? `${this.alias}.${key}` : key;\r\n    },\r\n\r\n    raw: db.connection.raw.bind(db.connection),\r\n\r\n    shouldUseSubQuery() {\r\n      return ['delete', 'update'].includes(state.type) && state.joins.length > 0;\r\n    },\r\n\r\n    runSubQuery() {\r\n      this.select('id');\r\n      const subQB = this.getKnexQuery();\r\n\r\n      const nestedSubQuery = db.getConnection().select('id').from(subQB.as('subQuery'));\r\n      const connection = db.getConnection(tableName);\r\n\r\n      return (connection[state.type] as Knex)().whereIn('id', nestedSubQuery);\r\n    },\r\n\r\n    processState() {\r\n      state.orderBy = helpers.processOrderBy(state.orderBy, { qb: this, uid, db });\r\n\r\n      if (!_.isNil(state.filters)) {\r\n        if (_.isFunction(state.filters)) {\r\n          const filters = state.filters({ qb: this, uid, meta, db });\r\n\r\n          if (!_.isNil(filters)) {\r\n            state.where.push(filters);\r\n          }\r\n        } else {\r\n          state.where.push(state.filters);\r\n        }\r\n      }\r\n\r\n      state.where = helpers.processWhere(state.where, { qb: this, uid, db });\r\n      state.populate = helpers.processPopulate(state.populate, { qb: this, uid, db });\r\n\r\n      state.data = helpers.toRow(meta, state.data);\r\n\r\n      this.processSelect();\r\n    },\r\n\r\n    shouldUseDistinct() {\r\n      return state.joins.length > 0 && _.isEmpty(state.groupBy);\r\n    },\r\n\r\n    shouldUseDeepSort() {\r\n      return (\r\n        state.orderBy\r\n          .filter(({ column }) => column.indexOf('.') >= 0)\r\n          .filter(({ column }) => {\r\n            const col = column.split('.');\r\n\r\n            for (let i = 0; i < col.length - 1; i += 1) {\r\n              const el = col[i];\r\n\r\n              // order by \"rel\".\"xxx\"\r\n              const isRelationAttribute = meta.attributes[el]?.type === 'relation';\r\n\r\n              // order by \"t2\".\"xxx\"\r\n              const isAliasedRelation = Object.values(state.joins)\r\n                .map((join) => join.alias)\r\n                .includes(el);\r\n\r\n              if (isRelationAttribute || isAliasedRelation) {\r\n                return true;\r\n              }\r\n            }\r\n\r\n            return false;\r\n          }).length > 0\r\n      );\r\n    },\r\n\r\n    processSelect() {\r\n      state.select = state.select.map((field) => {\r\n        if (isKnexQuery(field)) {\r\n          return field;\r\n        }\r\n\r\n        return helpers.toColumnName(meta, field);\r\n      });\r\n\r\n      if (this.shouldUseDistinct()) {\r\n        const joinsOrderByColumns = state.joins.flatMap((join) => {\r\n          return _.keys(join.orderBy).map((key) => this.aliasColumn(key, join.alias));\r\n        });\r\n        const orderByColumns = state.orderBy.map(({ column }) => column);\r\n\r\n        state.select = _.uniq([...joinsOrderByColumns, ...orderByColumns, ...state.select]);\r\n      }\r\n    },\r\n\r\n    getKnexQuery() {\r\n      if (!state.type) {\r\n        this.select('*');\r\n      }\r\n\r\n      const aliasedTableName = this.mustUseAlias() ? `${tableName} as ${this.alias}` : tableName;\r\n\r\n      const qb = db.getConnection(aliasedTableName);\r\n\r\n      if (this.shouldUseSubQuery()) {\r\n        return this.runSubQuery();\r\n      }\r\n\r\n      this.processState();\r\n\r\n      switch (state.type) {\r\n        case 'select': {\r\n          qb.select(state.select.map((column) => this.aliasColumn(column)));\r\n\r\n          if (this.shouldUseDistinct()) {\r\n            qb.distinct();\r\n          }\r\n\r\n          break;\r\n        }\r\n        case 'count': {\r\n          const dbColumnName = this.aliasColumn(helpers.toColumnName(meta, state.count));\r\n\r\n          if (this.shouldUseDistinct()) {\r\n            qb.countDistinct({ count: dbColumnName });\r\n          } else {\r\n            qb.count({ count: dbColumnName });\r\n          }\r\n          break;\r\n        }\r\n        case 'max': {\r\n          const dbColumnName = this.aliasColumn(helpers.toColumnName(meta, state.max));\r\n          qb.max({ max: dbColumnName });\r\n          break;\r\n        }\r\n        case 'insert': {\r\n          qb.insert(state.data);\r\n\r\n          if (db.dialect.useReturning() && _.has('id', meta.attributes)) {\r\n            qb.returning('id');\r\n          }\r\n\r\n          break;\r\n        }\r\n        case 'update': {\r\n          if (state.data) {\r\n            qb.update(state.data);\r\n          }\r\n          break;\r\n        }\r\n        case 'delete': {\r\n          qb.delete();\r\n\r\n          break;\r\n        }\r\n        case 'truncate': {\r\n          qb.truncate();\r\n          break;\r\n        }\r\n        default: {\r\n          throw new Error('Unknown query type');\r\n        }\r\n      }\r\n\r\n      if (state.transaction) {\r\n        qb.transacting(state.transaction);\r\n      }\r\n\r\n      if (state.forUpdate) {\r\n        qb.forUpdate();\r\n      }\r\n\r\n      if (!_.isEmpty(state.increments)) {\r\n        state.increments.forEach((incr) => qb.increment(incr.column, incr.amount));\r\n      }\r\n\r\n      if (!_.isEmpty(state.decrements)) {\r\n        state.decrements.forEach((decr) => qb.decrement(decr.column, decr.amount));\r\n      }\r\n\r\n      if (state.onConflict) {\r\n        if (state.merge) {\r\n          qb.onConflict(state.onConflict).merge(state.merge);\r\n        } else if (state.ignore) {\r\n          qb.onConflict(state.onConflict).ignore();\r\n        }\r\n      }\r\n\r\n      if (state.limit) {\r\n        qb.limit(state.limit);\r\n      }\r\n\r\n      if (state.offset) {\r\n        qb.offset(state.offset);\r\n      }\r\n\r\n      if (state.orderBy.length > 0) {\r\n        qb.orderBy(state.orderBy);\r\n      }\r\n\r\n      if (state.first) {\r\n        qb.first();\r\n      }\r\n\r\n      if (state.groupBy.length > 0) {\r\n        qb.groupBy(state.groupBy);\r\n      }\r\n\r\n      // if there are joins and it is a delete or update use a sub query\r\n      if (state.where) {\r\n        helpers.applyWhere(qb, state.where);\r\n      }\r\n\r\n      // if there are joins and it is a delete or update use a sub query\r\n      if (state.search) {\r\n        qb.where((subQb) => {\r\n          helpers.applySearch(subQb, state.search, { qb: this, db, uid });\r\n        });\r\n      }\r\n\r\n      if (state.joins.length > 0) {\r\n        helpers.applyJoins(qb, state.joins);\r\n      }\r\n\r\n      if (this.shouldUseDeepSort()) {\r\n        return helpers.wrapWithDeepSort(qb, { qb: this, db, uid });\r\n      }\r\n\r\n      return qb;\r\n    },\r\n\r\n    async execute({ mapResults = true } = {}) {\r\n      try {\r\n        const qb = this.getKnexQuery();\r\n\r\n        const transaction = transactionCtx.get();\r\n        if (transaction) {\r\n          qb.transacting(transaction);\r\n        }\r\n\r\n        const rows = await qb;\r\n\r\n        if (state.populate && !_.isNil(rows)) {\r\n          await helpers.applyPopulate(_.castArray(rows), state.populate, {\r\n            qb: this,\r\n            uid,\r\n            db,\r\n          });\r\n        }\r\n\r\n        let results = rows;\r\n        if (mapResults && state.type === 'select') {\r\n          results = helpers.fromRow(meta, rows);\r\n        }\r\n\r\n        return results;\r\n      } catch (error) {\r\n        if (error instanceof Error) {\r\n          db.dialect.transformErrors(error);\r\n        } else {\r\n          throw error;\r\n        }\r\n      }\r\n    },\r\n\r\n    stream({ mapResults = true } = {}) {\r\n      if (state.type === 'select') {\r\n        return new helpers.ReadableQuery({ qb: this, db, uid, mapResults });\r\n      }\r\n\r\n      throw new DatabaseError(\r\n        `query-builder.stream() has been called with an unsupported query type: \"${state.type}\"`\r\n      );\r\n    },\r\n  };\r\n};\r\n\r\nexport default createQueryBuilder;\r\n","import { isString } from 'lodash/fp';\r\nimport type { Database } from '..';\r\nimport type { Repository, Params } from './types';\r\n\r\nconst withDefaultPagination = (params: Params) => {\r\n  const { page = 1, pageSize = 10, ...rest } = params;\r\n\r\n  return {\r\n    page: Number(page),\r\n    pageSize: Number(pageSize),\r\n    ...rest,\r\n  };\r\n};\r\n\r\ntype ParamsWithLimits = Omit<Params, 'page' | 'pageSize'> & {\r\n  limit: number;\r\n  offset: number;\r\n};\r\n\r\nconst withOffsetLimit = (\r\n  params: Params\r\n): [ParamsWithLimits, { page: number; pageSize: number }] => {\r\n  const { page, pageSize, ...rest } = withDefaultPagination(params);\r\n\r\n  const offset = Math.max(page - 1, 0) * pageSize;\r\n  const limit = pageSize;\r\n\r\n  const query = {\r\n    ...rest,\r\n    limit,\r\n    offset,\r\n  };\r\n\r\n  return [query, { page, pageSize }];\r\n};\r\n\r\nexport const createRepository = (uid: string, db: Database): Repository => {\r\n  return {\r\n    findOne(params = {}) {\r\n      return db.entityManager.findOne(uid, params);\r\n    },\r\n\r\n    findMany(params = {}) {\r\n      return db.entityManager.findMany(uid, params);\r\n    },\r\n\r\n    findWithCount(params = {}) {\r\n      return Promise.all([\r\n        db.entityManager.findMany(uid, params),\r\n        db.entityManager.count(uid, params),\r\n      ]);\r\n    },\r\n\r\n    async findPage(params) {\r\n      const [query, { page, pageSize }] = withOffsetLimit(params);\r\n\r\n      const [results, total] = await Promise.all([\r\n        db.entityManager.findMany(uid, query),\r\n        db.entityManager.count(uid, query),\r\n      ]);\r\n\r\n      return {\r\n        results,\r\n        pagination: {\r\n          page,\r\n          pageSize,\r\n          pageCount: Math.ceil(total / pageSize),\r\n          total,\r\n        },\r\n      };\r\n    },\r\n\r\n    create(params) {\r\n      return db.entityManager.create(uid, params);\r\n    },\r\n\r\n    createMany(params) {\r\n      return db.entityManager.createMany(uid, params);\r\n    },\r\n\r\n    update(params) {\r\n      return db.entityManager.update(uid, params);\r\n    },\r\n\r\n    updateMany(params) {\r\n      return db.entityManager.updateMany(uid, params);\r\n    },\r\n\r\n    delete(params) {\r\n      return db.entityManager.delete(uid, params);\r\n    },\r\n\r\n    deleteMany(params = {}) {\r\n      return db.entityManager.deleteMany(uid, params);\r\n    },\r\n\r\n    count(params) {\r\n      return db.entityManager.count(uid, params);\r\n    },\r\n\r\n    attachRelations(id, data) {\r\n      return db.entityManager.attachRelations(uid, id, data);\r\n    },\r\n\r\n    async updateRelations(id, data) {\r\n      const trx = await db.transaction();\r\n      try {\r\n        await db.entityManager.updateRelations(uid, id, data, { transaction: trx.get() });\r\n        return await trx.commit();\r\n      } catch (e) {\r\n        await trx.rollback();\r\n        throw e;\r\n      }\r\n    },\r\n\r\n    deleteRelations(id) {\r\n      return db.entityManager.deleteRelations(uid, id);\r\n    },\r\n\r\n    populate(entity, populate) {\r\n      return db.entityManager.populate(uid, entity, populate);\r\n    },\r\n\r\n    load(entity, fields, params) {\r\n      return db.entityManager.load(uid, entity, fields, params);\r\n    },\r\n\r\n    async loadPages(entity, field, params) {\r\n      if (!isString(field)) {\r\n        throw new Error(`Invalid load. Expected ${field} to be a string`);\r\n      }\r\n\r\n      const { attributes } = db.metadata.get(uid);\r\n      const attribute = attributes[field];\r\n\r\n      if (\r\n        !attribute ||\r\n        attribute.type !== 'relation' ||\r\n        !attribute.relation ||\r\n        !['oneToMany', 'manyToMany'].includes(attribute.relation)\r\n      ) {\r\n        throw new Error(`Invalid load. Expected ${field} to be an anyToMany relational attribute`);\r\n      }\r\n\r\n      const [query, { page, pageSize }] = withOffsetLimit(params);\r\n\r\n      const [results, { count: total }] = await Promise.all([\r\n        db.entityManager.load(uid, entity, field, query),\r\n        db.entityManager.load(uid, entity, field, { ...query, count: true }),\r\n      ]);\r\n\r\n      return {\r\n        results,\r\n        pagination: {\r\n          page,\r\n          pageSize,\r\n          pageCount: Math.ceil(total / pageSize),\r\n          total,\r\n        },\r\n      };\r\n    },\r\n  };\r\n};\r\n","/* eslint-disable @typescript-eslint/naming-convention */ // allow __type\r\nimport { curry, groupBy, pipe, mapValues, map, isEmpty } from 'lodash/fp';\r\nimport type { Knex } from 'knex';\r\n\r\nimport { createQueryBuilder } from '../query';\r\nimport type { Database } from '..';\r\nimport type { MorphJoinTable, Relation } from '../types';\r\n\r\ntype Rows = Record<string, unknown>[];\r\n\r\nconst getMorphToManyRowsLinkedToMorphOne = (\r\n  rows: Rows,\r\n  {\r\n    uid,\r\n    attributeName,\r\n    typeColumn,\r\n    db,\r\n  }: {\r\n    uid: string;\r\n    attributeName: string;\r\n    typeColumn: { name: string };\r\n    db: Database;\r\n  }\r\n) =>\r\n  rows.filter((row) => {\r\n    const relatedType = row[typeColumn.name] as string;\r\n    const field = row.field as any;\r\n\r\n    const targetAttribute = db.metadata.get(relatedType).attributes[field] as Relation.MorphOne;\r\n\r\n    // ensure targeted field is the right one + check if it is a morphOne\r\n    return (\r\n      targetAttribute?.target === uid &&\r\n      targetAttribute?.morphBy === attributeName &&\r\n      targetAttribute?.relation === 'morphOne'\r\n    );\r\n  });\r\n\r\nexport const deleteRelatedMorphOneRelationsAfterMorphToManyUpdate = async (\r\n  rows: Rows,\r\n  {\r\n    uid,\r\n    attributeName,\r\n    joinTable,\r\n    db,\r\n    transaction: trx,\r\n  }: {\r\n    uid: string;\r\n    attributeName: string;\r\n    joinTable: MorphJoinTable;\r\n    db: Database;\r\n    transaction?: Knex.Transaction;\r\n  }\r\n) => {\r\n  const { morphColumn } = joinTable;\r\n  const { idColumn, typeColumn } = morphColumn;\r\n\r\n  const morphOneRows = getMorphToManyRowsLinkedToMorphOne(rows, {\r\n    uid,\r\n    attributeName,\r\n    typeColumn,\r\n    db,\r\n  });\r\n\r\n  const groupByType = groupBy(typeColumn.name);\r\n  const groupByField = groupBy('field');\r\n\r\n  const typeAndFieldIdsGrouped = pipe(groupByType, mapValues(groupByField))(morphOneRows);\r\n\r\n  const orWhere: object[] = [];\r\n\r\n  for (const [type, v] of Object.entries(typeAndFieldIdsGrouped)) {\r\n    for (const [field, arr] of Object.entries(v)) {\r\n      orWhere.push({\r\n        [typeColumn.name]: type,\r\n        field,\r\n        [idColumn.name]: { $in: map(idColumn.name, arr) },\r\n      });\r\n    }\r\n  }\r\n\r\n  if (!isEmpty(orWhere)) {\r\n    await createQueryBuilder(joinTable.name, db)\r\n      .delete()\r\n      .where({ $or: orWhere })\r\n      .transacting(trx)\r\n      .execute();\r\n  }\r\n};\r\n\r\n/**\r\n * Encoding utilities for polymorphic relations.\r\n *\r\n * In some scenarios is useful to encode both the id & __type of the relation\r\n * to have a unique identifier for the relation. (e.g. relations reordering)\r\n */\r\n\r\nexport const encodePolymorphicId = (id: number | string, __type: string) => {\r\n  return `${id}:::${__type}`;\r\n};\r\n\r\nexport const encodePolymorphicRelation = curry(({ idColumn, typeColumn }, relation?: any): any => {\r\n  // Encode the id of the relation and the positional argument if it exist\r\n  const newRelation = {\r\n    ...relation,\r\n    [idColumn]: encodePolymorphicId(relation[idColumn], relation[typeColumn]),\r\n  };\r\n\r\n  if (relation.position) {\r\n    const { before, after } = relation.position;\r\n    const __type = relation.position.__type || relation.__type;\r\n\r\n    newRelation.position = { ...relation.position };\r\n\r\n    if (before) newRelation.position.before = encodePolymorphicId(before, __type);\r\n    if (after) newRelation.position.after = encodePolymorphicId(after, __type);\r\n  }\r\n\r\n  return newRelation;\r\n});\r\n","/* eslint-disable @typescript-eslint/no-namespace */\r\nimport { map, isEmpty } from 'lodash/fp';\r\nimport type { Knex } from 'knex';\r\n\r\nimport {\r\n  isBidirectional,\r\n  isOneToAny,\r\n  isManyToAny,\r\n  isAnyToOne,\r\n  hasOrderColumn,\r\n  hasInverseOrderColumn,\r\n} from '../metadata';\r\nimport { createQueryBuilder } from '../query';\r\nimport { addSchema } from '../utils/knex';\r\nimport type { Database } from '..';\r\nimport type { ID, Relation, Model } from '../types';\r\n\r\ndeclare module 'knex' {\r\n  namespace Knex {\r\n    interface ChainableInterface {\r\n      transacting(trx?: Knex.Transaction): this;\r\n    }\r\n  }\r\n}\r\n\r\n//  TODO: This is a short term solution, to not steal relations from the same document.\r\nconst getDocumentSiblingIdsQuery = (tableName: string, id: ID) => {\r\n  // Find if the model is a content type or something else (e.g. component)\r\n  // to only get the documentId if it's a content type\r\n  const models: Model[] = Array.from(strapi.db.metadata.values());\r\n\r\n  const isContentType = models.find((model) => {\r\n    return model.tableName === tableName && model.attributes.documentId;\r\n  });\r\n\r\n  if (!isContentType) {\r\n    return [id];\r\n  }\r\n\r\n  // NOTE: SubQueries are wrapped in a function to not reuse the same connection,\r\n  // which causes infinite self references\r\n  return function (query) {\r\n    query\r\n      .select('id')\r\n      .from(tableName)\r\n      // Get all child ids of the document id\r\n      .whereIn('document_id', (documentIDSubQuery) => {\r\n        documentIDSubQuery\r\n          .from(tableName)\r\n          // get document id related to the current id\r\n          .select('document_id')\r\n          .where('id', id);\r\n      });\r\n  } satisfies Knex.QueryCallback;\r\n};\r\n\r\n/**\r\n * If some relations currently exist for this oneToX relation, on the one side, this function removes them and update the inverse order if needed.\r\n */\r\nconst deletePreviousOneToAnyRelations = async ({\r\n  id,\r\n  attribute,\r\n  relIdsToadd,\r\n  db,\r\n  transaction: trx,\r\n}: {\r\n  id: ID;\r\n  attribute: Relation.Bidirectional;\r\n  relIdsToadd: ID[];\r\n  db: Database;\r\n  transaction?: Knex.Transaction;\r\n}) => {\r\n  if (!(isBidirectional(attribute) && isOneToAny(attribute))) {\r\n    throw new Error(\r\n      'deletePreviousOneToAnyRelations can only be called for bidirectional oneToAny relations'\r\n    );\r\n  }\r\n  const { joinTable } = attribute;\r\n  const { joinColumn, inverseJoinColumn } = joinTable;\r\n\r\n  const con = db.getConnection();\r\n\r\n  await con\r\n    .delete()\r\n    .from(joinTable.name)\r\n    // Exclude the ids of the current document\r\n    .whereNotIn(joinColumn.name, getDocumentSiblingIdsQuery(joinColumn.referencedTable!, id))\r\n    // Include all the ids that are being connected\r\n    .whereIn(inverseJoinColumn.name, relIdsToadd)\r\n    .where(joinTable.on || {})\r\n    .transacting(trx);\r\n\r\n  await cleanOrderColumns({ attribute, db, inverseRelIds: relIdsToadd, transaction: trx });\r\n};\r\n\r\n/**\r\n * If a relation currently exists for this xToOne relations, this function removes it and update the inverse order if needed.\r\n */\r\nconst deletePreviousAnyToOneRelations = async ({\r\n  id,\r\n  attribute,\r\n  relIdToadd,\r\n  db,\r\n  transaction: trx,\r\n}: {\r\n  id: ID;\r\n  attribute: Relation.Bidirectional;\r\n  relIdToadd: ID;\r\n  db: Database;\r\n  transaction?: Knex.Transaction;\r\n}) => {\r\n  const { joinTable } = attribute;\r\n  const { joinColumn, inverseJoinColumn } = joinTable;\r\n  const con = db.getConnection();\r\n\r\n  if (!isAnyToOne(attribute)) {\r\n    throw new Error('deletePreviousAnyToOneRelations can only be called for anyToOne relations');\r\n  }\r\n  // handling manyToOne\r\n  if (isManyToAny(attribute)) {\r\n    // if the database integrity was not broken relsToDelete is supposed to be of length 1\r\n    const relsToDelete = await con\r\n      .select(inverseJoinColumn.name)\r\n      .from(joinTable.name)\r\n      .where(joinColumn.name, id)\r\n      .whereNotIn(\r\n        inverseJoinColumn.name,\r\n        getDocumentSiblingIdsQuery(inverseJoinColumn.referencedTable!, relIdToadd)\r\n      )\r\n      .where(joinTable.on || {})\r\n      .transacting(trx);\r\n\r\n    const relIdsToDelete = map(inverseJoinColumn.name, relsToDelete);\r\n\r\n    await createQueryBuilder(joinTable.name, db)\r\n      .delete()\r\n      .where({\r\n        [joinColumn.name]: id,\r\n        [inverseJoinColumn.name]: { $in: relIdsToDelete },\r\n      })\r\n      .where(joinTable.on || {})\r\n      .transacting(trx)\r\n      .execute();\r\n\r\n    await cleanOrderColumns({ attribute, db, inverseRelIds: relIdsToDelete, transaction: trx });\r\n\r\n    // handling oneToOne\r\n  } else {\r\n    await con\r\n      .delete()\r\n      .from(joinTable.name)\r\n      .where(joinColumn.name, id)\r\n      // Exclude the ids of the current document\r\n      .whereNotIn(\r\n        inverseJoinColumn.name,\r\n        getDocumentSiblingIdsQuery(inverseJoinColumn.referencedTable!, relIdToadd)\r\n      )\r\n      .where(joinTable.on || {})\r\n      .transacting(trx);\r\n  }\r\n};\r\n\r\n/**\r\n * Delete all or some relations of entity field\r\n */\r\nconst deleteRelations = async ({\r\n  id,\r\n  attribute,\r\n  db,\r\n  relIdsToNotDelete = [],\r\n  relIdsToDelete = [],\r\n  transaction: trx,\r\n}: {\r\n  id: ID;\r\n  attribute: Relation.Bidirectional;\r\n  db: Database;\r\n  relIdsToNotDelete?: ID[];\r\n  relIdsToDelete?: ID[] | 'all';\r\n  transaction?: Knex.Transaction;\r\n}) => {\r\n  const { joinTable } = attribute;\r\n  const { joinColumn, inverseJoinColumn } = joinTable;\r\n  const all = relIdsToDelete === 'all';\r\n\r\n  if (hasOrderColumn(attribute) || hasInverseOrderColumn(attribute)) {\r\n    let lastId: ID = 0;\r\n    let done = false;\r\n    const batchSize = 100;\r\n\r\n    while (!done) {\r\n      const batchToDelete: { id: ID }[] = await createQueryBuilder(joinTable.name, db)\r\n        .select(inverseJoinColumn.name)\r\n        .where({\r\n          [joinColumn.name]: id,\r\n          id: { $gt: lastId },\r\n          [inverseJoinColumn.name]: { $notIn: relIdsToNotDelete },\r\n          ...(all ? {} : { [inverseJoinColumn.name]: { $in: relIdsToDelete } }),\r\n        })\r\n        .where(joinTable.on || {})\r\n        .orderBy('id')\r\n        .limit(batchSize)\r\n        .transacting(trx)\r\n        .execute();\r\n\r\n      done = batchToDelete.length < batchSize;\r\n      lastId = batchToDelete[batchToDelete.length - 1]?.id || 0;\r\n\r\n      const batchIds = map(inverseJoinColumn.name, batchToDelete);\r\n\r\n      await createQueryBuilder(joinTable.name, db)\r\n        .delete()\r\n        .where({\r\n          [joinColumn.name]: id,\r\n          [inverseJoinColumn.name]: { $in: batchIds },\r\n        })\r\n        .where(joinTable.on || {})\r\n        .transacting(trx)\r\n        .execute();\r\n\r\n      await cleanOrderColumns({ attribute, db, id, inverseRelIds: batchIds, transaction: trx });\r\n    }\r\n  } else {\r\n    await createQueryBuilder(joinTable.name, db)\r\n      .delete()\r\n      .where({\r\n        [joinColumn.name]: id,\r\n        [inverseJoinColumn.name]: { $notIn: relIdsToNotDelete },\r\n        ...(all ? {} : { [inverseJoinColumn.name]: { $in: relIdsToDelete } }),\r\n      })\r\n      .where(joinTable.on || {})\r\n      .transacting(trx)\r\n      .execute();\r\n  }\r\n};\r\n\r\n/**\r\n * Clean the order columns by ensuring the order value are continuous (ex: 1, 2, 3 and not 1, 5, 10)\r\n */\r\nconst cleanOrderColumns = async ({\r\n  id,\r\n  attribute,\r\n  db,\r\n  inverseRelIds = [],\r\n  transaction: trx,\r\n}: {\r\n  id?: ID;\r\n  attribute: Relation.Bidirectional;\r\n  db: Database;\r\n  inverseRelIds?: ID[];\r\n  transaction?: Knex.Transaction;\r\n}) => {\r\n  if (\r\n    !(hasOrderColumn(attribute) && id) &&\r\n    !(hasInverseOrderColumn(attribute) && !isEmpty(inverseRelIds))\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  const { joinTable } = attribute;\r\n  const { joinColumn, inverseJoinColumn, orderColumnName, inverseOrderColumnName } = joinTable;\r\n\r\n  /**\r\n  UPDATE :joinTable: as a,\r\n  (\r\n    SELECT\r\n      id,\r\n      ROW_NUMBER() OVER ( PARTITION BY :joinColumn: ORDER BY :orderColumn:) AS src_order,\r\n    FROM :joinTable:\r\n    WHERE :joinColumn: = :id\r\n  ) AS b\r\n  SET :orderColumn: = b.src_order\r\n  WHERE b.id = a.id;\r\n  */\r\n  const updateOrderColumn = async () => {\r\n    if (!hasOrderColumn(attribute) || !id) {\r\n      return;\r\n    }\r\n\r\n    const selectRowsToOrder = (joinTableName: string) =>\r\n      db\r\n        .connection(joinTableName)\r\n        .select('id')\r\n        .rowNumber('src_order', orderColumnName, joinColumn.name)\r\n        .where(joinColumn.name, id)\r\n        .toSQL();\r\n\r\n    switch (strapi.db.dialect.client) {\r\n      case 'mysql': {\r\n        // Here it's MariaDB and MySQL 8\r\n        const select = selectRowsToOrder(joinTable.name);\r\n\r\n        await db\r\n          .getConnection()\r\n          .raw(\r\n            `UPDATE ?? as a, ( ${select.sql} ) AS b\r\n            SET ?? = b.src_order\r\n            WHERE b.id = a.id`,\r\n            [joinTable.name, ...select.bindings, orderColumnName]\r\n          )\r\n          .transacting(trx);\r\n\r\n        break;\r\n      }\r\n      default: {\r\n        const joinTableName = addSchema(db, joinTable.name);\r\n        const select = selectRowsToOrder(joinTableName);\r\n\r\n        // raw query as knex doesn't allow updating from a subquery\r\n        await db.connection\r\n          .raw(\r\n            `UPDATE ?? as a\r\n            SET ?? = b.src_order\r\n            FROM ( ${select.sql} ) AS b\r\n            WHERE b.id = a.id`,\r\n            [joinTableName, orderColumnName, ...select.bindings]\r\n          )\r\n          .transacting(trx);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n  UPDATE :joinTable: as a,\r\n  (\r\n    SELECT\r\n      id,\r\n      ROW_NUMBER() OVER ( PARTITION BY :inverseJoinColumn: ORDER BY :inverseOrderColumn:) AS inv_order\r\n    FROM :joinTable:\r\n    WHERE :inverseJoinColumn: IN (:inverseRelIds)\r\n  ) AS b\r\n  SET :inverseOrderColumn: = b.inv_order\r\n  WHERE b.id = a.id;\r\n  */\r\n  const updateInverseOrderColumn = async () => {\r\n    if (!hasInverseOrderColumn(attribute) || isEmpty(inverseRelIds)) return;\r\n\r\n    const selectRowsToOrder = (joinTableName: string) =>\r\n      db\r\n        .connection(joinTableName)\r\n        .select('id')\r\n        .rowNumber('inv_order', inverseOrderColumnName, inverseJoinColumn.name)\r\n        .where(inverseJoinColumn.name, 'in', inverseRelIds)\r\n        .toSQL();\r\n\r\n    switch (strapi.db.dialect.client) {\r\n      case 'mysql': {\r\n        // Here it's MariaDB and MySQL 8\r\n        const select = selectRowsToOrder(joinTable.name);\r\n\r\n        await db\r\n          .getConnection()\r\n          .raw(\r\n            `UPDATE ?? as a, ( ${select.sql} ) AS b\r\n            SET ?? = b.inv_order\r\n            WHERE b.id = a.id`,\r\n            [joinTable.name, ...select.bindings, inverseOrderColumnName]\r\n          )\r\n          .transacting(trx);\r\n        break;\r\n      }\r\n      default: {\r\n        const joinTableName = addSchema(db, joinTable.name);\r\n        const select = selectRowsToOrder(joinTableName);\r\n\r\n        // raw query as knex doesn't allow updating from a subquery\r\n        await db.connection\r\n          .raw(\r\n            `UPDATE ?? as a\r\n            SET ?? = b.inv_order\r\n            FROM ( ${select.sql} ) AS b\r\n            WHERE b.id = a.id`,\r\n            [joinTableName, inverseOrderColumnName, ...select.bindings]\r\n          )\r\n          .transacting(trx);\r\n      }\r\n    }\r\n  };\r\n\r\n  return Promise.all([updateOrderColumn(), updateInverseOrderColumn()]);\r\n};\r\n\r\nexport {\r\n  deletePreviousOneToAnyRelations,\r\n  deletePreviousAnyToOneRelations,\r\n  deleteRelations,\r\n  cleanOrderColumns,\r\n};\r\n","import { castArray, maxBy } from 'lodash/fp';\r\nimport _ from 'lodash';\r\n\r\nimport { InvalidRelationError } from '../errors';\r\nimport type { ID } from '../types';\r\n\r\ninterface Link {\r\n  id: ID;\r\n  position?: { before?: ID; after?: ID; start?: true; end?: true };\r\n  order?: number;\r\n  __component?: string;\r\n}\r\n\r\ninterface OrderedLink extends Link {\r\n  init?: boolean;\r\n  order: number;\r\n}\r\n\r\n/**\r\n * When connecting relations, the order you connect them matters.\r\n *\r\n * Example, if you connect the following relations:\r\n *   { id: 5, position: { before: 1 } }\r\n *   { id: 1, position: { before: 2 } }\r\n *   { id: 2, position: { end: true } }\r\n *\r\n * Going through the connect array, id 5 has to be connected before id 1,\r\n * so the order of id5 = id1 - 1. But the order value of id 1 is unknown.\r\n * The only way to know the order of id 1 is to connect it first.\r\n *\r\n * This function makes sure the relations are connected in the right order:\r\n *   { id: 2, position: { end: true } }\r\n *   { id: 1, position: { before: 2 } }\r\n *   { id: 5, position: { before: 1 } }\r\n *\r\n */\r\nconst sortConnectArray = (connectArr: Link[], initialArr: Link[] = [], strictSort = true) => {\r\n  const sortedConnect: Link[] = [];\r\n  // Boolean to know if we have to recalculate the order of the relations\r\n  let needsSorting = false;\r\n  // Map to validate if relation is already in sortedConnect or DB.\r\n  const relationInInitialArray = initialArr.reduce(\r\n    (acc, rel) => ({ ...acc, [rel.id]: true }),\r\n    {} as Record<ID, boolean>\r\n  );\r\n  // Map to store the first index where a relation id is connected\r\n  const mappedRelations = connectArr.reduce(\r\n    (mapper, relation: Link) => {\r\n      const adjacentRelId = relation.position?.before || relation.position?.after;\r\n\r\n      if (!adjacentRelId || (!relationInInitialArray[adjacentRelId] && !mapper[adjacentRelId])) {\r\n        needsSorting = true;\r\n      }\r\n\r\n      /**\r\n       * We do not allow duplicate relations to be connected, so we need to check for uniqueness with components\r\n       * Note that the id here includes the uid for polymorphic relations\r\n       *\r\n       * So for normal relations, the same id means the same relation\r\n       * For component relations, it means the unique combo of (id, component name)\r\n       */\r\n\r\n      // Check if there's an existing relation with this id\r\n      const existingRelation = mapper[relation.id];\r\n\r\n      // Check if existing relation has a component or not\r\n      const hasNoComponent = existingRelation && !('__component' in existingRelation);\r\n\r\n      // Check if the existing relation has the same component as the new relation\r\n      const hasSameComponent =\r\n        existingRelation && existingRelation.__component === relation.__component;\r\n\r\n      // If we have an existing relation that is not unique (no component or same component) we won't accept it\r\n      if (existingRelation && (hasNoComponent || hasSameComponent)) {\r\n        throw new InvalidRelationError(\r\n          `The relation with id ${relation.id} is already connected. ` +\r\n            'You cannot connect the same relation twice.'\r\n        );\r\n      }\r\n\r\n      return {\r\n        [relation.id]: { ...relation, computed: false },\r\n        ...mapper,\r\n      };\r\n    },\r\n    {} as Record<ID, Link & { computed: boolean }>\r\n  );\r\n\r\n  // If we don't need to sort the connect array, we can return it as is\r\n  if (!needsSorting) return connectArr;\r\n\r\n  // Recursively compute in which order the relation should be connected\r\n  const computeRelation = (relation: Link, relationsSeenInBranch: Record<ID, boolean>) => {\r\n    const adjacentRelId = relation.position?.before || relation.position?.after;\r\n    const adjacentRelation = mappedRelations[adjacentRelId as ID];\r\n\r\n    // If the relation has already been seen in the current branch,\r\n    // it means there is a circular reference\r\n    if (adjacentRelId && relationsSeenInBranch[adjacentRelId]) {\r\n      throw new InvalidRelationError(\r\n        'A circular reference was found in the connect array. ' +\r\n          'One relation is trying to connect before/after another one that is trying to connect before/after it'\r\n      );\r\n    }\r\n\r\n    // This relation has already been computed\r\n    if (mappedRelations[relation.id]?.computed) {\r\n      return;\r\n    }\r\n\r\n    mappedRelations[relation.id].computed = true;\r\n\r\n    // Relation does not have a before or after attribute or is in the initial array\r\n    if (!adjacentRelId || relationInInitialArray[adjacentRelId]) {\r\n      sortedConnect.push(relation);\r\n      return;\r\n    }\r\n\r\n    // Look if id is referenced elsewhere in the array\r\n    if (mappedRelations[adjacentRelId]) {\r\n      computeRelation(adjacentRelation, { ...relationsSeenInBranch, [relation.id]: true });\r\n      sortedConnect.push(relation);\r\n    } else if (strictSort) {\r\n      // If we reach this point, it means that the adjacent relation is not in the connect array\r\n      // and it is not in the database.\r\n      throw new InvalidRelationError(\r\n        `There was a problem connecting relation with id ${\r\n          relation.id\r\n        } at position ${JSON.stringify(\r\n          relation.position\r\n        )}. The relation with id ${adjacentRelId} needs to be connected first.`\r\n      );\r\n    } else {\r\n      // We are in non-strict mode so we can push the relation.\r\n      sortedConnect.push({ id: relation.id, position: { end: true } });\r\n    }\r\n  };\r\n\r\n  // Iterate over connectArr and populate sortedConnect\r\n  connectArr.forEach((relation) => computeRelation(relation, {}));\r\n\r\n  return sortedConnect;\r\n};\r\n\r\n/**\r\n * Responsible for calculating the relations order when connecting them.\r\n *\r\n * The connect method takes an array of relations with positional attributes:\r\n * - before: the id of the relation to connect before\r\n * - after: the id of the relation to connect after\r\n * - end: it should be at the end\r\n * - start: it should be at the start\r\n *\r\n * Example:\r\n *  - Having a connect array like:\r\n *      [ { id: 4, before: 2 }, { id: 4, before: 3}, {id: 5, before: 4} ]\r\n * - With the initial relations:\r\n *      [ { id: 2, order: 4 }, { id: 3, order: 10 } ]\r\n * - Step by step, going through the connect array, the array of relations would be:\r\n *      [ { id: 4, order: 3.5 }, { id: 2, order: 4 }, { id: 3, order: 10 } ]\r\n *      [ { id: 2, order: 4 }, { id: 4, order: 3.5 }, { id: 3, order: 10 } ]\r\n *      [ { id: 2, order: 4 }, { id: 5, order: 3.5 },  { id: 4, order: 3.5 }, { id: 3, order: 10 } ]\r\n * - The final step would be to recalculate fractional order values.\r\n *      [ { id: 2, order: 4 }, { id: 5, order: 3.33 },  { id: 4, order: 3.66 }, { id: 3, order: 10 } ]\r\n *\r\n * @param {Array<*>} initArr - array of relations to initialize the class with\r\n * @param {string} idColumn - the column name of the id\r\n * @param {string} orderColumn - the column name of the order\r\n * @param {boolean} strict - if true, will throw an error if a relation is connected adjacent to\r\n *                               another one that does not exist\r\n * @return {*}\r\n */\r\nconst relationsOrderer = <TRelation extends Record<string, ID | number | null>>(\r\n  initArr: TRelation[],\r\n  idColumn: keyof TRelation,\r\n  orderColumn: keyof TRelation,\r\n  strict?: boolean\r\n) => {\r\n  const computedRelations: OrderedLink[] = castArray(initArr ?? []).map((r) => ({\r\n    init: true,\r\n    id: r[idColumn] as ID,\r\n    order: Number(r[orderColumn]) || 1,\r\n  }));\r\n\r\n  const maxOrder = maxBy('order', computedRelations)?.order || 0;\r\n\r\n  const findRelation = (id: ID) => {\r\n    const idx = computedRelations.findIndex((r) => r.id === id);\r\n    return { idx, relation: computedRelations[idx] };\r\n  };\r\n\r\n  const removeRelation = (r: Link) => {\r\n    const { idx } = findRelation(r.id);\r\n    if (idx >= 0) {\r\n      computedRelations.splice(idx, 1);\r\n    }\r\n  };\r\n\r\n  const insertRelation = (r: Link) => {\r\n    let idx;\r\n\r\n    if (r.position?.before) {\r\n      const { idx: _idx, relation } = findRelation(r.position.before);\r\n      if (relation.init) {\r\n        r.order = relation.order - 0.5;\r\n      } else {\r\n        r.order = relation.order;\r\n      }\r\n      idx = _idx;\r\n    } else if (r.position?.after) {\r\n      const { idx: _idx, relation } = findRelation(r.position.after);\r\n      if (relation.init) {\r\n        r.order = relation.order + 0.5;\r\n      } else {\r\n        r.order = relation.order;\r\n      }\r\n\r\n      idx = _idx + 1;\r\n    } else if (r.position?.start) {\r\n      r.order = 0.5;\r\n      idx = 0;\r\n    } else {\r\n      r.order = maxOrder + 0.5;\r\n      idx = computedRelations.length;\r\n    }\r\n\r\n    // Insert the relation in the array\r\n    computedRelations.splice(idx, 0, r as OrderedLink);\r\n  };\r\n\r\n  return {\r\n    disconnect(relations: Link | Link[]) {\r\n      castArray(relations).forEach((relation) => {\r\n        removeRelation(relation);\r\n      });\r\n      return this;\r\n    },\r\n    connect(relations: Link | Link[]) {\r\n      sortConnectArray(castArray(relations), computedRelations, strict).forEach((relation) => {\r\n        this.disconnect(relation);\r\n\r\n        try {\r\n          insertRelation(relation);\r\n        } catch (err) {\r\n          throw new Error(\r\n            `There was a problem connecting relation with id ${\r\n              relation.id\r\n            } at position ${JSON.stringify(\r\n              relation.position\r\n            )}. The list of connect relations is not valid`\r\n          );\r\n        }\r\n      });\r\n      return this;\r\n    },\r\n    get() {\r\n      return computedRelations;\r\n    },\r\n    /**\r\n     * Get a map between the relation id and its order\r\n     */\r\n    getOrderMap() {\r\n      return _(computedRelations)\r\n        .groupBy('order')\r\n        .reduce(\r\n          (acc, relations) => {\r\n            if (relations[0]?.init) return acc;\r\n            relations.forEach((relation, idx) => {\r\n              acc[relation.id] = Math.floor(relation.order) + (idx + 1) / (relations.length + 1);\r\n            });\r\n            return acc;\r\n          },\r\n          {} as Record<ID, number>\r\n        );\r\n    },\r\n  };\r\n};\r\n\r\nexport { relationsOrderer, sortConnectArray };\r\n","import {\r\n  castArray,\r\n  compact,\r\n  difference,\r\n  differenceWith,\r\n  has,\r\n  isArray,\r\n  isEmpty,\r\n  isEqual,\r\n  isInteger,\r\n  isNil,\r\n  isNull,\r\n  isNumber,\r\n  isObject,\r\n  isPlainObject,\r\n  isString,\r\n  isUndefined,\r\n  map,\r\n  pick,\r\n  uniqBy,\r\n  uniqWith,\r\n} from 'lodash/fp';\r\n\r\nimport * as types from '../utils/types';\r\nimport { createField } from '../fields';\r\nimport { createQueryBuilder } from '../query';\r\nimport { createRepository } from './entity-repository';\r\nimport {\r\n  deleteRelatedMorphOneRelationsAfterMorphToManyUpdate,\r\n  encodePolymorphicRelation,\r\n  encodePolymorphicId,\r\n} from './morph-relations';\r\nimport {\r\n  isBidirectional,\r\n  isAnyToOne,\r\n  isOneToAny,\r\n  hasOrderColumn,\r\n  hasInverseOrderColumn,\r\n} from '../metadata';\r\nimport {\r\n  deletePreviousOneToAnyRelations,\r\n  deletePreviousAnyToOneRelations,\r\n  deleteRelations,\r\n  cleanOrderColumns,\r\n} from './regular-relations';\r\nimport { relationsOrderer } from './relations-orderer';\r\nimport type { Database } from '..';\r\nimport type { Meta } from '../metadata';\r\nimport type { ID } from '../types';\r\nimport { EntityManager, Repository, Entity } from './types';\r\n\r\nexport * from './types';\r\n\r\nconst isRecord = (value: unknown): value is Record<string, unknown> =>\r\n  isObject(value) && !isNil(value);\r\n\r\nconst toId = (value: unknown | { id: unknown }): ID => {\r\n  if (isRecord(value) && 'id' in value && isValidId(value.id)) {\r\n    return value.id;\r\n  }\r\n\r\n  if (isValidId(value)) {\r\n    return value;\r\n  }\r\n\r\n  throw new Error(`Invalid id, expected a string or integer, got ${JSON.stringify(value)}`);\r\n};\r\nconst toIds = (value: unknown): ID[] => castArray(value || []).map(toId);\r\n\r\nconst isValidId = (value: unknown): value is ID => isString(value) || isInteger(value);\r\n\r\nconst isValidObjectId = (value: unknown): value is Entity =>\r\n  isRecord(value) && 'id' in value && isValidId(value.id);\r\n\r\nconst toIdArray = (\r\n  data: unknown\r\n): {\r\n  id: ID;\r\n  __pivot?: { [key: string]: any };\r\n  [key: string]: any;\r\n}[] => {\r\n  const array = castArray(data)\r\n    .filter((datum) => !isNil(datum))\r\n    .map((datum) => {\r\n      // if it is a string or an integer return an obj with id = to datum\r\n      if (isValidId(datum)) {\r\n        return { id: datum, __pivot: {} };\r\n      }\r\n\r\n      // if it is an object check it has at least a valid id\r\n      if (!isValidObjectId(datum)) {\r\n        throw new Error(`Invalid id, expected a string or integer, got ${datum}`);\r\n      }\r\n\r\n      return datum;\r\n    });\r\n\r\n  return uniqWith(isEqual, array);\r\n};\r\n\r\ntype ScalarAssoc = string | number | null;\r\ntype Assocs =\r\n  | ScalarAssoc\r\n  | { id: ScalarAssoc | Array<ScalarAssoc> }\r\n  | Array<ScalarAssoc>\r\n  | {\r\n      set?: Array<ScalarAssoc> | null;\r\n      options?: { strict?: boolean };\r\n      connect?: Array<{\r\n        id: ScalarAssoc;\r\n        position?: { start?: boolean; end?: boolean; before?: ID; after?: ID };\r\n        __pivot?: any;\r\n        __type?: any;\r\n      }> | null;\r\n      disconnect?: Array<ScalarAssoc> | null;\r\n    };\r\n\r\nconst toAssocs = (data: Assocs) => {\r\n  if (\r\n    isArray(data) ||\r\n    isString(data) ||\r\n    isNumber(data) ||\r\n    isNull(data) ||\r\n    (isRecord(data) && 'id' in data)\r\n  ) {\r\n    return {\r\n      set: isNull(data) ? data : toIdArray(data),\r\n    };\r\n  }\r\n\r\n  if (data?.set) {\r\n    return {\r\n      set: isNull(data.set) ? data.set : toIdArray(data.set),\r\n    };\r\n  }\r\n\r\n  return {\r\n    options: {\r\n      strict: data?.options?.strict,\r\n    },\r\n    connect: toIdArray(data?.connect).map((elm) => ({\r\n      id: elm.id,\r\n      position: elm.position ? elm.position : { end: true },\r\n      __pivot: elm.__pivot ?? {},\r\n      __type: elm.__type,\r\n    })),\r\n    disconnect: toIdArray(data?.disconnect),\r\n  };\r\n};\r\n\r\nconst processData = (\r\n  metadata: Meta,\r\n  data: Record<string, unknown> = {},\r\n  { withDefaults = false } = {}\r\n) => {\r\n  const { attributes } = metadata;\r\n\r\n  const obj: Record<string, unknown> = {};\r\n\r\n  for (const attributeName of Object.keys(attributes)) {\r\n    const attribute = attributes[attributeName];\r\n\r\n    if (types.isScalarAttribute(attribute)) {\r\n      const field = createField(attribute);\r\n\r\n      if (isUndefined(data[attributeName])) {\r\n        if (!isUndefined(attribute.default) && withDefaults) {\r\n          if (typeof attribute.default === 'function') {\r\n            obj[attributeName] = attribute.default();\r\n          } else {\r\n            obj[attributeName] = attribute.default;\r\n          }\r\n        }\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        'validate' in field &&\r\n        typeof field.validate === 'function' &&\r\n        data[attributeName] !== null\r\n      ) {\r\n        field.validate(data[attributeName]);\r\n      }\r\n\r\n      const val = data[attributeName] === null ? null : field.toDB(data[attributeName]);\r\n\r\n      obj[attributeName] = val;\r\n    }\r\n\r\n    if (types.isRelationalAttribute(attribute)) {\r\n      // oneToOne & manyToOne\r\n      if ('joinColumn' in attribute && attribute.joinColumn && attribute.owner) {\r\n        const joinColumnName = attribute.joinColumn.name;\r\n\r\n        // allow setting to null\r\n        const attrValue = !isUndefined(data[attributeName])\r\n          ? data[attributeName]\r\n          : data[joinColumnName];\r\n\r\n        if (isNull(attrValue)) {\r\n          obj[joinColumnName] = attrValue;\r\n        } else if (!isUndefined(attrValue)) {\r\n          obj[joinColumnName] = toId(attrValue);\r\n        }\r\n\r\n        continue;\r\n      }\r\n\r\n      if ('morphColumn' in attribute && attribute.morphColumn && attribute.owner) {\r\n        const { idColumn, typeColumn, typeField = '__type' } = attribute.morphColumn;\r\n\r\n        const value = data[attributeName] as Record<string, unknown>;\r\n\r\n        if (value === null) {\r\n          Object.assign(obj, {\r\n            [idColumn.name]: null,\r\n            [typeColumn.name]: null,\r\n          });\r\n\r\n          continue;\r\n        }\r\n\r\n        if (!isUndefined(value)) {\r\n          if (!has('id', value) || !has(typeField, value)) {\r\n            throw new Error(`Expects properties ${typeField} an id to make a morph association`);\r\n          }\r\n\r\n          Object.assign(obj, {\r\n            [idColumn.name]: value.id,\r\n            [typeColumn.name]: value[typeField],\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return obj;\r\n};\r\nexport const createEntityManager = (db: Database): EntityManager => {\r\n  const repoMap: Record<string, Repository> = {};\r\n\r\n  return {\r\n    async findOne(uid, params) {\r\n      const states = await db.lifecycles.run('beforeFindOne', uid, { params });\r\n\r\n      const result = await this.createQueryBuilder(uid)\r\n        .init(params)\r\n        .first()\r\n        .execute<Entity | null>();\r\n\r\n      await db.lifecycles.run('afterFindOne', uid, { params, result }, states);\r\n\r\n      return result;\r\n    },\r\n\r\n    // should we name it findOne because people are used to it ?\r\n    async findMany(uid, params) {\r\n      const states = await db.lifecycles.run('beforeFindMany', uid, { params });\r\n\r\n      const result = await this.createQueryBuilder(uid).init(params).execute<any[]>();\r\n\r\n      await db.lifecycles.run('afterFindMany', uid, { params, result }, states);\r\n\r\n      return result;\r\n    },\r\n\r\n    async count(uid, params = {}) {\r\n      const states = await db.lifecycles.run('beforeCount', uid, { params });\r\n\r\n      const res = await this.createQueryBuilder(uid)\r\n        .init(pick(['_q', 'where', 'filters'], params))\r\n        .count()\r\n        .first()\r\n        .execute<{ count: number }>();\r\n\r\n      const result = Number(res.count);\r\n\r\n      await db.lifecycles.run('afterCount', uid, { params, result }, states);\r\n\r\n      return result;\r\n    },\r\n\r\n    async create(uid, params = {}) {\r\n      const states = await db.lifecycles.run('beforeCreate', uid, { params });\r\n\r\n      const metadata = db.metadata.get(uid);\r\n      const { data } = params;\r\n\r\n      if (!isPlainObject(data)) {\r\n        throw new Error('Create expects a data object');\r\n      }\r\n\r\n      const dataToInsert = processData(metadata, data, { withDefaults: true });\r\n\r\n      const res = await this.createQueryBuilder(uid)\r\n        .insert(dataToInsert)\r\n        .execute<Array<ID | { id: ID }>>();\r\n\r\n      const id = isRecord(res[0]) ? res[0].id : res[0];\r\n\r\n      const trx = await strapi.db.transaction();\r\n      try {\r\n        await this.attachRelations(uid, id, data, { transaction: trx.get() });\r\n\r\n        await trx.commit();\r\n      } catch (e) {\r\n        await trx.rollback();\r\n        await this.createQueryBuilder(uid).where({ id }).delete().execute();\r\n        throw e;\r\n      }\r\n\r\n      // TODO: in case there is no select or populate specified return the inserted data ?\r\n      // TODO: do not trigger the findOne lifecycles ?\r\n      const result = await this.findOne(uid, {\r\n        where: { id },\r\n        select: params.select,\r\n        populate: params.populate,\r\n        filters: params.filters,\r\n      });\r\n\r\n      await db.lifecycles.run('afterCreate', uid, { params, result }, states);\r\n\r\n      return result;\r\n    },\r\n\r\n    // TODO: where do we handle relation processing for many queries ?\r\n    async createMany(uid, params = {}) {\r\n      const states = await db.lifecycles.run('beforeCreateMany', uid, { params });\r\n\r\n      const metadata = db.metadata.get(uid);\r\n      const { data } = params;\r\n\r\n      if (!isArray(data)) {\r\n        throw new Error('CreateMany expects data to be an array');\r\n      }\r\n\r\n      const dataToInsert = data.map((datum) =>\r\n        processData(metadata, datum, { withDefaults: true })\r\n      );\r\n\r\n      if (isEmpty(dataToInsert)) {\r\n        throw new Error('Nothing to insert');\r\n      }\r\n\r\n      const createdEntries = await this.createQueryBuilder(uid)\r\n        .insert(dataToInsert)\r\n        .execute<Array<ID | { id: ID }>>();\r\n\r\n      const result = {\r\n        count: data.length,\r\n        ids: createdEntries.map((entry) => (typeof entry === 'object' ? entry?.id : entry)),\r\n      };\r\n\r\n      await db.lifecycles.run('afterCreateMany', uid, { params, result }, states);\r\n\r\n      return result;\r\n    },\r\n\r\n    async update(uid, params = {}) {\r\n      const states = await db.lifecycles.run('beforeUpdate', uid, { params });\r\n\r\n      const metadata = db.metadata.get(uid);\r\n      const { where, data } = params;\r\n\r\n      if (!isPlainObject(data)) {\r\n        throw new Error('Update requires a data object');\r\n      }\r\n\r\n      if (isEmpty(where)) {\r\n        throw new Error('Update requires a where parameter');\r\n      }\r\n\r\n      const entity = await this.createQueryBuilder(uid)\r\n        .select('*')\r\n        .where(where)\r\n        .first()\r\n        .execute<{ id: ID }>({ mapResults: false });\r\n\r\n      if (!entity) {\r\n        return null;\r\n      }\r\n\r\n      const { id } = entity;\r\n\r\n      const dataToUpdate = processData(metadata, data);\r\n\r\n      if (!isEmpty(dataToUpdate)) {\r\n        await this.createQueryBuilder(uid).where({ id }).update(dataToUpdate).execute();\r\n      }\r\n\r\n      const trx = await strapi.db.transaction();\r\n      try {\r\n        await this.updateRelations(uid, id, data, { transaction: trx.get() });\r\n        await trx.commit();\r\n      } catch (e) {\r\n        await trx.rollback();\r\n        await this.createQueryBuilder(uid).where({ id }).update(entity).execute();\r\n        throw e;\r\n      }\r\n\r\n      // TODO: do not trigger the findOne lifecycles ?\r\n      const result = await this.findOne(uid, {\r\n        where: { id },\r\n        select: params.select,\r\n        populate: params.populate,\r\n        filters: params.filters,\r\n      });\r\n\r\n      await db.lifecycles.run('afterUpdate', uid, { params, result }, states);\r\n\r\n      return result;\r\n    },\r\n\r\n    // TODO: where do we handle relation processing for many queries ?\r\n    async updateMany(uid, params = {}) {\r\n      const states = await db.lifecycles.run('beforeUpdateMany', uid, { params });\r\n\r\n      const metadata = db.metadata.get(uid);\r\n      const { where, data } = params;\r\n\r\n      const dataToUpdate = processData(metadata, data);\r\n\r\n      if (isEmpty(dataToUpdate)) {\r\n        throw new Error('Update requires data');\r\n      }\r\n\r\n      const updatedRows = await this.createQueryBuilder(uid)\r\n        .where(where)\r\n        .update(dataToUpdate)\r\n        .execute<number>();\r\n\r\n      const result = { count: updatedRows };\r\n\r\n      await db.lifecycles.run('afterUpdateMany', uid, { params, result }, states);\r\n\r\n      return result;\r\n    },\r\n\r\n    async delete(uid, params = {}) {\r\n      const states = await db.lifecycles.run('beforeDelete', uid, { params });\r\n\r\n      const { where, select, populate } = params;\r\n\r\n      if (isEmpty(where)) {\r\n        throw new Error('Delete requires a where parameter');\r\n      }\r\n\r\n      // TODO: do not trigger the findOne lifecycles ?\r\n      const entity = await this.findOne(uid, {\r\n        select: select && ['id'].concat(select),\r\n        where,\r\n        populate,\r\n      });\r\n\r\n      if (!entity) {\r\n        return null;\r\n      }\r\n\r\n      const { id } = entity;\r\n\r\n      await this.createQueryBuilder(uid).where({ id }).delete().execute();\r\n\r\n      const trx = await strapi.db.transaction();\r\n      try {\r\n        await this.deleteRelations(uid, id, { transaction: trx.get() });\r\n\r\n        await trx.commit();\r\n      } catch (e) {\r\n        await trx.rollback();\r\n        throw e;\r\n      }\r\n\r\n      await db.lifecycles.run('afterDelete', uid, { params, result: entity }, states);\r\n\r\n      return entity;\r\n    },\r\n\r\n    // TODO: where do we handle relation processing for many queries ?\r\n    async deleteMany(uid, params = {}) {\r\n      const states = await db.lifecycles.run('beforeDeleteMany', uid, { params });\r\n\r\n      const { where } = params;\r\n\r\n      const deletedRows = await this.createQueryBuilder(uid)\r\n        .where(where)\r\n        .delete()\r\n        .execute<number>();\r\n\r\n      const result = { count: deletedRows };\r\n\r\n      await db.lifecycles.run('afterDeleteMany', uid, { params, result }, states);\r\n\r\n      return result;\r\n    },\r\n\r\n    /**\r\n     * Attach relations to a new entity\r\n     */\r\n    async attachRelations(uid, id, data, options) {\r\n      const { attributes } = db.metadata.get(uid);\r\n      const { transaction: trx } = options ?? {};\r\n\r\n      for (const attributeName of Object.keys(attributes)) {\r\n        const attribute = attributes[attributeName];\r\n\r\n        const isValidLink = has(attributeName, data) && !isNil(data[attributeName]);\r\n\r\n        if (attribute.type !== 'relation' || !isValidLink) {\r\n          continue;\r\n        }\r\n\r\n        const cleanRelationData = toAssocs(data[attributeName]);\r\n\r\n        if (attribute.relation === 'morphOne' || attribute.relation === 'morphMany') {\r\n          /**\r\n           * morphOne and morphMany relations\r\n           */\r\n          const { target, morphBy } = attribute;\r\n\r\n          const targetAttribute = db.metadata.get(target).attributes[morphBy];\r\n          if (targetAttribute.type !== 'relation') {\r\n            throw new Error(\r\n              `Expected target attribute ${target}.${morphBy} to be a relation attribute`\r\n            );\r\n          }\r\n\r\n          if (targetAttribute.relation === 'morphToOne') {\r\n            // set columns\r\n            const { idColumn, typeColumn } = targetAttribute.morphColumn;\r\n\r\n            const relId = toId(cleanRelationData.set?.[0]);\r\n\r\n            await this.createQueryBuilder(target)\r\n              .update({ [idColumn.name]: id, [typeColumn.name]: uid })\r\n              .where({ id: relId })\r\n              .transacting(trx)\r\n              .execute();\r\n          } else if (targetAttribute.relation === 'morphToMany') {\r\n            const { joinTable } = targetAttribute;\r\n            const { joinColumn, morphColumn } = joinTable;\r\n\r\n            const { idColumn, typeColumn } = morphColumn;\r\n\r\n            if (isEmpty(cleanRelationData.set)) {\r\n              continue;\r\n            }\r\n\r\n            const rows =\r\n              cleanRelationData.set?.map((data, idx) => {\r\n                return {\r\n                  [joinColumn.name]: data.id,\r\n                  [idColumn.name]: id,\r\n                  [typeColumn.name]: uid,\r\n                  ...(('on' in joinTable && joinTable.on) || {}),\r\n                  ...(data.__pivot || {}),\r\n                  order: idx + 1,\r\n                  field: attributeName,\r\n                };\r\n              }) ?? [];\r\n\r\n            await this.createQueryBuilder(joinTable.name).insert(rows).transacting(trx).execute();\r\n          }\r\n\r\n          continue;\r\n        } else if (attribute.relation === 'morphToOne') {\r\n          /**\r\n           * morphToOne\r\n           */\r\n          // handled on the entry itself\r\n          continue;\r\n        } else if (attribute.relation === 'morphToMany') {\r\n          /**\r\n           * morphToMany\r\n           */\r\n          const { joinTable } = attribute;\r\n          const { joinColumn, morphColumn } = joinTable;\r\n\r\n          const { idColumn, typeColumn, typeField = '__type' } = morphColumn;\r\n\r\n          if (isEmpty(cleanRelationData.set) && isEmpty(cleanRelationData.connect)) {\r\n            continue;\r\n          }\r\n\r\n          // set happens before connect/disconnect\r\n          const dataset = cleanRelationData.set || cleanRelationData.connect || [];\r\n\r\n          const rows = dataset.map((data, idx) => ({\r\n            [joinColumn.name]: id,\r\n            [idColumn.name]: data.id,\r\n            [typeColumn.name]: data[typeField as '__type'],\r\n            ...(('on' in joinTable && joinTable.on) || {}),\r\n            ...(data.__pivot || {}),\r\n            order: idx + 1,\r\n          })) satisfies Record<string, any>[];\r\n\r\n          const orderMap = relationsOrderer(\r\n            [],\r\n            morphColumn.idColumn.name,\r\n            'order',\r\n            true // Always make a strict connect when inserting\r\n          )\r\n            .connect(\r\n              // Merge id & __type to get a single id key\r\n              dataset.map(encodePolymorphicRelation({ idColumn: 'id', typeColumn: '__type' }))\r\n            )\r\n            .get()\r\n            // set the order based on the order of the ids\r\n            .reduce((acc, rel, idx) => ({ ...acc, [rel.id]: idx }), {} as Record<ID, number>);\r\n\r\n          rows.forEach((row: Record<string, unknown>) => {\r\n            const rowId = row[morphColumn.idColumn.name] as ID;\r\n            const rowType = row[morphColumn.typeColumn.name] as string;\r\n            const encodedId = encodePolymorphicId(rowId, rowType);\r\n\r\n            row.order = orderMap[encodedId];\r\n          });\r\n\r\n          await this.createQueryBuilder(joinTable.name).insert(rows).transacting(trx).execute();\r\n\r\n          continue;\r\n        }\r\n\r\n        if ('joinColumn' in attribute && attribute.joinColumn && attribute.owner) {\r\n          const relIdsToAdd = toIds(cleanRelationData.set);\r\n          if (\r\n            attribute.relation === 'oneToOne' &&\r\n            isBidirectional(attribute) &&\r\n            relIdsToAdd.length\r\n          ) {\r\n            await this.createQueryBuilder(uid)\r\n              .where({ [attribute.joinColumn.name]: relIdsToAdd, id: { $ne: id } })\r\n              .update({ [attribute.joinColumn.name]: null })\r\n              .transacting(trx)\r\n              .execute();\r\n          }\r\n\r\n          continue;\r\n        }\r\n\r\n        // oneToOne oneToMany on the non owning side\r\n        if ('joinColumn' in attribute && attribute.joinColumn && !attribute.owner) {\r\n          // need to set the column on the target\r\n          const { target } = attribute;\r\n\r\n          // TODO: check it is an id & the entity exists (will throw due to FKs otherwise so not a big pbl in SQL)\r\n          const relIdsToAdd = toIds(cleanRelationData.set);\r\n\r\n          await this.createQueryBuilder(target)\r\n            .where({ [attribute.joinColumn.referencedColumn]: id })\r\n            .update({ [attribute.joinColumn.referencedColumn]: null })\r\n            .transacting(trx)\r\n            .execute();\r\n\r\n          await this.createQueryBuilder(target)\r\n            .update({ [attribute.joinColumn.referencedColumn]: id })\r\n            // NOTE: works if it is an array or a single id\r\n            .where({ id: relIdsToAdd })\r\n            .transacting(trx)\r\n            .execute();\r\n        }\r\n\r\n        if ('joinTable' in attribute && attribute.joinTable) {\r\n          // need to set the column on the target\r\n\r\n          const { joinTable } = attribute;\r\n          const { joinColumn, inverseJoinColumn, orderColumnName, inverseOrderColumnName } =\r\n            joinTable;\r\n\r\n          const relsToAdd = (cleanRelationData.set || cleanRelationData.connect) ?? [];\r\n          const relIdsToadd = toIds(relsToAdd);\r\n\r\n          if (isBidirectional(attribute) && isOneToAny(attribute)) {\r\n            await deletePreviousOneToAnyRelations({\r\n              id,\r\n              attribute,\r\n              relIdsToadd,\r\n              db,\r\n              transaction: trx,\r\n            });\r\n          }\r\n\r\n          // prepare new relations to insert\r\n          const insert = uniqBy('id', relsToAdd).map((data) => {\r\n            return {\r\n              [joinColumn.name]: id,\r\n              [inverseJoinColumn.name]: data.id,\r\n              ...(('on' in joinTable && joinTable.on) || {}),\r\n              ...(data.__pivot || {}),\r\n            };\r\n          }) satisfies Record<string, any>[];\r\n\r\n          // add order value\r\n          if (cleanRelationData.set && hasOrderColumn(attribute)) {\r\n            insert.forEach((data: Record<string, unknown>, idx) => {\r\n              data[orderColumnName] = idx + 1;\r\n            });\r\n          } else if (cleanRelationData.connect && hasOrderColumn(attribute)) {\r\n            // use position attributes to calculate order\r\n            const orderMap = relationsOrderer(\r\n              [],\r\n              inverseJoinColumn.name,\r\n              joinTable.orderColumnName,\r\n              true // Always make an strict connect when inserting\r\n            )\r\n              .connect(relsToAdd)\r\n              .get()\r\n              // set the order based on the order of the ids\r\n              .reduce((acc, rel, idx) => ({ ...acc, [rel.id]: idx }), {} as Record<ID, number>);\r\n\r\n            insert.forEach((row: Record<string, unknown>) => {\r\n              row[orderColumnName] = orderMap[row[inverseJoinColumn.name] as number];\r\n            });\r\n          }\r\n\r\n          // add inv_order value\r\n          if (hasInverseOrderColumn(attribute)) {\r\n            const maxResults = await db\r\n              .getConnection()\r\n              .select(inverseJoinColumn.name)\r\n              .max(inverseOrderColumnName, { as: 'max' })\r\n              .whereIn(inverseJoinColumn.name, relIdsToadd)\r\n              .where(joinTable.on || {})\r\n              .groupBy(inverseJoinColumn.name)\r\n              .from(joinTable.name)\r\n              .transacting(trx);\r\n\r\n            const maxMap = maxResults.reduce(\r\n              (acc, res) => Object.assign(acc, { [res[inverseJoinColumn.name]]: res.max }),\r\n              {} as Record<string, number>\r\n            );\r\n\r\n            insert.forEach((rel) => {\r\n              rel[inverseOrderColumnName] = (maxMap[rel[inverseJoinColumn.name]] || 0) + 1;\r\n            });\r\n          }\r\n\r\n          if (insert.length === 0) {\r\n            continue;\r\n          }\r\n\r\n          // insert new relations\r\n          await this.createQueryBuilder(joinTable.name).insert(insert).transacting(trx).execute();\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Updates relations of an existing entity\r\n     */\r\n    // TODO: check relation exists (handled by FKs except for polymorphics)\r\n    async updateRelations(uid, id, data, options) {\r\n      const { attributes } = db.metadata.get(uid);\r\n      const { transaction: trx } = options ?? {};\r\n\r\n      for (const attributeName of Object.keys(attributes)) {\r\n        const attribute = attributes[attributeName];\r\n\r\n        if (attribute.type !== 'relation' || !has(attributeName, data)) {\r\n          continue;\r\n        }\r\n        const cleanRelationData = toAssocs(data[attributeName]);\r\n\r\n        if (attribute.relation === 'morphOne' || attribute.relation === 'morphMany') {\r\n          const { target, morphBy } = attribute;\r\n\r\n          const targetAttribute = db.metadata.get(target).attributes[morphBy];\r\n\r\n          if (targetAttribute.type === 'relation' && targetAttribute.relation === 'morphToOne') {\r\n            // set columns\r\n            const { idColumn, typeColumn } = targetAttribute.morphColumn;\r\n\r\n            // update instead of deleting because the relation is directly on the entity table\r\n            // and not in a join table\r\n            await this.createQueryBuilder(target)\r\n              .update({ [idColumn.name]: null, [typeColumn.name]: null })\r\n              .where({ [idColumn.name]: id, [typeColumn.name]: uid })\r\n              .transacting(trx)\r\n              .execute();\r\n\r\n            if (!isNull(cleanRelationData.set)) {\r\n              const relId = toIds(cleanRelationData.set?.[0]);\r\n              await this.createQueryBuilder(target)\r\n                .update({ [idColumn.name]: id, [typeColumn.name]: uid })\r\n                .where({ id: relId })\r\n                .transacting(trx)\r\n                .execute();\r\n            }\r\n          } else if (\r\n            targetAttribute.type === 'relation' &&\r\n            targetAttribute.relation === 'morphToMany'\r\n          ) {\r\n            const { joinTable } = targetAttribute;\r\n            const { joinColumn, morphColumn } = joinTable;\r\n\r\n            const { idColumn, typeColumn } = morphColumn;\r\n\r\n            const hasSet = !isEmpty(cleanRelationData.set);\r\n            const hasConnect = !isEmpty(cleanRelationData.connect);\r\n            const hasDisconnect = !isEmpty(cleanRelationData.disconnect);\r\n\r\n            // for connect/disconnect without a set, only modify those relations\r\n            if (!hasSet && (hasConnect || hasDisconnect)) {\r\n              // delete disconnects and connects (to prevent duplicates when we add them later)\r\n              const idsToDelete = [\r\n                ...(cleanRelationData.disconnect || []),\r\n                ...(cleanRelationData.connect || []),\r\n              ];\r\n\r\n              if (!isEmpty(idsToDelete)) {\r\n                const where = {\r\n                  $or: idsToDelete.map((item: any) => {\r\n                    return {\r\n                      [idColumn.name]: id,\r\n                      [typeColumn.name]: uid,\r\n                      [joinColumn.name]: item.id,\r\n                      ...(joinTable.on || {}),\r\n                      field: attributeName,\r\n                    };\r\n                  }),\r\n                };\r\n\r\n                await this.createQueryBuilder(joinTable.name)\r\n                  .delete()\r\n                  .where(where)\r\n                  .transacting(trx)\r\n                  .execute();\r\n              }\r\n\r\n              // connect relations\r\n              if (hasConnect) {\r\n                // Query database to find the order of the last relation\r\n                const start = await this.createQueryBuilder(joinTable.name)\r\n                  .where({\r\n                    [idColumn.name]: id,\r\n                    [typeColumn.name]: uid,\r\n                    ...(joinTable.on || {}),\r\n                    ...(data.__pivot || {}),\r\n                  })\r\n                  .max('order')\r\n                  .first()\r\n                  .transacting(trx)\r\n                  .execute();\r\n\r\n                const startOrder = (start as any)?.max || 0;\r\n\r\n                const rows = (cleanRelationData.connect ?? []).map((data, idx) => ({\r\n                  [joinColumn.name]: data.id,\r\n                  [idColumn.name]: id,\r\n                  [typeColumn.name]: uid,\r\n                  ...(joinTable.on || {}),\r\n                  ...(data.__pivot || {}),\r\n                  order: startOrder + idx + 1,\r\n                  field: attributeName,\r\n                })) satisfies Record<string, any>[];\r\n\r\n                await this.createQueryBuilder(joinTable.name)\r\n                  .insert(rows)\r\n                  .transacting(trx)\r\n                  .execute();\r\n              }\r\n\r\n              continue;\r\n            }\r\n\r\n            // delete all relations\r\n            await this.createQueryBuilder(joinTable.name)\r\n              .delete()\r\n              .where({\r\n                [idColumn.name]: id,\r\n                [typeColumn.name]: uid,\r\n                ...(joinTable.on || {}),\r\n                field: attributeName,\r\n              })\r\n              .transacting(trx)\r\n              .execute();\r\n\r\n            if (hasSet) {\r\n              const rows = (cleanRelationData.set ?? []).map((data, idx) => ({\r\n                [joinColumn.name]: data.id,\r\n                [idColumn.name]: id,\r\n                [typeColumn.name]: uid,\r\n                ...(joinTable.on || {}),\r\n                ...(data.__pivot || {}),\r\n                order: idx + 1,\r\n                field: attributeName,\r\n              })) satisfies Record<string, any>[];\r\n\r\n              await this.createQueryBuilder(joinTable.name).insert(rows).transacting(trx).execute();\r\n            }\r\n          }\r\n\r\n          continue;\r\n        }\r\n\r\n        if (attribute.relation === 'morphToOne') {\r\n          // handled on the entry itself\r\n          continue;\r\n        }\r\n\r\n        if (attribute.relation === 'morphToMany') {\r\n          const { joinTable } = attribute;\r\n          const { joinColumn, morphColumn } = joinTable;\r\n\r\n          const { idColumn, typeColumn, typeField = '__type' } = morphColumn;\r\n\r\n          const hasSet = !isEmpty(cleanRelationData.set);\r\n          const hasConnect = !isEmpty(cleanRelationData.connect);\r\n          const hasDisconnect = !isEmpty(cleanRelationData.disconnect);\r\n\r\n          // for connect/disconnect without a set, only modify those relations\r\n          if (!hasSet && (hasConnect || hasDisconnect)) {\r\n            // delete disconnects and connects (to prevent duplicates when we add them later)\r\n            const idsToDelete = [\r\n              ...(cleanRelationData.disconnect || []),\r\n              ...(cleanRelationData.connect || []),\r\n            ];\r\n\r\n            const rowsToDelete = [\r\n              ...(cleanRelationData.disconnect ?? []).map((data, idx) => ({\r\n                [joinColumn.name]: id,\r\n                [idColumn.name]: data.id,\r\n                [typeColumn.name]: data[typeField],\r\n                ...(('on' in joinTable && joinTable.on) || {}),\r\n                ...(data.__pivot || {}),\r\n                order: idx + 1,\r\n              })),\r\n              ...(cleanRelationData.connect ?? []).map((data, idx) => ({\r\n                [joinColumn.name]: id,\r\n                [idColumn.name]: data.id,\r\n                // @ts-expect-error TODO\r\n                [typeColumn.name]: data[typeField],\r\n                ...(('on' in joinTable && joinTable.on) || {}),\r\n                ...(data.__pivot || {}),\r\n                order: idx + 1,\r\n              })),\r\n            ];\r\n\r\n            const adjacentRelations = await this.createQueryBuilder(joinTable.name)\r\n              .where({\r\n                $or: [\r\n                  {\r\n                    [joinColumn.name]: id,\r\n                    [idColumn.name]: {\r\n                      $in: compact(\r\n                        cleanRelationData.connect?.map(\r\n                          (r) => r.position?.after || r.position?.before\r\n                        )\r\n                      ),\r\n                    },\r\n                  },\r\n                  {\r\n                    [joinColumn.name]: id,\r\n                    order: this.createQueryBuilder(joinTable.name)\r\n                      .max('order')\r\n                      .where({ [joinColumn.name]: id })\r\n                      .where(joinTable.on || {})\r\n                      .transacting(trx)\r\n                      .getKnexQuery(),\r\n                  },\r\n                ],\r\n              })\r\n              .where(joinTable.on || {})\r\n              .transacting(trx)\r\n              .execute<Array<Record<string, any>>>();\r\n\r\n            if (!isEmpty(idsToDelete)) {\r\n              const where = {\r\n                $or: idsToDelete.map((item: any) => {\r\n                  return {\r\n                    [idColumn.name]: item.id,\r\n                    [typeColumn.name]: item[typeField],\r\n                    [joinColumn.name]: id,\r\n                    ...(joinTable.on || {}),\r\n                  };\r\n                }),\r\n              };\r\n\r\n              // delete previous relations\r\n              await this.createQueryBuilder(joinTable.name)\r\n                .delete()\r\n                .where(where)\r\n                .transacting(trx)\r\n                .execute();\r\n\r\n              await deleteRelatedMorphOneRelationsAfterMorphToManyUpdate(rowsToDelete as any, {\r\n                uid,\r\n                attributeName,\r\n                joinTable,\r\n                db,\r\n                transaction: trx,\r\n              });\r\n            }\r\n\r\n            // connect relations\r\n            if (hasConnect) {\r\n              const dataset = cleanRelationData.connect || [];\r\n\r\n              const rows = dataset.map((data) => ({\r\n                [joinColumn.name]: id,\r\n                [idColumn.name]: data.id,\r\n                [typeColumn.name]: data[typeField as '__type'],\r\n                ...(joinTable.on || {}),\r\n                ...(data.__pivot || {}),\r\n                field: attributeName,\r\n              })) satisfies Record<string, any>[];\r\n\r\n              const orderMap = relationsOrderer(\r\n                // Merge id & __type to get a single id key\r\n                adjacentRelations.map(\r\n                  encodePolymorphicRelation({\r\n                    idColumn: idColumn.name,\r\n                    typeColumn: typeColumn.name,\r\n                  })\r\n                ),\r\n                idColumn.name,\r\n                'order',\r\n                cleanRelationData.options?.strict\r\n              )\r\n                .connect(\r\n                  // Merge id & __type to get a single id key\r\n                  dataset.map(encodePolymorphicRelation({ idColumn: 'id', typeColumn: '__type' }))\r\n                )\r\n                .getOrderMap();\r\n\r\n              rows.forEach((row: Record<string, unknown>) => {\r\n                const rowId = row[idColumn.name] as number;\r\n                const rowType = row[typeColumn.name] as string;\r\n                const encodedId = encodePolymorphicId(rowId, rowType);\r\n\r\n                row.order = orderMap[encodedId];\r\n              });\r\n\r\n              await this.createQueryBuilder(joinTable.name).insert(rows).transacting(trx).execute();\r\n            }\r\n\r\n            continue;\r\n          }\r\n\r\n          if (hasSet) {\r\n            // delete all relations for this entity\r\n            await this.createQueryBuilder(joinTable.name)\r\n              .delete()\r\n              .where({\r\n                [joinColumn.name]: id,\r\n                ...(joinTable.on || {}),\r\n              })\r\n              .transacting(trx)\r\n              .execute();\r\n\r\n            const rows = (cleanRelationData.set ?? []).map((data, idx) => ({\r\n              [joinColumn.name]: id,\r\n              [idColumn.name]: data.id,\r\n              [typeColumn.name]: data[typeField],\r\n              field: attributeName,\r\n              ...(joinTable.on || {}),\r\n              ...(data.__pivot || {}),\r\n              order: idx + 1,\r\n            })) satisfies Record<string, any>[];\r\n\r\n            await deleteRelatedMorphOneRelationsAfterMorphToManyUpdate(rows, {\r\n              uid,\r\n              attributeName,\r\n              joinTable,\r\n              db,\r\n              transaction: trx,\r\n            });\r\n\r\n            await this.createQueryBuilder(joinTable.name).insert(rows).transacting(trx).execute();\r\n          }\r\n\r\n          continue;\r\n        }\r\n\r\n        if ('joinColumn' in attribute && attribute.joinColumn && attribute.owner) {\r\n          // handled in the row itself\r\n          continue;\r\n        }\r\n\r\n        // oneToOne oneToMany on the non owning side.\r\n        // Since it is a join column no need to remove previous relations\r\n        if ('joinColumn' in attribute && attribute.joinColumn && !attribute.owner) {\r\n          // need to set the column on the target\r\n          const { target } = attribute;\r\n\r\n          await this.createQueryBuilder(target)\r\n            .where({ [attribute.joinColumn.referencedColumn]: id })\r\n            .update({ [attribute.joinColumn.referencedColumn]: null })\r\n            .transacting(trx)\r\n            .execute();\r\n\r\n          if (!isNull(cleanRelationData.set)) {\r\n            const relIdsToAdd = toIds(cleanRelationData.set);\r\n            await this.createQueryBuilder(target)\r\n              .where({ id: relIdsToAdd })\r\n              .update({ [attribute.joinColumn.referencedColumn]: id })\r\n              .transacting(trx)\r\n              .execute();\r\n          }\r\n        }\r\n\r\n        if (attribute.joinTable) {\r\n          const { joinTable } = attribute;\r\n          const { joinColumn, inverseJoinColumn, orderColumnName, inverseOrderColumnName } =\r\n            joinTable;\r\n          const select = [joinColumn.name, inverseJoinColumn.name];\r\n          if (hasOrderColumn(attribute)) {\r\n            select.push(orderColumnName);\r\n          }\r\n          if (hasInverseOrderColumn(attribute)) {\r\n            select.push(inverseOrderColumnName);\r\n          }\r\n\r\n          // only delete relations\r\n          if (isNull(cleanRelationData.set)) {\r\n            await deleteRelations({ id, attribute, db, relIdsToDelete: 'all', transaction: trx });\r\n          } else {\r\n            const isPartialUpdate = !has('set', cleanRelationData);\r\n            let relIdsToaddOrMove: ID[];\r\n\r\n            if (isPartialUpdate) {\r\n              if (isAnyToOne(attribute)) {\r\n                // TODO: V5 find a fix to connect multiple versions of a document at the same time on xToOne relations\r\n                // cleanRelationData.connect = cleanRelationData.connect?.slice(-1);\r\n              }\r\n              relIdsToaddOrMove = toIds(cleanRelationData.connect);\r\n              const relIdsToDelete = toIds(\r\n                differenceWith(\r\n                  isEqual,\r\n                  cleanRelationData.disconnect,\r\n                  cleanRelationData.connect ?? []\r\n                )\r\n              );\r\n\r\n              if (!isEmpty(relIdsToDelete)) {\r\n                await deleteRelations({ id, attribute, db, relIdsToDelete, transaction: trx });\r\n              }\r\n\r\n              if (isEmpty(cleanRelationData.connect)) {\r\n                continue;\r\n              }\r\n\r\n              // Fetch current relations to handle ordering\r\n              let currentMovingRels: Record<string, ID>[] = [];\r\n\r\n              if (hasOrderColumn(attribute) || hasInverseOrderColumn(attribute)) {\r\n                currentMovingRels = await this.createQueryBuilder(joinTable.name)\r\n                  .select(select)\r\n                  .where({\r\n                    [joinColumn.name]: id,\r\n                    [inverseJoinColumn.name]: { $in: relIdsToaddOrMove },\r\n                  })\r\n                  .where(joinTable.on || {})\r\n                  .transacting(trx)\r\n                  .execute();\r\n              }\r\n\r\n              // prepare relations to insert\r\n              const insert = uniqBy('id', cleanRelationData.connect).map((relToAdd) => ({\r\n                [joinColumn.name]: id,\r\n                [inverseJoinColumn.name]: relToAdd.id,\r\n                ...(joinTable.on || {}),\r\n                ...(relToAdd.__pivot || {}),\r\n              }));\r\n\r\n              if (hasOrderColumn(attribute)) {\r\n                // Get all adjacent relations and the one with the highest order\r\n                const adjacentRelations = await this.createQueryBuilder(joinTable.name)\r\n                  .where({\r\n                    $or: [\r\n                      {\r\n                        [joinColumn.name]: id,\r\n                        [inverseJoinColumn.name]: {\r\n                          $in: compact(\r\n                            cleanRelationData.connect?.map(\r\n                              (r) => r.position?.after || r.position?.before\r\n                            )\r\n                          ),\r\n                        },\r\n                      },\r\n                      {\r\n                        [joinColumn.name]: id,\r\n                        [orderColumnName]: this.createQueryBuilder(joinTable.name)\r\n                          .max(orderColumnName)\r\n                          .where({ [joinColumn.name]: id })\r\n                          .where(joinTable.on || {})\r\n                          .transacting(trx)\r\n                          .getKnexQuery(),\r\n                      },\r\n                    ],\r\n                  })\r\n                  .where(joinTable.on || {})\r\n                  .transacting(trx)\r\n                  .execute<Array<Record<string, any>>>();\r\n\r\n                const orderMap = relationsOrderer(\r\n                  adjacentRelations,\r\n                  inverseJoinColumn.name,\r\n                  joinTable.orderColumnName,\r\n                  cleanRelationData.options?.strict\r\n                )\r\n                  .connect(cleanRelationData.connect ?? [])\r\n                  .getOrderMap();\r\n\r\n                insert.forEach((row) => {\r\n                  row[orderColumnName] = orderMap[row[inverseJoinColumn.name]];\r\n                });\r\n              }\r\n\r\n              // add inv order value\r\n              if (hasInverseOrderColumn(attribute)) {\r\n                const nonExistingRelsIds: ID[] = difference(\r\n                  relIdsToaddOrMove,\r\n                  map(inverseJoinColumn.name, currentMovingRels)\r\n                );\r\n\r\n                const maxResults = await db\r\n                  .getConnection()\r\n                  .select(inverseJoinColumn.name)\r\n                  .max(inverseOrderColumnName, { as: 'max' })\r\n                  .whereIn(inverseJoinColumn.name, nonExistingRelsIds)\r\n                  .where(joinTable.on || {})\r\n                  .groupBy(inverseJoinColumn.name)\r\n                  .from(joinTable.name)\r\n                  .transacting(trx);\r\n\r\n                const maxMap = maxResults.reduce(\r\n                  (acc, res) => Object.assign(acc, { [res[inverseJoinColumn.name]]: res.max }),\r\n                  {}\r\n                );\r\n\r\n                insert.forEach((row) => {\r\n                  row[inverseOrderColumnName] = (maxMap[row[inverseJoinColumn.name]] || 0) + 1;\r\n                });\r\n              }\r\n\r\n              // insert rows\r\n              const query = this.createQueryBuilder(joinTable.name)\r\n                .insert(insert)\r\n                .onConflict(joinTable.pivotColumns)\r\n                .transacting(trx);\r\n\r\n              if (hasOrderColumn(attribute)) {\r\n                query.merge([orderColumnName]);\r\n              } else {\r\n                query.ignore();\r\n              }\r\n\r\n              await query.execute();\r\n\r\n              // remove gap between orders\r\n              await cleanOrderColumns({ attribute, db, id, transaction: trx });\r\n            } else {\r\n              if (isAnyToOne(attribute)) {\r\n                cleanRelationData.set = cleanRelationData.set?.slice(-1);\r\n              }\r\n              // overwrite all relations\r\n              relIdsToaddOrMove = toIds(cleanRelationData.set);\r\n              await deleteRelations({\r\n                id,\r\n                attribute,\r\n                db,\r\n                relIdsToDelete: 'all',\r\n                relIdsToNotDelete: relIdsToaddOrMove,\r\n                transaction: trx,\r\n              });\r\n\r\n              if (isEmpty(cleanRelationData.set)) {\r\n                continue;\r\n              }\r\n\r\n              const insert = uniqBy('id', cleanRelationData.set).map((relToAdd) => ({\r\n                [joinColumn.name]: id,\r\n                [inverseJoinColumn.name]: relToAdd.id,\r\n                ...(joinTable.on || {}),\r\n                ...(relToAdd.__pivot || {}),\r\n              }));\r\n\r\n              // add order value\r\n              if (hasOrderColumn(attribute)) {\r\n                insert.forEach((row, idx) => {\r\n                  row[orderColumnName] = idx + 1;\r\n                });\r\n              }\r\n\r\n              // add inv order value\r\n              if (hasInverseOrderColumn(attribute)) {\r\n                const existingRels = await this.createQueryBuilder(joinTable.name)\r\n                  .select(inverseJoinColumn.name)\r\n                  .where({\r\n                    [joinColumn.name]: id,\r\n                    [inverseJoinColumn.name]: { $in: relIdsToaddOrMove },\r\n                  })\r\n                  .where(joinTable.on || {})\r\n                  .transacting(trx)\r\n                  .execute<Array<Record<string, ID>>>();\r\n\r\n                const inverseRelsIds = map(inverseJoinColumn.name, existingRels);\r\n\r\n                const nonExistingRelsIds = difference(relIdsToaddOrMove, inverseRelsIds);\r\n\r\n                const maxResults = await db\r\n                  .getConnection()\r\n                  .select(inverseJoinColumn.name)\r\n                  .max(inverseOrderColumnName, { as: 'max' })\r\n                  .whereIn(inverseJoinColumn.name, nonExistingRelsIds)\r\n                  .where(joinTable.on || {})\r\n                  .groupBy(inverseJoinColumn.name)\r\n                  .from(joinTable.name)\r\n                  .transacting(trx);\r\n\r\n                const maxMap = maxResults.reduce(\r\n                  (acc, res) => Object.assign(acc, { [res[inverseJoinColumn.name]]: res.max }),\r\n                  {}\r\n                );\r\n\r\n                insert.forEach((row: any) => {\r\n                  row[inverseOrderColumnName] = (maxMap[row[inverseJoinColumn.name]] || 0) + 1;\r\n                });\r\n              }\r\n\r\n              // insert rows\r\n              const query = this.createQueryBuilder(joinTable.name)\r\n                .insert(insert)\r\n                .onConflict(joinTable.pivotColumns)\r\n                .transacting(trx);\r\n\r\n              if (hasOrderColumn(attribute)) {\r\n                query.merge([orderColumnName]);\r\n              } else {\r\n                query.ignore();\r\n              }\r\n\r\n              await query.execute();\r\n            }\r\n\r\n            // Delete the previous relations for oneToAny relations\r\n            if (isBidirectional(attribute) && isOneToAny(attribute)) {\r\n              await deletePreviousOneToAnyRelations({\r\n                id,\r\n                attribute,\r\n                relIdsToadd: relIdsToaddOrMove,\r\n                db,\r\n                transaction: trx,\r\n              });\r\n            }\r\n\r\n            // Delete the previous relations for anyToOne relations\r\n            if (isAnyToOne(attribute)) {\r\n              await deletePreviousAnyToOneRelations({\r\n                id,\r\n                attribute,\r\n                relIdToadd: relIdsToaddOrMove[0],\r\n                db,\r\n                transaction: trx,\r\n              });\r\n            }\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Delete relational associations of an existing entity\r\n     * This removes associations but doesn't do cascade deletions for components for example. This will be handled on the entity service layer instead\r\n     * NOTE: Most of the deletion should be handled by ON DELETE CASCADE for dialects that have FKs\r\n     *\r\n     * @param {EntityManager} em - entity manager instance\r\n     * @param {Metadata} metadata - model metadta\r\n     * @param {ID} id - entity ID\r\n     */\r\n    async deleteRelations(uid, id, options) {\r\n      const { attributes } = db.metadata.get(uid);\r\n      const { transaction: trx } = options ?? {};\r\n\r\n      for (const attributeName of Object.keys(attributes)) {\r\n        const attribute = attributes[attributeName];\r\n\r\n        if (attribute.type !== 'relation') {\r\n          continue;\r\n        }\r\n\r\n        /*\r\n          if morphOne | morphMany\r\n            if morphBy is morphToOne\r\n              set null\r\n            if morphBy is morphToOne\r\n              delete links\r\n        */\r\n        if (attribute.relation === 'morphOne' || attribute.relation === 'morphMany') {\r\n          const { target, morphBy } = attribute;\r\n\r\n          const targetAttribute = db.metadata.get(target).attributes[morphBy];\r\n\r\n          if (targetAttribute.type === 'relation' && targetAttribute.relation === 'morphToOne') {\r\n            // set columns\r\n            const { idColumn, typeColumn } = targetAttribute.morphColumn;\r\n\r\n            await this.createQueryBuilder(target)\r\n              .update({ [idColumn.name]: null, [typeColumn.name]: null })\r\n              .where({ [idColumn.name]: id, [typeColumn.name]: uid })\r\n              .transacting(trx)\r\n              .execute();\r\n          } else if (\r\n            targetAttribute.type === 'relation' &&\r\n            targetAttribute.relation === 'morphToMany'\r\n          ) {\r\n            const { joinTable } = targetAttribute;\r\n            const { morphColumn } = joinTable;\r\n\r\n            const { idColumn, typeColumn } = morphColumn;\r\n\r\n            await this.createQueryBuilder(joinTable.name)\r\n              .delete()\r\n              .where({\r\n                [idColumn.name]: id,\r\n                [typeColumn.name]: uid,\r\n                ...(joinTable.on || {}),\r\n                field: attributeName,\r\n              })\r\n              .transacting(trx)\r\n              .execute();\r\n          }\r\n\r\n          continue;\r\n        }\r\n\r\n        /*\r\n          if morphToOne\r\n            nothing to do\r\n        */\r\n        if (attribute.relation === 'morphToOne') {\r\n          // do nothing\r\n        }\r\n\r\n        /*\r\n            if morphToMany\r\n            delete links\r\n        */\r\n        if (attribute.relation === 'morphToMany') {\r\n          const { joinTable } = attribute;\r\n          const { joinColumn } = joinTable;\r\n\r\n          await this.createQueryBuilder(joinTable.name)\r\n            .delete()\r\n            .where({\r\n              [joinColumn.name]: id,\r\n              ...(joinTable.on || {}),\r\n            })\r\n            .transacting(trx)\r\n            .execute();\r\n\r\n          continue;\r\n        }\r\n\r\n        // do not need to delete links when using foreign keys\r\n        if (db.dialect.usesForeignKeys()) {\r\n          return;\r\n        }\r\n\r\n        // NOTE: we do not remove existing associations with the target as it should handled by unique FKs instead\r\n        if ('joinColumn' in attribute && attribute.joinColumn && attribute.owner) {\r\n          // nothing to do => relation already added on the table\r\n          continue;\r\n        }\r\n\r\n        // oneToOne oneToMany on the non owning side.\r\n        if ('joinColumn' in attribute && attribute.joinColumn && !attribute.owner) {\r\n          // need to set the column on the target\r\n          const { target } = attribute;\r\n\r\n          await this.createQueryBuilder(target)\r\n            .where({ [attribute.joinColumn.referencedColumn]: id })\r\n            .update({ [attribute.joinColumn.referencedColumn]: null })\r\n            .transacting(trx)\r\n            .execute();\r\n        }\r\n\r\n        if ('joinTable' in attribute && attribute.joinTable) {\r\n          await deleteRelations({ id, attribute, db, relIdsToDelete: 'all', transaction: trx });\r\n        }\r\n      }\r\n    },\r\n\r\n    // TODO: add lifecycle events\r\n    async populate(uid, entity, populate) {\r\n      const entry = await this.findOne(uid, {\r\n        select: ['id'],\r\n        where: { id: entity.id },\r\n        populate,\r\n      });\r\n\r\n      return { ...entity, ...entry };\r\n    },\r\n\r\n    // TODO: add lifecycle events\r\n    async load(uid, entity, fields, populate) {\r\n      const { attributes } = db.metadata.get(uid);\r\n\r\n      const fieldsArr = castArray(fields);\r\n      fieldsArr.forEach((field) => {\r\n        const attribute = attributes[field];\r\n\r\n        if (!attribute || attribute.type !== 'relation') {\r\n          throw new Error(`Invalid load. Expected ${field} to be a relational attribute`);\r\n        }\r\n      });\r\n\r\n      const entry = await this.findOne(uid, {\r\n        select: ['id'],\r\n        where: { id: entity.id },\r\n        populate: fieldsArr.reduce(\r\n          (acc, field) => {\r\n            acc[field] = populate || true;\r\n            return acc;\r\n          },\r\n          {} as Record<string, unknown>\r\n        ),\r\n      });\r\n\r\n      if (!entry) {\r\n        return null;\r\n      }\r\n\r\n      if (Array.isArray(fields)) {\r\n        return pick(fields, entry);\r\n      }\r\n\r\n      return entry[fields];\r\n    },\r\n\r\n    // cascading\r\n    // aggregations\r\n    // -> avg\r\n    // -> min\r\n    // -> max\r\n    // -> grouping\r\n\r\n    // formulas\r\n    // custom queries\r\n\r\n    // utilities\r\n    // -> map result\r\n    // -> map input\r\n\r\n    // extra features\r\n    // -> virtuals\r\n    // -> private\r\n\r\n    createQueryBuilder(uid) {\r\n      return createQueryBuilder(uid, db);\r\n    },\r\n\r\n    getRepository(uid) {\r\n      if (!repoMap[uid]) {\r\n        repoMap[uid] = createRepository(uid, db);\r\n      }\r\n\r\n      return repoMap[uid];\r\n    },\r\n  };\r\n};\r\n","import type { Database } from '..';\r\n\r\nexport interface Options {\r\n  db: Database;\r\n  tableName: string;\r\n}\r\n\r\nexport const createStorage = (opts: Options) => {\r\n  const { db, tableName } = opts;\r\n\r\n  const hasMigrationTable = () => db.getSchemaConnection().hasTable(tableName);\r\n\r\n  const createMigrationTable = () => {\r\n    return db.getSchemaConnection().createTable(tableName, (table) => {\r\n      table.increments('id');\r\n      table.string('name');\r\n      table.datetime('time', { useTz: false });\r\n    });\r\n  };\r\n\r\n  return {\r\n    async logMigration({ name }: { name: string }) {\r\n      await db\r\n        .getConnection()\r\n        .insert({\r\n          name,\r\n          time: new Date(),\r\n        })\r\n        .into(tableName);\r\n    },\r\n\r\n    async unlogMigration({ name }: { name: string }) {\r\n      await db.getConnection(tableName).del().where({ name });\r\n    },\r\n\r\n    async executed() {\r\n      if (!(await hasMigrationTable())) {\r\n        await createMigrationTable();\r\n        return [];\r\n      }\r\n\r\n      const logs = await db.getConnection(tableName).select().from(tableName).orderBy('time');\r\n\r\n      return logs.map((log: { name: string }) => log.name);\r\n    },\r\n  };\r\n};\r\n","import type { Resolver } from 'umzug';\r\nimport type { Knex } from 'knex';\r\n\r\nimport type { Database } from '..';\r\n\r\nexport interface UserMigrationProvider {\r\n  shouldRun(): Promise<boolean>;\r\n  up(): Promise<void>;\r\n  down(): Promise<void>;\r\n}\r\n\r\nexport interface InternalMigrationProvider {\r\n  register(migration: Migration): void;\r\n  shouldRun(): Promise<boolean>;\r\n  up(): Promise<void>;\r\n  down(): Promise<void>;\r\n}\r\nexport interface MigrationProvider {\r\n  providers: { internal: InternalMigrationProvider };\r\n  shouldRun(): Promise<boolean>;\r\n  up(): Promise<void>;\r\n  down(): Promise<void>;\r\n}\r\n\r\nexport type Context = { db: Database };\r\n\r\nexport type MigrationResolver = Resolver<Context>;\r\n\r\nexport type MigrationFn = (knex: Knex.Transaction, db: Database) => Promise<void>;\r\n\r\nexport type Migration = {\r\n  name: string;\r\n  up: MigrationFn;\r\n  down: MigrationFn;\r\n};\r\n\r\nexport const wrapTransaction = (db: Database) => (fn: MigrationFn) => () => {\r\n  return db.transaction(({ trx }) => Promise.resolve(fn(trx, db)));\r\n};\r\n","export const transformLogMessage = (level: string, message: unknown) => {\r\n  if (typeof message === 'string') {\r\n    return { level, message };\r\n  }\r\n\r\n  if (typeof message === 'object' && message !== null) {\r\n    if ('event' in message && 'name' in message) {\r\n      return {\r\n        level,\r\n        message: `[internal migration]: ${message.event} ${message?.name}`,\r\n        timestamp: Date.now(),\r\n      };\r\n    }\r\n  }\r\n\r\n  // NOTE: the message typing are too loose so in practice we should never arrive here.\r\n  return '';\r\n};\r\n","import fse from 'fs-extra';\r\nimport { Umzug } from 'umzug';\r\n\r\nimport { createStorage } from './storage';\r\nimport { wrapTransaction } from './common';\r\nimport { transformLogMessage } from './logger';\r\n\r\nimport type { MigrationResolver, UserMigrationProvider } from './common';\r\nimport type { Database } from '..';\r\n\r\n// TODO: check multiple commands in one sql statement\r\nconst migrationResolver: MigrationResolver = ({ name, path, context }) => {\r\n  const { db } = context;\r\n\r\n  if (!path) {\r\n    throw new Error(`Migration ${name} has no path`);\r\n  }\r\n\r\n  // if sql file run with knex raw\r\n  if (path.match(/\\.sql$/)) {\r\n    const sql = fse.readFileSync(path, 'utf8');\r\n\r\n    return {\r\n      name,\r\n      up: wrapTransaction(db)((knex) => knex.raw(sql)),\r\n      async down() {\r\n        throw new Error('Down migration is not supported for sql files');\r\n      },\r\n    };\r\n  }\r\n\r\n  // NOTE: we can add some ts register if we want to handle ts migration files at some point\r\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n  const migration = require(path);\r\n  return {\r\n    name,\r\n    up: wrapTransaction(db)(migration.up),\r\n    down: wrapTransaction(db)(migration.down),\r\n  };\r\n};\r\n\r\nexport const createUserMigrationProvider = (db: Database): UserMigrationProvider => {\r\n  const dir = db.config.settings.migrations.dir;\r\n\r\n  fse.ensureDirSync(dir);\r\n\r\n  const context = { db };\r\n\r\n  const umzugProvider = new Umzug({\r\n    storage: createStorage({ db, tableName: 'strapi_migrations' }),\r\n    logger: {\r\n      info(message) {\r\n        // NOTE: only log internal migration in debug mode\r\n        db.logger.info(transformLogMessage('info', message));\r\n      },\r\n      warn(message) {\r\n        db.logger.warn(transformLogMessage('warn', message));\r\n      },\r\n      error(message) {\r\n        db.logger.error(transformLogMessage('error', message));\r\n      },\r\n      debug(message) {\r\n        db.logger.debug(transformLogMessage('debug', message));\r\n      },\r\n    },\r\n    context,\r\n    migrations: {\r\n      glob: ['*.{js,sql}', { cwd: dir }],\r\n      resolve: migrationResolver,\r\n    },\r\n  });\r\n\r\n  return {\r\n    async shouldRun() {\r\n      const pendingMigrations = await umzugProvider.pending();\r\n      return pendingMigrations.length > 0 && db.config?.settings?.runMigrations === true;\r\n    },\r\n    async up() {\r\n      await umzugProvider.up();\r\n    },\r\n    async down() {\r\n      await umzugProvider.down();\r\n    },\r\n  };\r\n};\r\n","/**\r\n * NOTE: This migration avoids using the `identifiers` utility.\r\n * As the `5.0.0-01-convert-identifiers-long-than-max-length`\r\n * migration does not convert the `localizations` join tables, as they are not\r\n * tables that exist anymore in v5 and are not in the db metadata.\r\n *\r\n * This migration therefore relies on the fact that those tables still exist, and\r\n * references them directly.\r\n *\r\n * Database join table name: `categories_localizations_links`\r\n * Actual `identifiers` returned join table name: `categories_localizations_lnk`\r\n *\r\n */\r\nimport { createId } from '@paralleldrive/cuid2';\r\nimport { snakeCase } from 'lodash/fp';\r\nimport type { Knex } from 'knex';\r\n\r\nimport type { Migration } from '../common';\r\nimport type { Database } from '../..';\r\nimport type { Meta } from '../../metadata';\r\n\r\ninterface Params {\r\n  joinColumn: string;\r\n  inverseJoinColumn: string;\r\n  tableName: string;\r\n  joinTableName: string;\r\n}\r\n\r\nconst QUERIES = {\r\n  async postgres(knex: Knex, params: Params) {\r\n    const res = await knex.raw(\r\n      `\r\n    SELECT :tableName:.id as id, string_agg(DISTINCT :inverseJoinColumn:::character varying, ',') as other_ids\r\n    FROM :tableName:\r\n    LEFT JOIN :joinTableName: ON :tableName:.id = :joinTableName:.:joinColumn:\r\n    WHERE :tableName:.document_id IS NULL\r\n    GROUP BY :tableName:.id, :joinTableName:.:joinColumn:\r\n    LIMIT 1;\r\n  `,\r\n      params\r\n    );\r\n\r\n    return res.rows;\r\n  },\r\n  async mysql(knex: Knex, params: Params) {\r\n    const [res] = await knex.raw(\r\n      `\r\n    SELECT :tableName:.id as id, group_concat(DISTINCT :inverseJoinColumn:) as other_ids\r\n    FROM :tableName:\r\n    LEFT JOIN :joinTableName: ON :tableName:.id = :joinTableName:.:joinColumn:\r\n    WHERE :tableName:.document_id IS NULL\r\n    GROUP BY :tableName:.id, :joinTableName:.:joinColumn:\r\n    LIMIT 1;\r\n  `,\r\n      params\r\n    );\r\n\r\n    return res;\r\n  },\r\n  async sqlite(knex: Knex, params: Params) {\r\n    return knex.raw(\r\n      `\r\n    SELECT :tableName:.id as id, group_concat(DISTINCT :inverseJoinColumn:) as other_ids\r\n    FROM :tableName:\r\n    LEFT JOIN :joinTableName: ON :tableName:.id = :joinTableName:.:joinColumn:\r\n    WHERE :tableName:.document_id IS NULL\r\n    GROUP BY :joinTableName:.:joinColumn:\r\n    LIMIT 1;\r\n    `,\r\n      params\r\n    );\r\n  },\r\n};\r\n\r\nconst getNextIdsToCreateDocumentId = async (\r\n  db: Database,\r\n  knex: Knex,\r\n  {\r\n    joinColumn,\r\n    inverseJoinColumn,\r\n    tableName,\r\n    joinTableName,\r\n  }: {\r\n    joinColumn: string;\r\n    inverseJoinColumn: string;\r\n    tableName: string;\r\n    joinTableName: string;\r\n  }\r\n): Promise<number[]> => {\r\n  const res = await QUERIES[db.dialect.client as keyof typeof QUERIES](knex, {\r\n    joinColumn,\r\n    inverseJoinColumn,\r\n    tableName,\r\n    joinTableName,\r\n  });\r\n\r\n  if (res.length > 0) {\r\n    const row = res[0];\r\n    const otherIds = row.other_ids\r\n      ? row.other_ids.split(',').map((v: string) => parseInt(v, 10))\r\n      : [];\r\n\r\n    return [row.id, ...otherIds];\r\n  }\r\n\r\n  return [];\r\n};\r\n\r\n// Migrate document ids for tables that have localizations\r\nconst migrateDocumentIdsWithLocalizations = async (db: Database, knex: Knex, meta: Meta) => {\r\n  const singularName = meta.singularName.toLowerCase();\r\n  const joinColumn = snakeCase(`${singularName}_id`);\r\n  const inverseJoinColumn = snakeCase(`inv_${singularName}_id`);\r\n  let ids: number[];\r\n\r\n  do {\r\n    ids = await getNextIdsToCreateDocumentId(db, knex, {\r\n      joinColumn,\r\n      inverseJoinColumn,\r\n      tableName: meta.tableName,\r\n      joinTableName: snakeCase(`${meta.tableName}_localizations_links`),\r\n    });\r\n\r\n    if (ids.length > 0) {\r\n      await knex(meta.tableName).update({ document_id: createId() }).whereIn('id', ids);\r\n    }\r\n  } while (ids.length > 0);\r\n};\r\n\r\n// Migrate document ids for tables that don't have localizations\r\nconst migrationDocumentIds = async (db: Database, knex: Knex, meta: Meta) => {\r\n  let updatedRows: number;\r\n\r\n  do {\r\n    updatedRows = await knex(meta.tableName)\r\n      .update({ document_id: createId() })\r\n      .whereIn(\r\n        'id',\r\n        knex(meta.tableName)\r\n          .select('id')\r\n          .from(knex(meta.tableName).select('id').whereNull('document_id').limit(1).as('sub_query'))\r\n      );\r\n  } while (updatedRows > 0);\r\n};\r\n\r\nconst createDocumentIdColumn = async (knex: Knex, tableName: string) => {\r\n  await knex.schema.alterTable(tableName, (table) => {\r\n    table.string('document_id');\r\n  });\r\n};\r\n\r\nconst hasLocalizationsJoinTable = async (knex: Knex, tableName: string) => {\r\n  const joinTableName = snakeCase(`${tableName}_localizations_links`);\r\n  return knex.schema.hasTable(joinTableName);\r\n};\r\n\r\nexport const createdDocumentId: Migration = {\r\n  name: '5.0.0-02-created-document-id',\r\n  async up(knex, db) {\r\n    // do sth\r\n    for (const meta of db.metadata.values()) {\r\n      const hasTable = await knex.schema.hasTable(meta.tableName);\r\n\r\n      if (!hasTable) {\r\n        continue;\r\n      }\r\n\r\n      if ('documentId' in meta.attributes) {\r\n        // add column if doesn't exist\r\n        const hasDocumentIdColumn = await knex.schema.hasColumn(meta.tableName, 'document_id');\r\n\r\n        if (hasDocumentIdColumn) {\r\n          continue;\r\n        }\r\n\r\n        await createDocumentIdColumn(knex, meta.tableName);\r\n\r\n        if (await hasLocalizationsJoinTable(knex, meta.tableName)) {\r\n          await migrateDocumentIdsWithLocalizations(db, knex, meta);\r\n        } else {\r\n          await migrationDocumentIds(db, knex, meta);\r\n        }\r\n      }\r\n    }\r\n  },\r\n  async down() {\r\n    throw new Error('not implemented');\r\n  },\r\n};\r\n","import type { Knex } from 'knex';\r\nimport createDebug from 'debug';\r\nimport type { Migration } from '../common';\r\nimport type { Metadata } from '../../metadata';\r\nimport { type Database } from '../..';\r\nimport { identifiers } from '../../utils/identifiers';\r\n\r\nconst debug = createDebug('strapi::database::migration');\r\n\r\ntype NameDiff<T> = {\r\n  short: T;\r\n  full: T;\r\n};\r\n\r\ntype IndexDiff = NameDiff<{ index: number; key: string; tableName: string; indexName: string }>;\r\n\r\n// key isn't really used except for debugging, but it's helpful to track down problems\r\ntype IdentifierDiffs = {\r\n  indexes: IndexDiff[];\r\n  tables: NameDiff<{ index: number; key: string; tableName: string }>[];\r\n  columns: NameDiff<{ index: number; key: string; tableName: string; columnName: string }>[];\r\n};\r\n\r\nexport const renameIdentifiersLongerThanMaxLength: Migration = {\r\n  name: '5.0.0-rename-identifiers-longer-than-max-length',\r\n  async up(knex, db) {\r\n    const md = db.metadata;\r\n\r\n    const diffs = findDiffs(md);\r\n    // migrate indexes before tables so we know to target the original tableName\r\n    for (const indexDiff of diffs.indexes) {\r\n      await renameIndex(knex, db, indexDiff);\r\n    }\r\n\r\n    // migrate columns before table names so we know to target the original tableName\r\n    for (const columnDiff of diffs.columns) {\r\n      const { full, short } = columnDiff;\r\n      const tableName = full.tableName;\r\n\r\n      const hasTable = await knex.schema.hasTable(tableName);\r\n\r\n      if (hasTable) {\r\n        // tablebuilder methods MUST be synchronous and so you cannot use async inside it, which is why we check the column here\r\n        const hasColumn = await knex.schema.hasColumn(tableName, full.columnName);\r\n\r\n        if (hasColumn) {\r\n          await knex.schema.alterTable(tableName, async (table) => {\r\n            debug(`renaming column ${full.columnName} to ${short.columnName}`);\r\n            table.renameColumn(full.columnName, short.columnName);\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // migrate table names\r\n    for (const tableDiff of diffs.tables) {\r\n      const hasTable = await knex.schema.hasTable(tableDiff.full.tableName);\r\n\r\n      if (hasTable) {\r\n        debug(`renaming table ${tableDiff.full.tableName} to ${tableDiff.short.tableName}`);\r\n        await knex.schema.renameTable(tableDiff.full.tableName, tableDiff.short.tableName);\r\n      }\r\n    }\r\n  },\r\n  async down() {\r\n    throw new Error('not implemented');\r\n  },\r\n};\r\n\r\nconst renameIndex = async (knex: Knex, db: Database, diff: IndexDiff) => {\r\n  const client = db.config.connection.client;\r\n  const short = diff.short;\r\n  const full = diff.full;\r\n\r\n  if (full.indexName === short.indexName) {\r\n    debug(`not renaming index ${full.indexName} because name hasn't changed`);\r\n    return;\r\n  }\r\n\r\n  // fk indexes can't be easily renamed, and will be recreated by db sync\r\n  // if this misses something due to the loose string matching, it's not critical, it just means index will be rebuilt in db sync\r\n  if (short.indexName.endsWith('fk') || full.indexName.endsWith('fk')) {\r\n    return;\r\n  }\r\n\r\n  debug(`renaming index from ${full.indexName} to ${short.indexName}`);\r\n\r\n  // If schema creation has never actually run before, none of these will exist, and they will throw an error\r\n  // we have no way of running an \"if exists\" other than a per-dialect manual check, which we won't do\r\n  // because even if it fails for some other reason, the schema sync will recreate them anyway\r\n  // Therefore, we wrap this in a nested transaction (considering we are running this migration in a transaction)\r\n  // so that we can suppress the error\r\n  try {\r\n    await knex.transaction(async (trx) => {\r\n      if (client === 'mysql' || client === 'mariadb') {\r\n        await knex\r\n          .raw('ALTER TABLE ?? RENAME INDEX ?? TO ??', [\r\n            full.tableName,\r\n            full.indexName,\r\n            short.indexName,\r\n          ])\r\n          .transacting(trx);\r\n      } else if (client === 'pg' || client === 'postgres') {\r\n        await knex\r\n          .raw('ALTER INDEX ?? RENAME TO ??', [full.indexName, short.indexName])\r\n          .transacting(trx);\r\n      } else if (['sqlite', 'sqlite3', 'better-sqlite3'].includes(client as any)) {\r\n        // SQLite doesn't support renaming, so rather than trying to drop/recreate we'll let db sync handle it\r\n        debug(`SQLite does not support index renaming, not renaming index ${full.indexName}`);\r\n      } else {\r\n        debug(`No db client name matches, not renaming index ${full.indexName}`);\r\n      }\r\n    });\r\n  } catch (err) {\r\n    debug(`error creating index: ${JSON.stringify(err)}`);\r\n  }\r\n};\r\n\r\nconst findDiffs = (shortMap: Metadata) => {\r\n  const diffs = {\r\n    tables: [],\r\n    columns: [],\r\n    indexes: [],\r\n  } as IdentifierDiffs;\r\n\r\n  const shortArr = Array.from(shortMap.entries());\r\n\r\n  shortArr.forEach(([, shortObj], index) => {\r\n    const fullTableName = identifiers.getUnshortenedName(shortObj.tableName);\r\n    if (!fullTableName) {\r\n      throw new Error(`Missing full table name for ${shortObj.tableName}`);\r\n    }\r\n\r\n    // find table name diffs\r\n    if (shortObj.tableName !== fullTableName) {\r\n      diffs.tables.push({\r\n        full: {\r\n          index,\r\n          key: 'tableName',\r\n          tableName: fullTableName,\r\n        },\r\n        short: {\r\n          index,\r\n          key: 'tableName',\r\n          tableName: shortObj.tableName,\r\n        },\r\n      });\r\n    }\r\n\r\n    // find column name diffs\r\n    // eslint-disable-next-line guard-for-in\r\n    for (const attrKey in shortObj.attributes) {\r\n      if (shortObj.attributes[attrKey].type === 'relation') {\r\n        continue;\r\n      }\r\n\r\n      // TODO: add more type checks so we don't need any\r\n      const attr = shortObj.attributes[attrKey] as any;\r\n      const shortColumnName = attr.columnName;\r\n      const longColumnName = identifiers.getUnshortenedName(shortColumnName);\r\n\r\n      if (!shortColumnName || !longColumnName) {\r\n        throw new Error(`missing column name(s) for attribute ${JSON.stringify(attr, null, 2)}`);\r\n      }\r\n      if (shortColumnName && longColumnName && shortColumnName !== longColumnName) {\r\n        diffs.columns.push({\r\n          short: {\r\n            index,\r\n            tableName: fullTableName, // NOTE: this means that we must rename columns before tables\r\n            key: `attributes.${attrKey}`,\r\n            columnName: shortColumnName,\r\n          },\r\n          full: {\r\n            index,\r\n            tableName: fullTableName,\r\n            key: `attributes.${attrKey}`,\r\n            columnName: longColumnName,\r\n          },\r\n        });\r\n      }\r\n    }\r\n\r\n    // find index name diffs\r\n    // eslint-disable-next-line guard-for-in\r\n    for (const attrKey in shortObj.indexes) {\r\n      const shortIndexName = shortObj.indexes[attrKey].name;\r\n      const longIndexName = identifiers.getUnshortenedName(shortIndexName);\r\n      if (!longIndexName) {\r\n        throw new Error(`Missing full index name for ${shortIndexName}`);\r\n      }\r\n\r\n      if (shortIndexName && longIndexName && shortIndexName !== longIndexName) {\r\n        diffs.indexes.push({\r\n          short: {\r\n            index,\r\n            tableName: fullTableName, // NOTE: this means that we must rename columns before tables\r\n            key: `indexes.${attrKey}`,\r\n            indexName: shortIndexName,\r\n          },\r\n          full: {\r\n            index,\r\n            tableName: fullTableName,\r\n            key: `indexes.${attrKey}`,\r\n            indexName: longIndexName,\r\n          },\r\n        });\r\n      }\r\n    }\r\n  });\r\n\r\n  return diffs;\r\n};\r\n","import type { Knex } from 'knex';\r\n\r\nimport type { Migration } from '../common';\r\n\r\n/**\r\n * In v4, content types with disabled i18n did not have any locale column.\r\n * In v5, we need to add a `locale` column to all content types.\r\n * Other downstream migrations will make use of this column.\r\n *\r\n * This function creates the `locale` column if it doesn't exist.\r\n */\r\nconst createLocaleColumn = async (db: Knex, tableName: string) => {\r\n  await db.schema.alterTable(tableName, (table) => {\r\n    table.string('locale');\r\n  });\r\n};\r\n\r\nexport const createdLocale: Migration = {\r\n  name: '5.0.0-03-created-locale',\r\n  async up(knex, db) {\r\n    for (const meta of db.metadata.values()) {\r\n      const hasTable = await knex.schema.hasTable(meta.tableName);\r\n\r\n      if (!hasTable) {\r\n        continue;\r\n      }\r\n\r\n      // Ignore non-content types\r\n      const uid = meta.uid;\r\n      const model = strapi.getModel(uid);\r\n      if (!model) {\r\n        continue;\r\n      }\r\n\r\n      // Create locale column if it doesn't exist\r\n      const hasLocaleColumn = await knex.schema.hasColumn(meta.tableName, 'locale');\r\n\r\n      if (meta.attributes.locale && !hasLocaleColumn) {\r\n        await createLocaleColumn(knex, meta.tableName);\r\n      }\r\n    }\r\n  },\r\n  async down() {\r\n    throw new Error('not implemented');\r\n  },\r\n};\r\n","import type { Knex } from 'knex';\r\n\r\nimport type { Migration } from '../common';\r\n\r\n/**\r\n * In v4, content types with disabled D&P did not have any `published_at` column.\r\n * In v5, we need to add a `published_at` column to all content types.\r\n * Other downstream migrations will make use of this column.\r\n *\r\n * This function creates the `published_at` column if it doesn't exist.\r\n */\r\nconst createPublishedAtColumn = async (db: Knex, tableName: string) => {\r\n  await db.schema.alterTable(tableName, (table) => {\r\n    table.string('published_at');\r\n  });\r\n\r\n  // Non DP content types should have their `published_at` column set to a date\r\n  await db(tableName).update({ published_at: new Date() });\r\n};\r\n\r\nexport const createdPublishedAt: Migration = {\r\n  name: '5.0.0-04-created-published-at',\r\n  async up(knex, db) {\r\n    for (const meta of db.metadata.values()) {\r\n      const hasTable = await knex.schema.hasTable(meta.tableName);\r\n\r\n      if (!hasTable) {\r\n        continue;\r\n      }\r\n\r\n      // Ignore non-content types\r\n      const uid = meta.uid;\r\n      const model = strapi.getModel(uid);\r\n      if (!model) {\r\n        continue;\r\n      }\r\n\r\n      // Create publishedAt column if it doesn't exist\r\n      const hasPublishedAtColumn = await knex.schema.hasColumn(meta.tableName, 'published_at');\r\n\r\n      if (meta.attributes.publishedAt && !hasPublishedAtColumn) {\r\n        await createPublishedAtColumn(knex, meta.tableName);\r\n      }\r\n    }\r\n  },\r\n  async down() {\r\n    throw new Error('not implemented');\r\n  },\r\n};\r\n","/**\r\n * In V4 slug fields contained a unique index.\r\n * In V5 slug fields should not have a unique index.\r\n *\r\n * This migration drops existing unique indexes from slug fields so downstream migrations\r\n * can work on the data without violating the unique index.\r\n */\r\nimport type { Knex } from 'knex';\r\n\r\nimport type { Migration } from '../common';\r\n\r\nconst dropIndex = async (knex: Knex, tableName: string, columnName: string) => {\r\n  try {\r\n    await knex.schema.alterTable(tableName, (table) => {\r\n      // NOTE: Can not use \"identifiers\" utility, as the 5.0.0-01 migration does not rename this particular index\r\n      // to `tableName_columnName_uq`.\r\n      table.dropUnique([columnName], `${tableName}_${columnName}_unique`);\r\n    });\r\n  } catch (error) {\r\n    // If unique index does not exist, do nothing\r\n  }\r\n};\r\n\r\nexport const dropSlugFieldsIndex: Migration = {\r\n  name: '5.0.0-05-drop-slug-fields-index',\r\n  async up(knex, db) {\r\n    for (const meta of db.metadata.values()) {\r\n      const hasTable = await knex.schema.hasTable(meta.tableName);\r\n      if (!hasTable) {\r\n        continue;\r\n      }\r\n\r\n      for (const attribute of Object.values(meta.attributes)) {\r\n        if (attribute.type === 'uid' && attribute.columnName) {\r\n          await dropIndex(knex, meta.tableName, attribute.columnName);\r\n        }\r\n      }\r\n    }\r\n  },\r\n  async down() {\r\n    throw new Error('not implemented');\r\n  },\r\n};\r\n","import type { Migration } from '../common';\r\nimport { createdDocumentId } from './5.0.0-02-document-id';\r\nimport { renameIdentifiersLongerThanMaxLength } from './5.0.0-01-convert-identifiers-long-than-max-length';\r\nimport { createdLocale } from './5.0.0-03-locale';\r\nimport { createdPublishedAt } from './5.0.0-04-published-at';\r\nimport { dropSlugFieldsIndex } from './5.0.0-05-drop-slug-unique-index';\r\n\r\n/**\r\n * List of all the internal migrations. The array order will be the order in which they are executed.\r\n *\r\n * {\r\n *   name: 'some-name',\r\n *   async up(knex: Knex, db: Database) {},\r\n *   async down(knex: Knex, db: Database) {},\r\n * },\r\n */\r\nexport const internalMigrations: Migration[] = [\r\n  renameIdentifiersLongerThanMaxLength,\r\n  createdDocumentId,\r\n  createdLocale,\r\n  createdPublishedAt,\r\n  dropSlugFieldsIndex,\r\n];\r\n","import { Umzug } from 'umzug';\r\n\r\nimport { wrapTransaction } from './common';\r\nimport { internalMigrations } from './internal-migrations';\r\nimport { createStorage } from './storage';\r\nimport { transformLogMessage } from './logger';\r\n\r\nimport type { InternalMigrationProvider, Migration } from './common';\r\nimport type { Database } from '..';\r\n\r\nexport const createInternalMigrationProvider = (db: Database): InternalMigrationProvider => {\r\n  const context = { db };\r\n  const migrations: Migration[] = [...internalMigrations];\r\n\r\n  const umzugProvider = new Umzug({\r\n    storage: createStorage({ db, tableName: 'strapi_migrations_internal' }),\r\n    logger: {\r\n      info(message) {\r\n        // NOTE: only log internal migration in debug mode\r\n        db.logger.debug(transformLogMessage('info', message));\r\n      },\r\n      warn(message) {\r\n        db.logger.warn(transformLogMessage('warn', message));\r\n      },\r\n      error(message) {\r\n        db.logger.error(transformLogMessage('error', message));\r\n      },\r\n      debug(message) {\r\n        db.logger.debug(transformLogMessage('debug', message));\r\n      },\r\n    },\r\n    context,\r\n    migrations: () =>\r\n      migrations.map((migration) => {\r\n        return {\r\n          name: migration.name,\r\n          up: wrapTransaction(context.db)(migration.up),\r\n          down: wrapTransaction(context.db)(migration.down),\r\n        };\r\n      }),\r\n  });\r\n\r\n  return {\r\n    async register(migration: Migration) {\r\n      migrations.push(migration);\r\n    },\r\n    async shouldRun() {\r\n      const pendingMigrations = await umzugProvider.pending();\r\n      return pendingMigrations.length > 0;\r\n    },\r\n    async up() {\r\n      await umzugProvider.up();\r\n    },\r\n    async down() {\r\n      await umzugProvider.down();\r\n    },\r\n  };\r\n};\r\n","import { createUserMigrationProvider } from './users';\r\nimport { createInternalMigrationProvider } from './internal';\r\n\r\nimport type { MigrationProvider, Migration } from './common';\r\nimport type { Database } from '..';\r\n\r\nexport type { MigrationProvider, Migration };\r\n\r\nexport const createMigrationsProvider = (db: Database): MigrationProvider => {\r\n  const userProvider = createUserMigrationProvider(db);\r\n  const internalProvider = createInternalMigrationProvider(db);\r\n  const providers = [userProvider, internalProvider];\r\n\r\n  return {\r\n    providers: {\r\n      internal: internalProvider,\r\n    },\r\n    async shouldRun() {\r\n      const shouldRunResponses = await Promise.all(\r\n        providers.map((provider) => provider.shouldRun())\r\n      );\r\n\r\n      return shouldRunResponses.some((shouldRun) => shouldRun);\r\n    },\r\n    async up() {\r\n      for (const provider of providers) {\r\n        if (await provider.shouldRun()) {\r\n          await provider.up();\r\n        }\r\n      }\r\n    },\r\n    async down() {\r\n      for (const provider of providers) {\r\n        if (await provider.shouldRun()) {\r\n          await provider.down();\r\n        }\r\n      }\r\n    },\r\n  };\r\n};\r\n","import type { Subscriber } from '../types';\r\n\r\n/**\r\n * For each model try to run it's lifecycles function if any is defined\r\n */\r\nexport const modelsLifecyclesSubscriber: Subscriber = async (event) => {\r\n  const { model } = event;\r\n\r\n  if (model.lifecycles && event.action in model.lifecycles) {\r\n    await model.lifecycles[event.action]?.(event);\r\n  }\r\n};\r\n","import _ from 'lodash';\r\nimport type { Event, Subscriber } from '../types';\r\n\r\n// NOTE: we could add onCreate & onUpdate on field level to do this instead\r\nexport const timestampsLifecyclesSubscriber: Subscriber = {\r\n  /**\r\n   * Init createdAt & updatedAt before create\r\n   */\r\n  beforeCreate(event: Event) {\r\n    const { data } = event.params;\r\n\r\n    const now = new Date();\r\n    _.defaults(data, { createdAt: now, updatedAt: now });\r\n  },\r\n\r\n  /**\r\n   * Init createdAt & updatedAt before create\r\n   * @param {Event} event\r\n   */\r\n  beforeCreateMany(event) {\r\n    const { data } = event.params;\r\n\r\n    const now = new Date();\r\n    if (_.isArray(data)) {\r\n      data.forEach((data) => _.defaults(data, { createdAt: now, updatedAt: now }));\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Update updatedAt before update\r\n   * @param {Event} event\r\n   */\r\n  beforeUpdate(event) {\r\n    const { data } = event.params;\r\n\r\n    const now = new Date();\r\n    _.assign(data, { updatedAt: now });\r\n  },\r\n\r\n  /**\r\n   * Update updatedAt before update\r\n   * @param {Event} event\r\n   */\r\n  beforeUpdateMany(event) {\r\n    const { data } = event.params;\r\n\r\n    const now = new Date();\r\n    if (_.isArray(data)) {\r\n      data.forEach((data) => _.assign(data, { updatedAt: now }));\r\n    }\r\n  },\r\n};\r\n","import type { Subscriber } from '../types';\r\n\r\nexport const isValidSubscriber = (subscriber: Subscriber) => {\r\n  return (\r\n    typeof subscriber === 'function' || (typeof subscriber === 'object' && subscriber !== null)\r\n  );\r\n};\r\n\r\nexport { modelsLifecyclesSubscriber } from './models-lifecycles';\r\nexport { timestampsLifecyclesSubscriber } from './timestamps';\r\n","import { strict as assert } from 'assert';\r\n\r\nimport * as subscriberUtils from './subscribers';\r\n\r\nimport type { Action, Event, Params, Subscriber } from './types';\r\nimport type { Database } from '..';\r\n\r\nexport type * from './types';\r\n\r\nexport type State = Record<string, unknown>;\r\nexport type States = Map<Subscriber, State>;\r\n\r\nexport interface Properties {\r\n  params: Params;\r\n  result?: unknown;\r\n}\r\n\r\nexport interface LifecycleProvider {\r\n  subscribe(subscriber: Subscriber): () => void;\r\n  clear(): void;\r\n  run(action: Action, uid: string, properties: Properties, states?: States): Promise<States>;\r\n  createEvent(action: Action, uid: string, properties: Properties, state: State): Event;\r\n}\r\n\r\nexport const createLifecyclesProvider = (db: Database): LifecycleProvider => {\r\n  let subscribers = [\r\n    subscriberUtils.timestampsLifecyclesSubscriber,\r\n    subscriberUtils.modelsLifecyclesSubscriber,\r\n  ];\r\n\r\n  return {\r\n    subscribe(subscriber) {\r\n      assert(\r\n        subscriberUtils.isValidSubscriber(subscriber),\r\n        'Invalid subscriber. Expected function or object'\r\n      );\r\n\r\n      subscribers.push(subscriber);\r\n\r\n      return () => subscribers.splice(subscribers.indexOf(subscriber), 1);\r\n    },\r\n\r\n    clear() {\r\n      subscribers = [];\r\n    },\r\n\r\n    createEvent(action, uid, properties, state): Event {\r\n      const model = db.metadata.get(uid);\r\n\r\n      return {\r\n        action,\r\n        model,\r\n        state,\r\n        ...properties,\r\n      };\r\n    },\r\n\r\n    /**\r\n     * @param {string} action\r\n     * @param {string} uid\r\n     * @param {{ params?: any, result?: any }} properties\r\n     * @param {Map<any, any>} states\r\n     */\r\n    async run(action, uid, properties, states = new Map()) {\r\n      for (let i = 0; i < subscribers.length; i += 1) {\r\n        const subscriber = subscribers[i];\r\n        if (typeof subscriber === 'function') {\r\n          const state = states.get(subscriber) || {};\r\n          const event = this.createEvent(action, uid, properties, state);\r\n          await subscriber(event);\r\n          if (event.state) {\r\n            states.set(subscriber, event.state || state);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        const hasAction = action in subscriber;\r\n        const hasModel = !subscriber.models || subscriber.models.includes(uid);\r\n\r\n        if (hasAction && hasModel) {\r\n          const state = states.get(subscriber) || {};\r\n          const event = this.createEvent(action, uid, properties, state);\r\n\r\n          await subscriber[action]?.(event);\r\n          if (event.state) {\r\n            states.set(subscriber, event.state);\r\n          }\r\n        }\r\n      }\r\n\r\n      return states;\r\n    },\r\n  };\r\n};\r\n","import knex from 'knex';\r\nimport type { Knex } from 'knex';\r\n\r\nconst clientMap = {\r\n  sqlite: 'better-sqlite3',\r\n  mysql: 'mysql2',\r\n  postgres: 'pg',\r\n};\r\n\r\nfunction isClientValid(config: { client?: unknown }): config is { client: keyof typeof clientMap } {\r\n  return Object.keys(clientMap).includes(config.client as string);\r\n}\r\n\r\nexport const createConnection = (userConfig: Knex.Config, strapiConfig?: Partial<Knex.Config>) => {\r\n  if (!isClientValid(userConfig)) {\r\n    throw new Error(`Unsupported database client ${userConfig.client}`);\r\n  }\r\n\r\n  const knexConfig: Knex.Config = { ...userConfig, client: (clientMap as any)[userConfig.client] };\r\n\r\n  // initialization code to run upon opening a new connection\r\n  if (strapiConfig?.pool?.afterCreate) {\r\n    knexConfig.pool = knexConfig.pool || {};\r\n    // if the user has set their own afterCreate in config, we will replace it and call it\r\n    const userAfterCreate = knexConfig.pool?.afterCreate;\r\n    const strapiAfterCreate = strapiConfig.pool.afterCreate;\r\n    knexConfig.pool.afterCreate = (\r\n      conn: unknown,\r\n      done: (err: Error | null | undefined, connection: any) => void\r\n    ) => {\r\n      strapiAfterCreate(conn, (err: Error | null | undefined, nativeConn: any) => {\r\n        if (err) {\r\n          return done(err, nativeConn);\r\n        }\r\n        if (userAfterCreate) {\r\n          return userAfterCreate(nativeConn, done);\r\n        }\r\n        return done(null, nativeConn);\r\n      });\r\n    };\r\n  }\r\n\r\n  return knex(knexConfig);\r\n};\r\n","import { snakeCase } from 'lodash/fp';\r\nimport type { Database } from '../..';\r\nimport type { Relation } from '../../types';\r\nimport { identifiers } from '../../utils/identifiers';\r\n\r\ntype Link = {\r\n  relation: Relation.Bidirectional & { inversedBy: string };\r\n  invRelation: Relation.Bidirectional & { inversedBy: string };\r\n};\r\n\r\nconst getLinksWithoutMappedBy = (db: Database): Array<Link> => {\r\n  const relationsToUpdate: Record<string, Link> = {};\r\n\r\n  db.metadata.forEach((modelMetadata) => {\r\n    const attributes = modelMetadata.attributes;\r\n\r\n    // For each relation attribute, add the joinTable name to tablesToUpdate\r\n    Object.values(attributes).forEach((attribute) => {\r\n      if (attribute.type !== 'relation') {\r\n        return;\r\n      }\r\n\r\n      if ('inversedBy' in attribute && attribute.inversedBy) {\r\n        const invRelation = db.metadata.get(attribute.target).attributes[attribute.inversedBy];\r\n\r\n        // Both relations use inversedBy.\r\n        if ('inversedBy' in invRelation && invRelation.inversedBy) {\r\n          relationsToUpdate[attribute.joinTable.name] = {\r\n            relation: attribute as Relation.Bidirectional & { inversedBy: string },\r\n            invRelation: invRelation as Relation.Bidirectional & { inversedBy: string },\r\n          };\r\n        }\r\n      }\r\n    });\r\n  });\r\n\r\n  return Object.values(relationsToUpdate);\r\n};\r\n\r\nconst isLinkTableEmpty = async (db: Database, linkTableName: string) => {\r\n  // If the table doesn't exist, it's empty\r\n  const exists = await db.getSchemaConnection().hasTable(linkTableName);\r\n  if (!exists) return true;\r\n\r\n  const result = await db.getConnection().from(linkTableName).count('* as count');\r\n  return Number(result[0].count) === 0;\r\n};\r\n\r\n/**\r\n * Validates bidirectional relations before starting the server.\r\n * - If both sides use inversedBy, one of the sides must switch to mappedBy.\r\n *    When this happens, two join tables exist in the database.\r\n *    This makes sure you switch the side which does not delete any data.\r\n *\r\n * @param {*} db\r\n * @return {*}\r\n */\r\nexport const validateBidirectionalRelations = async (db: Database) => {\r\n  const invalidLinks = getLinksWithoutMappedBy(db);\r\n\r\n  for (const { relation, invRelation } of invalidLinks) {\r\n    const modelMetadata = db.metadata.get(invRelation.target);\r\n    const invModelMetadata = db.metadata.get(relation.target);\r\n\r\n    // Generate the join table name based on the relation target table and attribute name.\r\n    const joinTableName = identifiers.getJoinTableName(\r\n      snakeCase(modelMetadata.tableName),\r\n      snakeCase(invRelation.inversedBy)\r\n    );\r\n    const inverseJoinTableName = identifiers.getJoinTableName(\r\n      snakeCase(invModelMetadata.tableName),\r\n      snakeCase(relation.inversedBy)\r\n    );\r\n\r\n    const joinTableEmpty = await isLinkTableEmpty(db, joinTableName);\r\n    const inverseJoinTableEmpty = await isLinkTableEmpty(db, inverseJoinTableName);\r\n\r\n    if (joinTableEmpty) {\r\n      process.emitWarning(\r\n        `Error on attribute \"${invRelation.inversedBy}\" in model \"${modelMetadata.singularName}\" (${modelMetadata.uid}).` +\r\n          ` Please modify your ${modelMetadata.singularName} schema by renaming the key \"inversedBy\" to \"mappedBy\".` +\r\n          ` Ex: { \"inversedBy\": \"${relation.inversedBy}\" } -> { \"mappedBy\": \"${relation.inversedBy}\" }`\r\n      );\r\n    } else if (inverseJoinTableEmpty) {\r\n      // Its safe to delete the inverse join table\r\n      process.emitWarning(\r\n        `Error on attribute \"${relation.inversedBy}\" in model \"${invModelMetadata.singularName}\" (${invModelMetadata.uid}).` +\r\n          ` Please modify your ${invModelMetadata.singularName} schema by renaming the key \"inversedBy\" to \"mappedBy\".` +\r\n          ` Ex: { \"inversedBy\": \"${invRelation.inversedBy}\" } -> { \"mappedBy\": \"${invRelation.inversedBy}\" }`\r\n      );\r\n    } else {\r\n      // Both sides have data in the join table\r\n    }\r\n  }\r\n};\r\n","import { validateBidirectionalRelations } from './bidirectional';\r\n\r\nimport type { Database } from '../..';\r\n\r\n/**\r\n * Validates if relations data and tables are in a valid state before\r\n * starting the server.\r\n */\r\nexport const validateRelations = async (db: Database) => {\r\n  await validateBidirectionalRelations(db);\r\n};\r\n","import { validateRelations } from './relations';\r\n\r\nimport type { Database } from '..';\r\n\r\n/**\r\n * Validate if the database is in a valid state before starting the server.\r\n */\r\nexport async function validateDatabase(db: Database) {\r\n  await validateRelations(db);\r\n}\r\n","import type { Knex } from 'knex';\r\n\r\nimport path from 'node:path';\r\nimport { Dialect, getDialect } from './dialects';\r\nimport { createSchemaProvider, SchemaProvider } from './schema';\r\nimport { createMetadata, Metadata } from './metadata';\r\nimport { createEntityManager, EntityManager } from './entity-manager';\r\nimport { createMigrationsProvider, MigrationProvider } from './migrations';\r\nimport { createLifecyclesProvider, LifecycleProvider } from './lifecycles';\r\nimport { createConnection } from './connection';\r\nimport * as errors from './errors';\r\nimport { Callback, transactionCtx, TransactionObject } from './transaction-context';\r\nimport { validateDatabase } from './validations';\r\nimport type { Model } from './types';\r\nimport type { Migration } from './migrations';\r\nimport { type Identifiers } from './utils/identifiers';\r\n\r\nexport { isKnexQuery } from './utils/knex';\r\n\r\ninterface Settings {\r\n  forceMigration?: boolean;\r\n  runMigrations?: boolean;\r\n  migrations: {\r\n    dir: string;\r\n  };\r\n  [key: string]: unknown;\r\n}\r\n\r\nexport type Logger = Record<\r\n  'info' | 'warn' | 'error' | 'debug',\r\n  (message: string | Record<string, unknown>) => void\r\n>;\r\n\r\nexport interface DatabaseConfig {\r\n  connection: Knex.Config;\r\n  settings: Settings;\r\n  logger?: Logger;\r\n}\r\n\r\nconst afterCreate =\r\n  (db: Database) =>\r\n  (\r\n    nativeConnection: unknown,\r\n    done: (error: Error | null, nativeConnection: unknown) => Promise<void>\r\n  ) => {\r\n    // run initialize for it since commands such as postgres SET and sqlite PRAGMA are per-connection\r\n    db.dialect.initialize(nativeConnection).then(() => {\r\n      return done(null, nativeConnection);\r\n    });\r\n  };\r\n\r\nclass Database {\r\n  connection: Knex;\r\n\r\n  dialect: Dialect;\r\n\r\n  config: DatabaseConfig;\r\n\r\n  metadata: Metadata;\r\n\r\n  schema: SchemaProvider;\r\n\r\n  migrations: MigrationProvider;\r\n\r\n  lifecycles: LifecycleProvider;\r\n\r\n  entityManager: EntityManager;\r\n\r\n  logger: Logger;\r\n\r\n  constructor(config: DatabaseConfig) {\r\n    this.config = {\r\n      ...config,\r\n      settings: {\r\n        forceMigration: true,\r\n        runMigrations: true,\r\n        ...(config.settings ?? {}),\r\n      },\r\n    };\r\n\r\n    this.logger = config.logger ?? console;\r\n\r\n    this.dialect = getDialect(this);\r\n\r\n    let knexConfig: Knex.Config = this.config.connection;\r\n\r\n    // for object connections, we can configure the dialect synchronously\r\n    if (typeof this.config.connection.connection !== 'function') {\r\n      this.dialect.configure();\r\n    }\r\n    // for connection functions, we wrap it so that we can modify it with dialect configure before it reaches knex\r\n    else {\r\n      this.logger.warn(\r\n        'Knex connection functions are currently experimental. Attempting to access the connection object before database initialization will result in errors.'\r\n      );\r\n\r\n      knexConfig = {\r\n        ...this.config.connection,\r\n        connection: async () => {\r\n          // @ts-expect-error confirmed it was a function above\r\n          const conn = await this.config.connection.connection();\r\n          this.dialect.configure(conn);\r\n          return conn;\r\n        },\r\n      };\r\n    }\r\n\r\n    this.metadata = createMetadata([]);\r\n\r\n    this.connection = createConnection(knexConfig, {\r\n      pool: { afterCreate: afterCreate(this) },\r\n    });\r\n\r\n    this.schema = createSchemaProvider(this);\r\n\r\n    this.migrations = createMigrationsProvider(this);\r\n    this.lifecycles = createLifecyclesProvider(this);\r\n\r\n    this.entityManager = createEntityManager(this);\r\n  }\r\n\r\n  async init({ models }: { models: Model[] }) {\r\n    if (typeof this.config.connection.connection === 'function') {\r\n      /*\r\n       * User code needs to be able to access `connection.connection` directly as if\r\n       * it were always an object. For a connection function, that doesn't happen\r\n       * until the pool is created, so we need to do that here\r\n       *\r\n       * TODO: In the next major version, we need to replace all internal code that\r\n       * directly references `connection.connection` prior to init, and make a breaking\r\n       * change that it cannot be relied on to exist before init so that we can call\r\n       * this feature stable.\r\n       */\r\n      this.logger.debug('Forcing Knex to make real connection to db');\r\n\r\n      // sqlite does not support connection pooling so acquireConnection doesn't work\r\n      if (this.config.connection.client === 'sqlite') {\r\n        await this.connection.raw('SELECT 1');\r\n      } else {\r\n        await this.connection.client.acquireConnection();\r\n      }\r\n    }\r\n\r\n    this.metadata.loadModels(models);\r\n    await validateDatabase(this);\r\n    return this;\r\n  }\r\n\r\n  query(uid: string) {\r\n    if (!this.metadata.has(uid)) {\r\n      throw new Error(`Model ${uid} not found`);\r\n    }\r\n\r\n    return this.entityManager.getRepository(uid);\r\n  }\r\n\r\n  inTransaction() {\r\n    return !!transactionCtx.get();\r\n  }\r\n\r\n  transaction(): Promise<TransactionObject>;\r\n  transaction<TCallback extends Callback>(c: TCallback): Promise<ReturnType<TCallback>>;\r\n  async transaction<TCallback extends Callback>(\r\n    cb?: TCallback\r\n  ): Promise<ReturnType<TCallback> | TransactionObject> {\r\n    const notNestedTransaction = !transactionCtx.get();\r\n    const trx = notNestedTransaction\r\n      ? await this.connection.transaction()\r\n      : (transactionCtx.get() as Knex.Transaction);\r\n\r\n    async function commit() {\r\n      if (notNestedTransaction) {\r\n        await transactionCtx.commit(trx);\r\n      }\r\n    }\r\n\r\n    async function rollback() {\r\n      if (notNestedTransaction) {\r\n        await transactionCtx.rollback(trx);\r\n      }\r\n    }\r\n\r\n    if (!cb) {\r\n      return { commit, rollback, get: () => trx };\r\n    }\r\n\r\n    return transactionCtx.run(trx, async () => {\r\n      try {\r\n        const callbackParams = {\r\n          trx,\r\n          commit,\r\n          rollback,\r\n          onCommit: transactionCtx.onCommit,\r\n          onRollback: transactionCtx.onRollback,\r\n        };\r\n        const res = await cb(callbackParams);\r\n        await commit();\r\n        return res;\r\n      } catch (error) {\r\n        await rollback();\r\n        throw error;\r\n      }\r\n    });\r\n  }\r\n\r\n  getSchemaName(): string | undefined {\r\n    return this.connection.client.connectionSettings.schema;\r\n  }\r\n\r\n  getConnection(): Knex;\r\n  getConnection(tableName?: string): Knex.QueryBuilder;\r\n  getConnection(tableName?: string): Knex | Knex.QueryBuilder {\r\n    const schema = this.getSchemaName();\r\n    const connection = tableName ? this.connection(tableName) : this.connection;\r\n    return schema ? connection.withSchema(schema) : connection;\r\n  }\r\n\r\n  // Returns basic info about the database connection\r\n  getInfo() {\r\n    const connectionSettings = this.connection?.client?.connectionSettings || {};\r\n    const client = this.dialect?.client || '';\r\n\r\n    let displayName = '';\r\n    let schema;\r\n\r\n    // For SQLite, get the relative filename\r\n    if (client === 'sqlite') {\r\n      const absolutePath = connectionSettings?.filename;\r\n      if (absolutePath) {\r\n        displayName = path.relative(process.cwd(), absolutePath);\r\n      }\r\n    }\r\n    // For other dialects, get the database name\r\n    else {\r\n      displayName = connectionSettings?.database;\r\n      schema = connectionSettings?.schema;\r\n    }\r\n\r\n    return {\r\n      displayName,\r\n      schema,\r\n      client,\r\n    };\r\n  }\r\n\r\n  getSchemaConnection(trx = this.connection) {\r\n    const schema = this.getSchemaName();\r\n    return schema ? trx.schema.withSchema(schema) : trx.schema;\r\n  }\r\n\r\n  queryBuilder(uid: string) {\r\n    return this.entityManager.createQueryBuilder(uid);\r\n  }\r\n\r\n  async destroy() {\r\n    await this.lifecycles.clear();\r\n    await this.connection.destroy();\r\n  }\r\n}\r\n\r\nexport { Database, errors };\r\nexport type { Model, Identifiers, Migration };\r\n"],"names":["SQL_QUERIES","toStrapiType","index","errors.NotNullError","PostgresClass","MysqlClass","SqliteClass","debug","helpers","dropIndex","createColumn","createTable","table","databaseTable","crypto","types.isScalarAttribute","metadata","types.isRelationalAttribute","isString","types.isScalar","types.isRelation","knex","types.isString","types.isNumber","alias","joinTable","prefix","map","qb","rows","isRecord","helpers.toColumnName","groupBy","helpers.createJoin","helpers.processOrderBy","helpers.processWhere","helpers.processPopulate","helpers.toRow","helpers.applyWhere","helpers.applySearch","helpers.applyJoins","helpers.wrapWithDeepSort","helpers.applyPopulate","helpers.fromRow","helpers.ReadableQuery","strict","_","isNumber","data","path","subscriberUtils.timestampsLifecyclesSubscriber","subscriberUtils.modelsLifecyclesSubscriber","assert","subscriberUtils.isValidSubscriber"],"mappings":"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"}